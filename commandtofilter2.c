/* This file was generated by the Hex-Rays decompiler version 9.0.0.240807.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include "defs.h"
#include "deps.h"


//-------------------------------------------------------------------------
// Function declarations

void __fastcall __noreturn start(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, const char *a7);
int setDeviceOn();
_BOOL8 __fastcall isMessageAvailable(char *spec);
int setDeviceOff();
int setDevice2On();
int setDevice2Off();
int sendLabelPrint();
int __fastcall setMaintenance(char a1);
int __fastcall sendPJLCommand(char *a1);
__int64 isSNMPAvailable();
__int64 CheckBackChannel();
__int64 __fastcall getBackChannelRowData(_BYTE *__dst, int *a2, double a3);
__int64 __fastcall getBackChannelData(double a1);
char *__fastcall convertToUTF8String(char *cStr);
__int64 __fastcall convertSupplyLevel(double a1);
__int64 __fastcall getSideChannelSNMPData(char *__s1, double a2);
__int64 __fastcall getDeviceStatusSub(double a1);
__int64 __fastcall getDeviceStatus(double a1);
char *__fastcall determineStatus(__int64 a1);
char *__fastcall getStandardStatus(char *__s1);
__int64 __fastcall getStatusMessageFromResource(char *cStr); // idb
__int64 __fastcall getStatusMessageFromDevice(double a1);
char *__fastcall convertWarningErrorStatusMessage(char *cStr);
__int64 __fastcall getDeviceSupplyLevels(double a1);
__int64 getDeviceCharCode();
int __fastcall showStatusMessage(__int64 a1);
CFDictionaryRef __fastcall copyPlistfromBundle(__CFBundle *a1, const __CFString *a2);
const void *__fastcall getStatusValue(const __CFDictionary *a1, const void *a2);
__int64 determineModel();
__int64 canBlackPrint();
_BOOL8 canPrintFromAnotherTray();
_BOOL8 isWirelessInterface();
__int64 isBRMaintenanceAvailable();
__int64 isIPPPrinting();
_BOOL8 isCalledFromRasterFiler();
CFBundleRef copyCommandFilterBundle();
int __fastcall main(int argc, const char **argv, const char **envp);
void __fastcall cancelJob();
int dummyPrint();
int startDeviceStatusTimer();
int resetDeviceStatusTimer();
int __fastcall getDeviceStatusAlarm(int a1);
int __fastcall print_self_test_page(char *a1);
int sendNULLData();
int clean_print_head();
void __fastcall setupLanguage();
char *__fastcall BRLocalizedString(char *cStr);
int __fastcall BRPrintInfoMessage(char *a1);
int __fastcall BRPrintErrorMessage(char *a1);
__int64 __fastcall AutoCalibration(double a1);
void __fastcall WalkCallback(const char *a1, const char *a2, int a3, void *a4);
__int64 __fastcall getBackChannelLUTData(double a1);
int infoLUT();
__int64 __fastcall copyCalibDataArray(__int64 a1, const char *a2, int a3);
double __fastcall getTimeout(char *__src);
char *__fastcall copyPJLCommand(char *__s);
char *__fastcall copySerchCommand(char *a1);
char *__fastcall copyOutputPath(char *__s);
int __fastcall changePermissions(char *a1);
__int64 __fastcall createCachesDirectory(char *a1);
__int64 __fastcall makeFolderAndFile(const void *a1, int a2, const char *a3);
__int64 __fastcall saveFileWithData(CFDataRef theData, char *__filename); // idb
__int64 __fastcall runPJLWriteCommand(char *a1);
__int64 deleteTrashData();
__int64 __fastcall runPJLReadCommand(char *__s); // idb
void __fastcall runPJLUtilityCommand(char *a1, char *__s);
void __fastcall runRetriveDataCommand(__int64 a1, char *a2);
__int64 __fastcall BrMakeGammaTable4150(unsigned __int16 *a1, __int16 *a2, __int64 a3, char a4, int a5, unsigned __int8 a6, double a7, __m128d a8, unsigned __int8 a9, unsigned __int8 a10);
void __fastcall CorrectSpline(__int64 *a1, __int64 a2, int a3);
__int64 __fastcall BrMakeGammaTable3150(unsigned __int16 *a1, __int16 *a2, __int64 a3, char a4, int a5, unsigned __int8 a6, double a7, __m128d a8, unsigned __int8 a9, unsigned __int8 a10);
void __fastcall CorrectSpline_0(__int64 *a1, __int64 a2, int a3);
void *__fastcall BRCalibrationGetBRCalibrationModuleInfoWithModelType(_DWORD *a1, _DWORD *a2);
char *__fastcall BRCalibrationGetConfigFileNameWithModelType(_DWORD *a1);
__int64 __fastcall BRCalibrationDetermineModel(const char *a1, int *a2);
bool __fastcall BRCalibrationNeedAutoCalibration(_DWORD *a1, const char *a2, const char *a3);
_BOOL8 __fastcall getPrintersLUTDirPath(const char *a1, char *a2);
_BOOL8 __fastcall getCachesLUTDirPath(const char *a1, const char *a2, char *a3);
__int64 __fastcall removeRecursively(const char *a1);
__int64 __fastcall BRCalibrationCalibration(int **a1, int a2, _DWORD *a3, const char *a4, char *a5);
__int64 __fastcall createDirectory(const __CFURL *a1);
void __fastcall changePermissions_0(char *a1);
__int64 __fastcall BRCalibrationAutoCalibration(int **a1, int a2, _DWORD *a3, const char *a4, const char *a5);
_BOOL8 __fastcall getVendorDirNameFromIconPath(char *__big, char *__dst);
__int64 __fastcall BRCalibrationInfoManagerAutoCalibrationEnabled(const char *a1);
__int64 __fastcall BRCalibrationInfoManagerInitWithPath(char *__s); // idb
__int64 BRCalibrationInfoManagerReadFromFile();
__int64 BRCalibrationInfoManagerDeallocate();
__int64 BRCalibrationInfoManagerWriteToFile();
_BOOL8 BRCalibrationInfoManagerFileExist();
CFTypeRef BRCalibrationInfoManagerData();
void __fastcall BRCalibrationInfoManagerSetData(CFTypeRef cf);
__int64 __fastcall copyPropertyFromURL(_QWORD *a1, const __CFURL *a2);
__int64 __fastcall BRMakeDitherCacheTableFile(unsigned __int8 a1, unsigned __int16 *a2, __int16 *a3, unsigned __int8 a4, const UInt8 *a5, unsigned __int8 a6, double a7, __m128d a8, UInt8 *path, int a10);
__int64 __fastcall BRMakeDitherCacheTableData(unsigned __int8 *a1, int a2, char a3, __int64 a4, int a5, char *a6);
__int64 __fastcall DitheringUseDitherCashTable(char a1, __int64 a2, int a3, int a4, int a5, int a6, int a7, __int64 a8, _BYTE *a9);
__int64 __fastcall removePrefixAndSufixDoubleQuotationChar(char *__dst, size_t __n);
int __fastcall printPJLCommands(const char *a1, int a2);
CFArrayRef __fastcall copyBackChannelWithPJLCommands(char *__little, int a2, double a3);
CFArrayRef __fastcall copySideChannelSNMPDataWithOIDs(char *oid, int a2, double a3);
CFArrayRef __fastcall copyFactorWithFactorOIDHeader(const char *a1, const __CFArray *a2, int a3, double a4);
CFArrayRef __fastcall copyIndexesWithIndexOIDHeader(const char *a1, int a2, double a3);
__int64 __fastcall getCountWithCountOID(const char *a1, double a2);
CFArrayRef __fastcall copyDatasWithPJLCommands(char *__little, int a2, double a3);
CFStringRef __fastcall copyDataWithPJLCommand(const char *a1, double a2);
__int64 __fastcall copyParametersWithOIDs(char *a1, char a2, double a3);
CFArrayRef __fastcall copyIndexesWithCountOID(const char *a1, const char *a2, double a3);
CFArrayRef __fastcall copyFactorWithCountOID(const char *a1, const char *a2, const char *a3, double a4);
_BOOL8 __fastcall getVendorFolderNameWithIconPath(char *__big, char *__dst, int a3);
__int64 __fastcall getCachesLUTFolderPath(char *a1, int a2);
CFDataRef __fastcall copyDataWithFilePath(char *__filename);
CFDictionaryRef copyRetriveDataCheckSumFileDatas();
__int64 __fastcall saveRetriveDataFileWithDict(CFDictionaryRef theDict); // idb
_BOOL8 __fastcall saveRetriveDataFileWithCheckSumAndParameters(CFDictionaryRef theDict, CFDictionaryRef a2);
__int64 __fastcall checkUpdate(double a1);
__int64 __fastcall updateData(double a1);
__int64 __fastcall executeRetriveData(int a1);
CFDataRef __fastcall copyBinaryDataWithHexStringParameter(const __CFArray *a1);
CFDataRef __fastcall copyTrimmedBinaryDataWithHexStringParameter(CFArrayRef theArray);
CFArrayRef __fastcall copyHeadAllTableFactorsWithPJL(double a1);
CFDictionaryRef __fastcall copyRetriveDataParametersWithPJL(double a1);
CFArrayRef __fastcall copyRetriveDataCheckSumParametersWithPJL(double a1);
CFArrayRef __fastcall copyHeadAllTableFactorsWithMIB(double a1);
CFDictionaryRef __fastcall copyRetriveDataParametersWithMIB(double a1);
__int64 __fastcall copyRetriveDataCheckSumParametersWithMIB(double a1);
__int64 __fastcall isNewParameters(const void *a1, const void *a2);
CFDictionaryRef __fastcall copyBinaryParametersWithHexStringParameters(CFDictionaryRef theDict);
CFDictionaryRef __fastcall copyTrimmedBinaryParametersWithHexStringParameters(CFDictionaryRef theDict);
CFDictionaryRef __fastcall copyRetriveDataCheckSumParameters(double a1);
CFDictionaryRef __fastcall copyRetriveDataParameters(double a1);
__int64 __fastcall BrMakeGammaTableNoCalculateModel(unsigned __int16 *a1, __int16 *a2, __int64 a3, char a4, int a5, unsigned __int8 a6, double a7, __m128d a8, unsigned __int8 a9, unsigned __int8 a10, int a11);
void __fastcall CorrectSpline_1(__int64 *a1, __int64 a2, int a3);
// CFAbsoluteTime CFAbsoluteTimeGetCurrent(void);
// void __cdecl CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange);
// CFArrayRef __cdecl CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks);
// CFArrayRef __cdecl CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray);
// CFMutableArrayRef __cdecl CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks);
// CFIndex __cdecl CFArrayGetCount(CFArrayRef theArray);
// CFTypeID CFArrayGetTypeID(void);
// const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx);
// void __cdecl CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value);
// void __cdecl CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value);
// CFStringRef __cdecl CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName);
// CFURLRef __cdecl CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName);
// CFBundleRef __cdecl CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL);
// CFStringRef __cdecl CFBundleGetIdentifier(CFBundleRef bundle);
// CFDictionaryRef __cdecl CFBundleGetInfoDictionary(CFBundleRef bundle);
// CFBundleRef CFBundleGetMainBundle(void);
// void __cdecl CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length);
// CFDataRef __cdecl CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length);
// CFDataRef __cdecl CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData);
// CFMutableDataRef __cdecl CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity);
// CFDataRef __cdecl CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator);
// const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData);
// CFIndex __cdecl CFDataGetLength(CFDataRef theData);
// void __cdecl CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value);
// CFDictionaryRef __cdecl CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks);
// CFDictionaryRef __cdecl CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict);
// CFMutableDictionaryRef __cdecl CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks);
// CFMutableDictionaryRef __cdecl CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict);
// CFIndex __cdecl CFDictionaryGetCount(CFDictionaryRef theDict);
// void __cdecl CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values);
// const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key);
// Boolean __cdecl CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value);
// void __cdecl CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value);
// Boolean __cdecl CFEqual(CFTypeRef cf1, CFTypeRef cf2);
// CFTypeID __cdecl CFGetTypeID(CFTypeRef cf);
// void __cdecl CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID);
// CFDataRef __cdecl CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error);
// CFPropertyListRef __cdecl CFPropertyListCreateFromXMLData(CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString);
// CFPropertyListRef __cdecl CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error);
// void __cdecl CFRelease(CFTypeRef cf);
// CFTypeRef __cdecl CFRetain(CFTypeRef cf);
// CFStringRef __cdecl CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString);
// CFMutableStringRef __cdecl CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString);
// CFStringRef __cdecl CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding);
// CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...);
// void __cdecl CFStringDelete(CFMutableStringRef theString, CFRange range);
// CFRange __cdecl CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions);
// CFIndex __cdecl CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions);
// Boolean __cdecl CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding);
// SInt32 __cdecl CFStringGetIntValue(CFStringRef str);
// CFIndex __cdecl CFStringGetLength(CFStringRef theString);
// CFTypeID CFStringGetTypeID(void);
// Boolean __cdecl CFStringHasSuffix(CFStringRef theString, CFStringRef suffix);
// CFStringRef __cdecl CFURLCopyPath(CFURLRef anURL);
// CFURLRef __cdecl CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url);
// CFDataRef __cdecl CFURLCreateData(CFAllocatorRef allocator, CFURLRef url, CFStringEncoding encoding, Boolean escapeWhitespace);
// Boolean __cdecl CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode);
// CFURLRef __cdecl CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory);
// CFURLRef __cdecl CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory);
// Boolean __cdecl CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen);
// Boolean __cdecl CFURLWriteDataAndPropertiesToResource(CFURLRef url, CFDataRef dataToWrite, CFDictionaryRef propertiesToWrite, SInt32 *errorCode);
// ssize_t __cdecl cupsBackChannelRead(char *buffer, size_t bytes, double timeout);
// char *__cdecl cupsFileGetConf(cups_file_t *fp, char *buf, size_t buflen, char **value, int *linenum);
// cups_file_t *__cdecl cupsFileOpen(const char *filename, const char *mode);
// cups_file_t *cupsFileStdin(void);
// cups_sc_status_t __cdecl cupsSideChannelDoRequest(cups_sc_command_t command, char *data, int *datalen, double timeout);
// cups_sc_status_t __cdecl cupsSideChannelSNMPGet(const char *oid, char *data, int *datalen, double timeout);
// cups_sc_status_t __cdecl cupsSideChannelSNMPWalk(const char *oid, double timeout, cups_sc_walk_func_t cb, void *context);
// void __cdecl ppdClose(ppd_file_t *ppd);
// ppd_attr_t *__cdecl ppdFindAttr(ppd_file_t *ppd, const char *name, const char *spec);
// ppd_file_t *__cdecl ppdOpenFile(const char *filename);
// OSErr __cdecl FSCloseFork(FSIORefNum forkRefNum);
// OSErr __cdecl FSOpenFork(const FSRef *ref, UniCharCount forkNameLength, const UniChar *forkName, SInt8 permissions, FSIORefNum *forkRefNum);
// OSStatus __cdecl FSPathMakeRef(const UInt8 *path, FSRef *ref, Boolean *isDirectory);
// OSErr __cdecl FSReadFork(FSIORefNum forkRefNum, UInt16 positionMode, SInt64 positionOffset, ByteCount requestCount, void *buffer, ByteCount *actualCount);
// OSErr __cdecl FSWriteFork(FSIORefNum forkRefNum, UInt16 positionMode, SInt64 positionOffset, ByteCount requestCount, const void *buffer, ByteCount *actualCount);
// __int64 __fastcall __bzero(_QWORD, _QWORD); weak
// int *__error(void);
// int __sprintf_chk(char *, int, size_t, const char *, ...);
// int __cdecl access(const char *, int);
// double __cdecl atof(const char *);
// int __cdecl atoi(const char *);
// __int64 __cdecl atol(const char *);
// int __cdecl chmod(const char *, mode_t);
// int __cdecl close(int);
// int __cdecl closedir(DIR *);
// int __cdecl creat(const char *, mode_t);
// void __cdecl __noreturn exit(int);
// int __cdecl fclose(FILE *);
// int __cdecl fflush(FILE *);
// FILE *__cdecl fopen(const char *__filename, const char *__mode);
// int fprintf(FILE *, const char *, ...);
// void __cdecl free(void *);
// size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
// int __cdecl getc(FILE *);
// char *__cdecl getenv(const char *);
// int __cdecl gettimeofday(timeval *, void *);
// uid_t getuid(void);
// void *__cdecl malloc(size_t __size);
// void *__cdecl memcpy(void *__dst, const void *__src, size_t __n);
// void __cdecl memset_pattern16(void *__b, const void *__pattern16, size_t __len);
// int __cdecl mkdir(const char *, mode_t);
// DIR *__cdecl opendir_INODE64(const char *);
// int printf(const char *, ...);
// int __cdecl putc(int, FILE *);
// int __cdecl putchar(int);
// int __cdecl puts(const char *);
// dirent *__cdecl readdir_INODE64(DIR *);
// int __cdecl remove(const char *);
// int __cdecl setitimer(int, const itimerval *, itimerval *);
// char *__cdecl setlocale(int, const char *);
// void (__cdecl *__cdecl signal(int, void (__cdecl *)(int)))(int);
// unsigned int __cdecl sleep(unsigned int);
// int sscanf(const char *, const char *, ...);
// int __cdecl stat_INODE64(const char *, stat *);
// int __cdecl strcasecmp(const char *, const char *);
// int __cdecl strcmp(const char *__s1, const char *__s2);
// char *__cdecl strcpy(char *__dst, const char *__src);
// size_t __cdecl strlen(const char *__s);
// int __cdecl strncasecmp(const char *, const char *, size_t);
// int __cdecl strncmp(const char *__s1, const char *__s2, size_t __n);
// char *__cdecl strncpy(char *__dst, const char *__src, size_t __n);
// char *__cdecl strstr(const char *__big, const char *__little);
// char *__cdecl strtok(char *__str, const char *__sep);
// CFDataRef __cdecl _CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length);

//-------------------------------------------------------------------------
// Data declarations

double dbl_100010020[2] = { 5.0, 10.0 }; // weak
_QWORD qword_1000100A0[4] = { 100LL, 10LL, 0LL, 0LL }; // weak
_QWORD qword_1000100C0[4] = { 100LL, 10LL, 0LL, 0LL }; // weak
_UNKNOWN memset_pattern; // weak
__int128 xmmword_100010140 = 0x3000000020000000100000000LL; // weak
__int128 xmmword_100010150 = 0xFFFF0000FFFF0000FFFF0000FFFFLL; // weak
__int128 xmmword_100010160 = 0x437F0000437F0000437F0000437F0000LL; // weak
_DWORD dword_1000101E0[12] = { 1, 2, 3, 4, 5, 7, 6, 8, 9, 0, 0, 0 }; // weak
_DWORD dword_100010210[8] = { 4, 5, 6, 7, 8, 9, 0, 0 }; // weak
_DWORD dword_100010230[8] = { 24, 24, 24, 16, 16, 16, 0, 0 }; // weak
_BYTE ext_ucDataCAPT[12] = { 0, 8, 4, 12, 2, 10, 6, 14, 15, 0, 0, 0 }; // weak
_UNKNOWN kPJLCommandMaxLength; // weak
_UNKNOWN kMIBOIDMaxLength; // weak
_UNKNOWN kMIBResponseMaxLength; // weak
const char kPJLCommandResponseFooder[2] = "\r\n"; // idb
_UNKNOWN *off_100014470 = &kE55Msg; // weak
int (*off_1000144C0[2])[23] = { &gCalib600DPI, &gCalibCAPT }; // weak
char *off_1000144D0[8] =
{
  "@PJL INQUIRE FCYANLUT\r\n",
  "@PJL INQUIRE FMAGENTALUT\r\n",
  "@PJL INQUIRE FYELLOWLUT\r\n",
  "@PJL INQUIRE FBLACKLUT\r\n",
  "@PJL INQUIRE SFCYANLUT\r\n",
  "@PJL INQUIRE SFMAGENTALUT\r\n",
  "@PJL INQUIRE SFYELLOWLUT\r\n",
  "@PJL INQUIRE SFBLACKLUT\r\n"
}; // weak
_UNKNOWN kCalibrationInfo4150; // weak
_UNKNOWN kCalibrationInfo3150; // weak
_UNKNOWN kCalibrationInfoBC2Model; // weak
_UNKNOWN kCalibrationInfoBC4Model; // weak
_UNKNOWN kCalibrationInfoECLModel; // weak
_UNKNOWN kCalibrationInfoDCLUFPModel; // weak
char *off_100015410[6] =
{
  "calib09.plist",
  "calib12.plist",
  "calib12_sp.plist",
  "calib13.plist",
  "calib16.plist",
  "calib17.plist"
}; // weak
_UNKNOWN *off_100015440 = &kCalibrationInfo4150; // weak
__CFString replacementString = { &__CFConstantStringClassReference, 1992LL, "", 0LL }; // idb
char *kWasteFullMsg[11] =
{
  "marker-waste-full-warning",
  "marker-waste-almost-full-report",
  "cover-open-warning",
  "media-low-report",
  "media-empty-warning",
  "media-jam-warning",
  "opc-life-over-report",
  "input-tray-missing-warning",
  "output-area-full-warning",
  "output-tray-missing-warning",
  "service-needed-warning"
}; // weak
char *kWasteNearFullMsg[10] =
{
  "marker-waste-almost-full-report",
  "cover-open-warning",
  "media-low-report",
  "media-empty-warning",
  "media-jam-warning",
  "opc-life-over-report",
  "input-tray-missing-warning",
  "output-area-full-warning",
  "output-tray-missing-warning",
  "service-needed-warning"
}; // weak
char *kCoverOpenMsg[9] =
{
  "cover-open-warning",
  "media-low-report",
  "media-empty-warning",
  "media-jam-warning",
  "opc-life-over-report",
  "input-tray-missing-warning",
  "output-area-full-warning",
  "output-tray-missing-warning",
  "service-needed-warning"
}; // weak
char *kMediaLowMsg[8] =
{
  "media-low-report",
  "media-empty-warning",
  "media-jam-warning",
  "opc-life-over-report",
  "input-tray-missing-warning",
  "output-area-full-warning",
  "output-tray-missing-warning",
  "service-needed-warning"
}; // weak
char *kPaperOutMsg = "media-empty-warning"; // idb
char *kPaperJamMsg = "media-jam-warning"; // idb
char *kBeltOutMsg[5] =
{
  "opc-life-over-report",
  "input-tray-missing-warning",
  "output-area-full-warning",
  "output-tray-missing-warning",
  "service-needed-warning"
}; // weak
char *kNoTrayMsg = "input-tray-missing-warning"; // idb
char *kOutputBinFullMsg[3] =
{
  "output-area-full-warning",
  "output-tray-missing-warning",
  "service-needed-warning"
}; // weak
char *kServiceCallMsg = "service-needed-warning"; // weak
char *kGenericMsg = ""; // idb
char *kTonerLowMsg = ""; // idb
char *kTonerOutMsg = ""; // idb
_UNKNOWN kDrumLowMsg; // weak
_UNKNOWN kWaitMsg; // weak
_UNKNOWN kDeviceMsg; // weak
_UNKNOWN kResolutionMsg; // weak
_UNKNOWN kInsideHotMsg; // weak
_UNKNOWN kUnitHotMsg; // weak
_UNKNOWN kLserUnitOutMsg; // weak
_UNKNOWN kUnitOutMsg; // weak
_UNKNOWN kKitOutMsg; // weak
_UNKNOWN kKit1OutMsg; // weak
_UNKNOWN kKit2OutMsg; // weak
_UNKNOWN kKit3OutMsg; // weak
_UNKNOWN kKit4OutMsg; // weak
_UNKNOWN kKitMPOutMsg; // weak
_UNKNOWN kBeltUnitLowMsg; // weak
_UNKNOWN kBeltUnitOutMsg; // weak
char *kBlackPrintMsg = ""; // idb
char *kNoBlackPrintMsg = ""; // idb
_UNKNOWN kNoDXTrayMsg; // weak
_UNKNOWN kMemoryOutMsg; // weak
_UNKNOWN kOverrunMsg; // weak
_UNKNOWN kA1JamMsg; // weak
_UNKNOWN kA2JamMsg; // weak
_UNKNOWN kBJamMsg; // weak
_UNKNOWN kCJamMsg; // weak
_UNKNOWN kTrayManyMsg; // weak
_UNKNOWN kDrumMsg; // weak
char *kDrumDustMsg = ""; // idb
_UNKNOWN kDrumOut2Msg; // weak
_UNKNOWN kTonerMsg; // weak
_UNKNOWN kTonerEndMsg; // weak
_UNKNOWN kTonerEnd2Msg; // weak
_UNKNOWN kCartridgeMsg; // weak
_UNKNOWN kCartridge2Msg; // weak
_UNKNOWN kCartridge3Msg; // weak
_UNKNOWN kCartridgeOldMsg; // weak
_UNKNOWN kCartridgeColorMsg; // weak
_UNKNOWN kCartridgeStrMsg; // weak
_UNKNOWN kVersionMsg; // weak
_UNKNOWN kPrintMsg; // weak
_UNKNOWN kWasteMissMsg; // weak
_UNKNOWN kBeltMissMsg; // weak
_UNKNOWN kUnitMissMsg; // weak
_UNKNOWN kUnitMsg; // weak
_UNKNOWN kBeltUnitMissMsg; // weak
_UNKNOWN kBeltUnitOut2Msg; // weak
_UNKNOWN kRollerMissMsg; // weak
_UNKNOWN kDrumMissMsg; // weak
_UNKNOWN kDrumOutMsg; // weak
_UNKNOWN kOutputTrayMsg; // weak
_UNKNOWN kDuplexMsg; // weak
_UNKNOWN kSizeMsg; // weak
_UNKNOWN kT1SizeMsg; // weak
_UNKNOWN kT2SizeMsg; // weak
_UNKNOWN kMPSizeMsg; // weak
_UNKNOWN kManualSizeMsg; // weak
_UNKNOWN kTray1SizeMsg; // weak
_UNKNOWN kTray2SizeMsg; // weak
_UNKNOWN kTray3SizeMsg; // weak
_UNKNOWN kTray4SizeMsg; // weak
_UNKNOWN kWrongSizeMsg; // weak
_UNKNOWN kOptionalOutputFullMsg; // weak
_UNKNOWN kAutoSizeMsg; // weak
char *kTonerMissMsg = ""; // idb
_UNKNOWN kTray1MissMsg; // weak
_UNKNOWN kTray2MissMsg; // weak
_UNKNOWN kTray3MissMsg; // weak
_UNKNOWN kTray4MissMsg; // weak
_UNKNOWN kTrayID1MissMsg; // weak
_UNKNOWN kTrayID2MissMsg; // weak
_UNKNOWN kTrayID3MissMsg; // weak
_UNKNOWN kTrayID4MissMsg; // weak
_UNKNOWN kELMsg; // weak
_UNKNOWN kRegistMsg; // weak
_UNKNOWN kBackCoverMsg; // weak
_UNKNOWN kFrontCoverMsg; // weak
char *kDiscGuideMsg = ""; // idb
_UNKNOWN kMPJamMsg; // weak
_UNKNOWN kTray1JamMsg; // weak
_UNKNOWN kTray2JamMsg; // weak
_UNKNOWN kTray3JamMsg; // weak
_UNKNOWN kTray4JamMsg; // weak
_UNKNOWN kInsideJamMsg; // weak
_UNKNOWN kRearJamMsg; // weak
_UNKNOWN kDuplexJamMsg; // weak
_UNKNOWN kDuplexLeverMsg; // weak
_UNKNOWN kOptionJamMsg; // weak
_UNKNOWN kMachineHotMsg; // weak
_UNKNOWN kPrintUnableMsg; // weak
_UNKNOWN kInitUnableMsg; // weak
_UNKNOWN kShortPaperMsg; // weak
_UNKNOWN kSmallPaperMsg; // weak
_UNKNOWN kCondensationMsg; // weak
_UNKNOWN kHighTemperMsg; // weak
_UNKNOWN kLowTemperMsg; // weak
char *kStorageFullMsg = ""; // idb
char *kE49Msg = ""; // idb
_UNKNOWN kE51Msg; // weak
_UNKNOWN kE52Msg; // weak
_UNKNOWN kE54Msg; // weak
_UNKNOWN kLogAccessMsg; // weak
_UNKNOWN kStorageMsg; // weak
_UNKNOWN kJournalFullMsg; // weak
_UNKNOWN kDocumentJamMsg; // weak
_UNKNOWN kWrongPaperMsg; // weak
_UNKNOWN kScanCoverOpenMsg; // weak
_UNKNOWN kScanLockMsg; // weak
char *kScanUnableMsg = ""; // idb
_UNKNOWN kCommErrorMsg; // weak
_UNKNOWN kPrinterLockMsg; // weak
char *kStatusID = "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.5.6.0"; // idb
char *kStatusMsgID = "1.3.6.1.2.1.43.16.5.1.2.1.1"; // idb
char *kSupplyLevelID = "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.5.8.0"; // idb
char *kBlackPrintID = "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.5.26.0"; // idb
char *kInterfaceID = "1.3.6.1.4.1.2435.2.4.4.1240.1.2.0"; // idb
char *kMarkerColor = "marker-colors="; // idb
char *kMarkerLevel[4] = { "marker-levels=", "marker-low-levels=", "marker-names=", "marker-types=" }; // weak
char *kMarkerLowLevel[3] = { "marker-low-levels=", "marker-names=", "marker-types=" }; // weak
char *kMarkerName[2] = { "marker-names=", "marker-types=" }; // weak
char *kMarkerType = "marker-types="; // weak
char *supplyName[27] =
{
  "PFKit1",
  "PFKit2",
  "PFKit3",
  "PFKit4",
  "OPC",
  "Fuser",
  "WasteToner",
  "120KKit",
  "240KKit",
  "60KKit",
  "Drum",
  "Media",
  "kit",
  "kit",
  "kit",
  "kit",
  "opc",
  "fuser",
  "wasteToner",
  "kit",
  "kit",
  "kit",
  "drum",
  "media",
  "1.3.6.1.2.1.43.5.1.1.2.1",
  "1.3.6.1.2.1.43.7.1.1.4.1",
  "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.12.0"
}; // weak
char *supplyType[15] =
{
  "kit",
  "kit",
  "kit",
  "kit",
  "opc",
  "fuser",
  "wasteToner",
  "kit",
  "kit",
  "kit",
  "drum",
  "media",
  "1.3.6.1.2.1.43.5.1.1.2.1",
  "1.3.6.1.2.1.43.7.1.1.4.1",
  "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.12.0"
}; // weak
char *kCharCodeIndexID = "1.3.6.1.2.1.43.5.1.1.2.1"; // idb
char *kCharCodeID = "1.3.6.1.2.1.43.7.1.1.4.1"; // idb
char *kLanguageID = "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.12.0"; // idb
__int64 gStatus[] = { 0LL }; // weak
__int64 qword_100015CB0 = 0LL; // weak
int dword_100015CB8 = 0; // weak
int dword_100015CBC = -1; // weak
__int64 qword_100015CC0 = -1LL; // weak
__int64 qword_100015CC8 = -1LL; // weak
__int64 qword_100015CD0 = -1LL; // weak
__int64 qword_100015CD8 = -1LL; // weak
__int64 qword_100015CE0 = 0LL; // weak
__int64 qword_100015CE8 = 0LL; // weak
__int64 qword_100015CF0 = 0LL; // weak
__int64 qword_100015CF8 = 0LL; // weak
__int64 qword_100015D00 = 0LL; // weak
__int64 qword_100015D08 = 0LL; // weak
__int64 qword_100015D10 = 0LL; // weak
__int64 qword_100015D18 = 0LL; // weak
__int64 qword_100015D20 = 0LL; // weak
__int64 qword_100015D28 = 0LL; // weak
__int64 qword_100015D30 = 0LL; // weak
__int64 qword_100015D38 = 0LL; // weak
int gLowLevel[] = { -1 }; // weak
int dword_100015D44 = -1; // weak
int dword_100015D48 = -1; // weak
int dword_100015D4C = -1; // weak
int gModelInfo = -1; // weak
int dword_100015D54 = -1; // weak
unsigned __int16 ext_uwCalTarget_BC[16] =
{
  142u,
  132u,
  82u,
  140u,
  142u,
  132u,
  82u,
  140u,
  142u,
  132u,
  82u,
  140u,
  0u,
  0u,
  0u,
  0u
}; // weak
_UNKNOWN ext_ubConvTableBase_BC; // weak
unsigned __int8 ext_ubConvTableInside_BC[1024] =
{
  0u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  55u,
  55u,
  55u,
  56u,
  56u,
  56u,
  57u,
  57u,
  57u,
  58u,
  58u,
  59u,
  59u,
  60u,
  60u,
  61u,
  61u,
  62u,
  63u,
  63u,
  64u,
  65u,
  65u,
  66u,
  67u,
  68u,
  69u,
  69u,
  70u,
  71u,
  72u,
  72u,
  73u,
  74u,
  75u,
  76u,
  76u,
  77u,
  78u,
  79u,
  80u,
  80u,
  81u,
  82u,
  83u,
  83u,
  84u,
  85u,
  86u,
  87u,
  87u,
  89u,
  90u,
  92u,
  94u,
  96u,
  100u,
  104u,
  108u,
  111u,
  115u,
  119u,
  123u,
  127u,
  131u,
  135u,
  138u,
  138u,
  139u,
  139u,
  140u,
  140u,
  141u,
  141u,
  142u,
  142u,
  142u,
  0u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  55u,
  56u,
  56u,
  57u,
  58u,
  59u,
  59u,
  60u,
  61u,
  62u,
  62u,
  63u,
  64u,
  65u,
  65u,
  66u,
  67u,
  68u,
  68u,
  69u,
  70u,
  71u,
  71u,
  72u,
  73u,
  74u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  85u,
  87u,
  89u,
  91u,
  94u,
  96u,
  99u,
  101u,
  104u,
  107u,
  110u,
  113u,
  115u,
  118u,
  120u,
  122u,
  124u,
  127u,
  129u,
  0u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  40u,
  40u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  44u,
  44u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  48u,
  48u,
  49u,
  49u,
  50u,
  50u,
  51u,
  51u,
  52u,
  52u,
  53u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  64u,
  65u,
  66u,
  68u,
  69u,
  70u,
  71u,
  73u,
  74u,
  75u,
  76u,
  77u,
  79u,
  80u,
  81u,
  0u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  54u,
  55u,
  55u,
  55u,
  56u,
  56u,
  56u,
  57u,
  57u,
  57u,
  58u,
  58u,
  58u,
  59u,
  59u,
  60u,
  61u,
  62u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  89u,
  90u,
  92u,
  94u,
  97u,
  100u,
  102u,
  105u,
  108u,
  111u,
  114u,
  118u,
  121u,
  124u,
  127u,
  129u,
  131u,
  133u,
  135u,
  137u,
  138u,
  139u,
  139u,
  140u
}; // weak
__int16 ext_uwCalTarget_DCL[3] = { 124, 114, 82 }; // weak
_UNKNOWN ext_ubConvTableBase_DCL; // weak
unsigned __int8 ext_ubConvTableInside_DCL[1024] =
{
  0u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  55u,
  55u,
  55u,
  56u,
  56u,
  56u,
  57u,
  57u,
  57u,
  58u,
  58u,
  59u,
  59u,
  60u,
  60u,
  61u,
  61u,
  62u,
  63u,
  63u,
  64u,
  65u,
  65u,
  66u,
  67u,
  68u,
  69u,
  69u,
  70u,
  71u,
  72u,
  72u,
  73u,
  74u,
  75u,
  76u,
  76u,
  77u,
  78u,
  79u,
  80u,
  80u,
  81u,
  82u,
  83u,
  83u,
  84u,
  85u,
  86u,
  87u,
  87u,
  89u,
  90u,
  92u,
  94u,
  96u,
  100u,
  104u,
  108u,
  111u,
  115u,
  119u,
  123u,
  127u,
  131u,
  135u,
  138u,
  138u,
  139u,
  139u,
  140u,
  140u,
  141u,
  141u,
  142u,
  142u,
  142u,
  0u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  55u,
  56u,
  56u,
  57u,
  58u,
  59u,
  59u,
  60u,
  61u,
  62u,
  62u,
  63u,
  64u,
  65u,
  65u,
  66u,
  67u,
  68u,
  68u,
  69u,
  70u,
  71u,
  71u,
  72u,
  73u,
  74u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  85u,
  87u,
  89u,
  91u,
  94u,
  96u,
  99u,
  101u,
  104u,
  107u,
  110u,
  113u,
  115u,
  118u,
  120u,
  122u,
  124u,
  127u,
  129u,
  0u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  40u,
  40u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  44u,
  44u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  48u,
  48u,
  49u,
  49u,
  50u,
  50u,
  51u,
  51u,
  52u,
  52u,
  53u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  64u,
  65u,
  66u,
  68u,
  69u,
  70u,
  71u,
  73u,
  74u,
  75u,
  76u,
  77u,
  79u,
  80u,
  81u,
  0u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  54u,
  55u,
  55u,
  55u,
  56u,
  56u,
  56u,
  57u,
  57u,
  57u,
  58u,
  58u,
  58u,
  59u,
  59u,
  60u,
  61u,
  62u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  89u,
  90u,
  92u,
  94u,
  97u,
  100u,
  102u,
  105u,
  108u,
  111u,
  114u,
  118u,
  121u,
  124u,
  127u,
  129u,
  131u,
  133u,
  135u,
  137u,
  138u,
  139u,
  139u,
  140u
}; // weak
char *kAPPrinterIconPath = "APPrinterIconPath"; // idb
char *kCommandOIDLUTParentChar[9] =
{
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.1",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.2",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.3",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.4",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.5",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.6",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.7",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8"
}; // weak
char *kCommandOIDFCyanLUTChar[8] =
{
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.1",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.2",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.3",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.4",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.5",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.6",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.7",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8"
}; // weak
char *kCommandOIDFMagentaLUTChar[7] =
{
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.2",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.3",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.4",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.5",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.6",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.7",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8"
}; // weak
char *kCommandOIDFYellowLUTChar[6] =
{
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.3",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.4",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.5",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.6",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.7",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8"
}; // weak
char *kCommandOIDFBlackLUTChar[5] =
{
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.4",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.5",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.6",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.7",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8"
}; // weak
char *kCommandOIDSFCyanLUTChar[4] =
{
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.5",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.6",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.7",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8"
}; // weak
char *kCommandOIDSFMagentaLUTChar[3] =
{
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.6",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.7",
  ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8"
}; // weak
char *kCommandOIDSFYeloowLUTChar[2] = { ".1.3.6.1.4.1.2435.2.4.3.99.3.2.7", ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8" }; // weak
char *kCommandOIDSFBlackLUTChar = ".1.3.6.1.4.1.2435.2.4.3.99.3.2.8"; // weak
__CFString *kBRCalibrationInfoManagerCyanKey[6] =
{
  &cfstr_Cyan,
  &cfstr_Magenta,
  &cfstr_Yellow,
  &cfstr_Black,
  &cfstr_600,
  &cfstr_Capt
}; // weak
__CFString *kBRCalibrationInfoManagerMagentaKey[5] = { &cfstr_Magenta, &cfstr_Yellow, &cfstr_Black, &cfstr_600, &cfstr_Capt }; // weak
__CFString *kBRCalibrationInfoManagerYellowKey[4] = { &cfstr_Yellow, &cfstr_Black, &cfstr_600, &cfstr_Capt }; // weak
__CFString *kBRCalibrationInfoManagerBlackKey[3] = { &cfstr_Black, &cfstr_600, &cfstr_Capt }; // weak
__CFString *kBRCalibrationInfoManagerQuality600Key[2] = { &cfstr_600, &cfstr_Capt }; // weak
__CFString *kBRCalibrationInfoManagerQualityCAPTKey = &cfstr_Capt; // weak
_WORD ext_uwCalTarget_BC2Model[16] = { 130, 130, 75, 140, 130, 130, 75, 140, 130, 130, 75, 140, 0, 0, 0, 0 }; // weak
__int16 ext_uwCalTarget_ECLModel[3] = { 120, 100, 70 }; // weak
_UNKNOWN ext_ubConvTableBase_BC2Model; // weak
unsigned __int8 ext_ubConvTableInside_BC2Model[1024] =
{
  0u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  55u,
  55u,
  55u,
  56u,
  56u,
  56u,
  57u,
  57u,
  57u,
  58u,
  58u,
  59u,
  59u,
  60u,
  60u,
  61u,
  61u,
  62u,
  63u,
  63u,
  64u,
  65u,
  65u,
  66u,
  67u,
  68u,
  69u,
  69u,
  70u,
  71u,
  72u,
  72u,
  73u,
  74u,
  75u,
  76u,
  76u,
  77u,
  78u,
  79u,
  80u,
  80u,
  81u,
  82u,
  83u,
  83u,
  84u,
  85u,
  86u,
  87u,
  87u,
  89u,
  90u,
  92u,
  94u,
  96u,
  100u,
  104u,
  108u,
  111u,
  115u,
  119u,
  123u,
  127u,
  131u,
  135u,
  138u,
  138u,
  139u,
  139u,
  140u,
  140u,
  141u,
  141u,
  142u,
  142u,
  142u,
  0u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  55u,
  56u,
  56u,
  57u,
  58u,
  59u,
  59u,
  60u,
  61u,
  62u,
  62u,
  63u,
  64u,
  65u,
  65u,
  66u,
  67u,
  68u,
  68u,
  69u,
  70u,
  71u,
  71u,
  72u,
  73u,
  74u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  85u,
  87u,
  89u,
  91u,
  94u,
  96u,
  99u,
  101u,
  104u,
  107u,
  110u,
  113u,
  115u,
  118u,
  120u,
  122u,
  124u,
  127u,
  129u,
  0u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  38u,
  38u,
  38u,
  39u,
  39u,
  40u,
  40u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  44u,
  44u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  48u,
  48u,
  49u,
  49u,
  50u,
  50u,
  51u,
  51u,
  52u,
  52u,
  53u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  64u,
  65u,
  66u,
  68u,
  69u,
  70u,
  71u,
  73u,
  74u,
  75u,
  76u,
  77u,
  79u,
  80u,
  81u,
  0u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  9u,
  9u,
  9u,
  9u,
  10u,
  10u,
  10u,
  11u,
  11u,
  11u,
  11u,
  12u,
  12u,
  12u,
  12u,
  13u,
  13u,
  13u,
  13u,
  14u,
  14u,
  14u,
  15u,
  15u,
  15u,
  15u,
  16u,
  16u,
  16u,
  16u,
  17u,
  17u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  32u,
  32u,
  32u,
  32u,
  33u,
  33u,
  33u,
  34u,
  34u,
  34u,
  34u,
  35u,
  35u,
  35u,
  35u,
  36u,
  36u,
  36u,
  36u,
  37u,
  37u,
  37u,
  37u,
  38u,
  38u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  40u,
  41u,
  41u,
  41u,
  42u,
  42u,
  42u,
  43u,
  43u,
  43u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  48u,
  49u,
  49u,
  49u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  52u,
  52u,
  52u,
  53u,
  53u,
  53u,
  54u,
  54u,
  54u,
  55u,
  55u,
  55u,
  56u,
  56u,
  56u,
  57u,
  57u,
  57u,
  58u,
  58u,
  58u,
  59u,
  59u,
  60u,
  61u,
  62u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  89u,
  90u,
  92u,
  94u,
  97u,
  100u,
  102u,
  105u,
  108u,
  111u,
  114u,
  118u,
  121u,
  124u,
  127u,
  129u,
  131u,
  133u,
  135u,
  137u,
  138u,
  139u,
  139u,
  140u
}; // weak
int gGetStatusMode; // weak
CFStringEncoding gEncodingNum; // idb
_DWORD gCalib600DPI[23]; // weak
_DWORD gCalibCAPT[23]; // weak
char getStatusMessageFromResource_buf[512]; // idb
char getStandardStatus_buf[512]; // idb
char convertToUTF8String_buf[512]; // idb
char convertWarningErrorStatusMessage_buf[]; // idb
__int128 xmmword_100017300; // weak
__int128 xmmword_100017310; // weak
__int128 xmmword_100017320; // weak
__int128 xmmword_100017330; // weak
__int128 xmmword_100017340; // weak
__int128 xmmword_100017350; // weak
__int128 xmmword_100017360; // weak
char BRLocalizedString_buf[512]; // idb
char getBackChannelLUTData_tmp[]; // idb
__int128 xmmword_100017580; // weak
__int128 xmmword_100017590; // weak
__int128 xmmword_1000175A0; // weak
CFTypeRef sData; // idb
UInt8 sCurrentFilePath; // idb
// extern const CFAllocatorRef kCFAllocatorDefault;
// extern const CFAllocatorRef kCFAllocatorNull;
// extern const CFStringRef kCFPreferencesCurrentApplication;
// extern const CFArrayCallBacks kCFTypeArrayCallBacks;
// extern const CFDictionaryKeyCallBacks kCFTypeDictionaryKeyCallBacks;
// extern const CFDictionaryValueCallBacks kCFTypeDictionaryValueCallBacks;
// extern _UNKNOWN __stack_chk_guard; weak
// extern FILE *__stderrp;
// extern FILE *__stdoutp;


//----- (0000000100001124) ----------------------------------------------------
void __fastcall __noreturn start(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        const char *a7)
{
  _QWORD *i; // rcx
  int v8; // eax
  _UNKNOWN *retaddr; // [rsp+0h] [rbp+0h]

  for ( i = (const char **)((char *)&a7 + (unsigned int)(8 * ((_DWORD)retaddr + 1))); *i; ++i )
    ;
  v8 = main((int)retaddr, &a7, (const char **)((char *)&a7 + (unsigned int)(8 * ((_DWORD)retaddr + 1))));
  exit(v8);
}

//----- (0000000100001160) ----------------------------------------------------
int setDeviceOn()
{
  bool v0; // al
  int v1; // ecx

  printf("%s", "\x1B%-12345X@PJL\n");
  if ( gModelInfo )
  {
    v0 = isMessageAvailable(kGenericMsg);
    v1 = gModelInfo;
    if ( v0 && gModelInfo != 3 )
    {
      printf("%s", "@PJL DINQUIRE STRINGCODESET\r\n");
      printf("%s", "@PJL INQUIRE LANG\r\n");
      v1 = gModelInfo;
    }
    if ( v1 == 1 )
      printf("%s", "@PJL INFO STATUS\n");
  }
  printf("%s", "@PJL USTATUS DEVICE=ON \n");
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}
// 100015D50: using guessed type int gModelInfo;

//----- (0000000100001226) ----------------------------------------------------
_BOOL8 __fastcall isMessageAvailable(char *spec)
{
  char *v1; // rax
  ppd_file_t *v2; // rax
  ppd_file_t *v3; // rbx
  bool v4; // r14

  v1 = getenv("PPD");
  v2 = ppdOpenFile(v1);
  v3 = v2;
  if ( v2 )
  {
    v4 = ppdFindAttr(v2, "cupsIPPReason", spec) != 0LL;
    ppdClose(v3);
  }
  else
  {
    return 0;
  }
  return v4;
}

//----- (000000010000127B) ----------------------------------------------------
int setDeviceOff()
{
  printf("%s", "\x1B%-12345X@PJL\n");
  printf("%s", "@PJL USTATUS DEVICE=OFF \n");
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}

//----- (00000001000012D0) ----------------------------------------------------
int setDevice2On()
{
  printf("%s", "\x1B%-12345X@PJL\n");
  printf("%s", "@PJL USTATUS DEVICE2=ON \n");
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}

//----- (0000000100001325) ----------------------------------------------------
int setDevice2Off()
{
  printf("%s", "\x1B%-12345X@PJL\n");
  printf("%s", "@PJL USTATUS DEVICE2=OFF \n");
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}

//----- (000000010000137A) ----------------------------------------------------
int sendLabelPrint()
{
  printf("%s", "\x1B%-12345X@PJL\n");
  printf("%s", "@PJL INFO SENDLABELDATA\n");
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}

//----- (00000001000013CF) ----------------------------------------------------
int __fastcall setMaintenance(char a1)
{
  const char *v1; // rsi

  printf("%s", "\x1B%-12345X@PJL\n");
  if ( a1 )
    v1 = "@PJL SET NOTIFYBRMAINTENANCE=ON\n";
  else
    v1 = "@PJL SET NOTIFYBRMAINTENANCE=OFF\n";
  printf("%s", v1);
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}

//----- (0000000100001438) ----------------------------------------------------
int __fastcall sendPJLCommand(char *a1)
{
  printf("%s", "\x1B%-12345X@PJL\n");
  puts(a1);
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}

//----- (0000000100001486) ----------------------------------------------------
__int64 isSNMPAvailable()
{
  char *v0; // rax
  __int64 result; // rax

  v0 = getenv("SOFTWARE");
  LOBYTE(result) = !v0 || strncmp("CUPS/1.4.2", v0, 0xAuLL);
  return (unsigned __int8)result;
}

//----- (00000001000014BE) ----------------------------------------------------
__int64 CheckBackChannel()
{
  unsigned int v0; // ebx
  char *v1; // rax
  char *v2; // r14
  bool v3; // al
  cups_sc_status_t v4; // eax
  int v6; // [rsp+0h] [rbp-20h] BYREF
  char v7; // [rsp+7h] [rbp-19h] BYREF
  int datalen; // [rsp+8h] [rbp-18h] BYREF
  char data[17]; // [rsp+Fh] [rbp-11h] BYREF

  v0 = -1;
  if ( (int)determineModel() > 0 )
  {
    v1 = getenv("SOFTWARE");
    if ( v1 )
    {
      if ( strncmp("CUPS/1.3", v1, 8uLL) <= 0 )
      {
        v2 = getenv("DEVICE_URI");
        if ( !strncmp("usb://", v2, 6uLL) || strstr(v2, "._riousbprint._tcp.") )
        {
          datalen = 1;
          if ( cupsSideChannelDoRequest(CUPS_SC_CMD_GET_BIDI, data, &datalen, 5.0) == CUPS_SC_STATUS_OK
            && datalen == 1
            && data[0] == 1 )
          {
            fprintf(__stderrp, "%s Use Back Channel (PJL)\n", "DEBUG: ");
            return 2;
          }
        }
        else if ( !(unsigned __int8)isIPPPrinting() || !isCalledFromRasterFiler() )
        {
          v6 = 1;
          v3 = isCalledFromRasterFiler();
          v4 = cupsSideChannelDoRequest(CUPS_SC_CMD_GET_BIDI, &v7, &v6, dbl_100010020[!v3]);
          return 2 * (unsigned int)(v4 == CUPS_SC_STATUS_OK && v6 == 1) - 1;
        }
      }
    }
  }
  return v0;
}
// 100010020: using guessed type double dbl_100010020[2];

//----- (0000000100001613) ----------------------------------------------------
__int64 __fastcall getBackChannelRowData(_BYTE *__dst, int *a2, double a3)
{
  _BYTE *v3; // r15
  int v4; // r13d
  int v5; // ebx
  int v6; // r13d
  int v7; // eax
  char buffer[512]; // [rsp+10h] [rbp-230h] BYREF

  v3 = __dst;
  v4 = *a2;
  __bzero(__dst, *a2);
  *a2 = 0;
  v5 = cupsBackChannelRead(buffer, 0x200uLL, a3);
  if ( v5 <= 0 )
  {
LABEL_5:
    if ( v5 && *__error() != 35 )
    {
      fprintf(__stderrp, "%s getBackChannelRowData read error.\n", "DEBUG: ");
      *a2 = 0;
      *v3 = 0;
    }
    else
    {
      v3[*a2] = 0;
    }
  }
  else
  {
    v6 = v4 - 1;
    while ( 1 )
    {
      v7 = v5 + *a2;
      *a2 = v7;
      if ( v7 >= v6 )
        break;
      memcpy(v3, buffer, v5);
      v3 += v5;
      v5 = cupsBackChannelRead(buffer, 0x200uLL, 0.01);
      if ( v5 <= 0 )
        goto LABEL_5;
    }
    fprintf(__stderrp, "%s getBackChannelRowData buffer overflow.\n", "DEBUG: ");
    memcpy(v3, buffer, v6 + v5 - *a2);
    *a2 = v6;
  }
  return 0LL;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (0000000100001763) ----------------------------------------------------
__int64 __fastcall getBackChannelData(double a1)
{
  __int64 v1; // r14
  int v2; // eax
  int v3; // ebx
  __int64 v4; // r15
  __int128 v5; // xmm2
  __int64 v6; // rax
  char v7; // cl
  __int64 v8; // r12
  size_t v9; // r14
  int v10; // eax
  double v11; // xmm0_8
  __int64 v12; // rcx
  char v13; // al
  size_t v14; // rax
  int v15; // eax
  bool v16; // cl
  int v17; // r12d
  const char *v18; // r14
  int v19; // eax
  int v20; // eax
  char v22; // [rsp+8h] [rbp-4A8h]
  char timeout; // [rsp+10h] [rbp-4A0h]
  char *timeouta; // [rsp+10h] [rbp-4A0h]
  int v25; // [rsp+18h] [rbp-498h] BYREF
  char v26; // [rsp+1Ch] [rbp-494h] BYREF
  int v27; // [rsp+20h] [rbp-490h] BYREF
  int v28; // [rsp+24h] [rbp-48Ch] BYREF
  int v29; // [rsp+28h] [rbp-488h] BYREF
  char v30; // [rsp+2Ch] [rbp-484h] BYREF
  char v31; // [rsp+30h] [rbp-480h] BYREF
  int v32; // [rsp+34h] [rbp-47Ch] BYREF
  int v33; // [rsp+38h] [rbp-478h] BYREF
  int v34; // [rsp+3Ch] [rbp-474h] BYREF
  char __s1[16]; // [rsp+40h] [rbp-470h] BYREF
  __int128 v36; // [rsp+50h] [rbp-460h]
  __int128 v37; // [rsp+60h] [rbp-450h]
  __int128 v38; // [rsp+70h] [rbp-440h]
  char buffer[1024]; // [rsp+80h] [rbp-430h] BYREF

  v1 = __stack_chk_guard;
  __bzero(buffer, 1024LL);
  qword_100015CB0 = 0LL;
  gStatus[0] = 0LL;
  qword_100015CD8 = -1LL;
  qword_100015CD0 = -1LL;
  qword_100015CC8 = -1LL;
  qword_100015CC0 = -1LL;
  v2 = cupsBackChannelRead(buffer, 0x3FFuLL, a1);
  v3 = v2;
  if ( v2 > 0 )
  {
    buffer[v2] = 0;
    fprintf(__stderrp, "%s cupsBackChannelRead %d bytes.\n", "DEBUG: ", v2);
    v22 = 0;
    timeout = 0;
    LODWORD(v4) = 0;
    v5 = 0LL;
    while ( 1 )
    {
      v38 = v5;
      v37 = v5;
      v36 = v5;
      *(_OWORD *)__s1 = v5;
      v20 = (unsigned __int8)buffer[(int)v4];
      if ( v20 == 10 || (unsigned __int8)v20 == 13 )
      {
        LODWORD(v4) = v4 + 1;
        goto LABEL_98;
      }
      v6 = 0LL;
LABEL_4:
      v4 = (int)v4;
LABEL_6:
      v7 = buffer[v4];
      while ( v7 != 10 && v7 != 13 )
      {
        if ( (int)v4 >= v3 )
          goto LABEL_98;
        if ( v7 == 12 )
        {
          ++v4;
          goto LABEL_6;
        }
        if ( (unsigned int)v6 <= 0x3F )
        {
          LODWORD(v4) = v4 + 1;
          __s1[v6++] = v7;
          goto LABEL_4;
        }
      }
      if ( (int)v4 >= v3 )
        goto LABEL_98;
      if ( !strncmp(__s1, "CODE=", 5uLL) )
      {
        gStatus[0] = atol(&__s1[5]);
      }
      else if ( !strncmp(__s1, "DISPLAY=", 8uLL) )
      {
        qword_100015CB0 = (__int64)convertToUTF8String(&__s1[8]);
      }
      else
      {
        if ( !strncmp(__s1, "INFOMAINTE=", 0xBuLL) )
        {
          if ( sscanf(__s1, "INFOMAINTE=\"A%d,%d,%d,%x,%x\"", &v32, &v31, &v30, &v33, &v34) )
          {
            v10 = v32 - 1;
            v5 = 0LL;
            if ( (unsigned int)(v32 - 1) <= 3 && v34 )
            {
              --v32;
              v11 = (double)v33 / (double)v34 * 100.0;
              v12 = 0LL;
              if ( v11 > 0.0 )
              {
                v12 = 10LL;
                if ( v11 >= 10.0 )
                {
                  v12 = 25LL;
                  if ( v11 >= 25.0 )
                  {
                    v12 = 40LL;
                    if ( v11 >= 40.0 )
                    {
                      v12 = 55LL;
                      if ( v11 >= 55.0 )
                      {
                        v12 = 70LL;
                        if ( v11 >= 70.0 )
                        {
                          v12 = 100LL;
                          if ( v11 < 85.0 )
                            v12 = 85LL;
                        }
                      }
                    }
                  }
                }
              }
              gStatus[v10 + 3] = v12;
            }
            goto LABEL_98;
          }
          goto LABEL_68;
        }
        if ( !strncmp(__s1, "STATUS=", 7uLL) )
          return strcmp(&__s1[7], "TRUE") == 0;
        v8 = v1;
        v9 = strlen(__s1);
        if ( !strncmp(__s1, "@PJL DINQUIRE STRINGCODESET\r\n", v9) )
        {
          v13 = 1;
LABEL_67:
          timeout = v13;
          v1 = v8;
          goto LABEL_68;
        }
        if ( timeout )
        {
          if ( !strcmp(__s1, "HPUTF8") )
            gEncodingNum = 134217984;
          goto LABEL_66;
        }
        if ( gEncodingNum != 134217984 && !strncmp(__s1, "@PJL INQUIRE LANG\r\n", v9) )
        {
          v22 = 1;
LABEL_66:
          v13 = 0;
          goto LABEL_67;
        }
        if ( v22 )
        {
          v1 = v8;
          if ( strcmp(__s1, "DUCTH")
            && strcmp(__s1, "DANISH")
            && strcmp(__s1, "FRENCH")
            && strcmp(__s1, "GERMAN")
            && strcmp(__s1, "ENGLISH")
            && strcmp(__s1, "FINNISH")
            && strcmp(__s1, "ITALIAN")
            && strcmp(__s1, "SPANISH")
            && strcmp(__s1, "SWEDISH")
            && strcmp(__s1, "NORWEGIAN")
            && strcmp(__s1, "PORTUGUESE") )
          {
            if ( !strcmp(__s1, "RUSSIAN") || !strcmp(__s1, "BULGARIAN") )
            {
              gEncodingNum = 1282;
            }
            else if ( !strcmp(__s1, "CZECH")
                   || !strcmp(__s1, "POLISH")
                   || !strcmp(__s1, "ROMANIAN")
                   || !strcmp(__s1, "HUNGARIAN")
                   || !strcmp(__s1, "SLOVAKIAN") )
            {
              gEncodingNum = 1281;
            }
            else if ( !strcmp(__s1, "TURKISH") )
            {
              gEncodingNum = 1284;
            }
            else if ( !strcmp(__s1, "JAPANESE") )
            {
              gEncodingNum = 2561;
            }
            else
            {
              gEncodingNum = -1;
            }
            timeout = 0;
            v22 = 0;
            goto LABEL_68;
          }
          gEncodingNum = 1280;
        }
        else
        {
          v14 = strlen(__s1);
          v1 = v8;
          if ( !strncmp(__s1, "@PJL INFO SENDLABELDATA\n", v14) )
          {
            dword_100015CBC = 1;
            return 0;
          }
          if ( !strncmp(__s1, "DATA=", 5uLL) )
          {
            timeouta = (char *)malloc(0x3BuLL);
            if ( sscanf(__s1, "DATA=\"8%d,%d,%d,%s\"", &v28, &v26, &v25, timeouta) && (unsigned int)(v28 - 1) <= 8 )
            {
              --v28;
              v15 = v25;
              v16 = timeouta != 0LL;
              v17 = 0;
              if ( v25 <= 1 )
              {
                v18 = timeouta;
              }
              else
              {
                v18 = timeouta;
                while ( v18 )
                {
                  v16 = 1;
                  if ( *(unsigned __int8 *)v18 == 255 )
                    break;
                  if ( sscanf(v18, "%x,%n", &v27, &v29) && v29 > 0 )
                    v18 += v29;
                  ++v17;
                  v15 = v25;
                  v16 = v18 != 0LL;
                  if ( v17 >= v25 - 1 )
                    break;
                }
              }
              if ( v17 == v15 - 1 && v16 && *(unsigned __int8 *)v18 != 255 && sscanf(v18, "%x", &v27) )
              {
                v19 = v28;
                if ( v28 > 3LL )
                {
                  if ( v28 >= 5 )
                  {
                    v28 -= 5;
                    gLowLevel[v19 - 5] = v27;
                  }
                }
                else
                {
                  gStatus[v28 + 3] = v27;
                }
              }
            }
            free(timeouta);
            timeout = 0;
            v22 = 0;
            v1 = __stack_chk_guard;
            goto LABEL_68;
          }
        }
        timeout = 0;
        v22 = 0;
      }
LABEL_68:
      v5 = 0LL;
LABEL_98:
      if ( (int)v4 >= v3 )
        return (unsigned int)v3;
    }
  }
  if ( !v2 )
  {
    v3 = 0;
    fprintf(__stderrp, "%s cupsBackChannelRead 0 bytes.\n", "DEBUG: ");
  }
  return (unsigned int)v3;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);
// 100015CA8: using guessed type __int64 gStatus[];
// 100015CB0: using guessed type __int64 qword_100015CB0;
// 100015CBC: using guessed type int dword_100015CBC;
// 100015CC0: using guessed type __int64 qword_100015CC0;
// 100015CC8: using guessed type __int64 qword_100015CC8;
// 100015CD0: using guessed type __int64 qword_100015CD0;
// 100015CD8: using guessed type __int64 qword_100015CD8;
// 100015D40: using guessed type int gLowLevel[];

//----- (0000000100001FDA) ----------------------------------------------------
char *__fastcall convertToUTF8String(char *cStr)
{
  char *v1; // r15
  char *v2; // rbx
  CFStringEncoding v3; // edx
  const __CFString *v4; // rax
  const __CFString *v5; // r14
  CFIndex Length; // rax
  const __CFString *MutableCopy; // rax
  __CFString *v8; // r12
  CFIndex v9; // rax

  v1 = convertToUTF8String_buf;
  __bzero(convertToUTF8String_buf, 512LL);
  v2 = 0LL;
  if ( cStr )
  {
    v3 = gEncodingNum;
    if ( !gEncodingNum )
    {
      getDeviceCharCode();
      v3 = gEncodingNum;
    }
    if ( v3 == 134217984 )
    {
      return cStr;
    }
    else
    {
      v2 = 0LL;
      if ( v3 != -1 )
      {
        v4 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, v3);
        v5 = v4;
        v2 = 0LL;
        if ( v4 )
        {
          Length = CFStringGetLength(v4);
          MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, Length, v5);
          v8 = (__CFString *)MutableCopy;
          v2 = 0LL;
          if ( MutableCopy )
          {
            v9 = CFStringGetLength(MutableCopy);
            CFStringFindAndReplace(v8, CFSTR("\""), &replacementString, (CFRange)__PAIR128__(v9, 0LL), 0LL);
            if ( !CFStringGetCString(v8, convertToUTF8String_buf, 512LL, 0x8000100u) )
              v1 = 0LL;
            CFRelease(v8);
            v2 = v1;
          }
          CFRelease(v5);
        }
      }
    }
  }
  return v2;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (00000001000020D8) ----------------------------------------------------
__int64 __fastcall convertSupplyLevel(double a1)
{
  __int64 result; // rax

  result = 0LL;
  if ( a1 > 0.0 )
  {
    result = 10LL;
    if ( a1 >= 10.0 )
    {
      result = 25LL;
      if ( a1 >= 25.0 )
      {
        result = 40LL;
        if ( a1 >= 40.0 )
        {
          result = 55LL;
          if ( a1 >= 55.0 )
          {
            result = 70LL;
            if ( a1 >= 70.0 )
            {
              result = 100LL;
              if ( a1 < 85.0 )
                return 85LL;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000100002162) ----------------------------------------------------
__int64 __fastcall getSideChannelSNMPData(char *__s1, double a2)
{
  cups_sc_status_t v2; // ebx
  size_t v3; // rbx
  unsigned __int8 *v4; // r15
  int v5; // r13d
  unsigned int v6; // r14d
  __int64 v7; // rax
  unsigned __int8 *v8; // rcx
  unsigned __int8 *v9; // rbx
  int v10; // edi
  int v11; // r9d
  __int64 v12; // r8
  int v13; // edi
  __int64 v14; // rcx
  unsigned __int8 v15; // al
  __int64 v16; // rdx
  double v17; // xmm7_8
  __int64 v18; // rcx
  bool v19; // zf
  bool v20; // sf
  bool v21; // of
  __int64 v22; // rcx
  bool v23; // zf
  bool v24; // sf
  bool v25; // of
  int v26; // ecx
  unsigned __int8 v27; // dl
  __int64 v28; // rax
  unsigned int v29; // ecx
  __int64 v30; // rsi
  unsigned int v31; // ecx
  __int64 v32; // rsi
  int datalen; // [rsp+Ch] [rbp-834h] BYREF
  char data[2048]; // [rsp+10h] [rbp-830h] BYREF

  datalen = 2048;
  v2 = cupsSideChannelSNMPGet(__s1, data, &datalen, a2);
  if ( v2 == CUPS_SC_STATUS_OK && datalen > 0 )
  {
    fprintf(__stderrp, "%s cupsSideChannelRead %d bytes.\n", "DEBUG: ", datalen);
    v3 = datalen;
    v4 = (unsigned __int8 *)malloc(datalen + 1);
    memcpy(v4, data, v3);
    v5 = datalen;
    v4[datalen] = 0;
    if ( !strcmp(__s1, kStatusID) )
    {
      v7 = atol((const char *)v4);
      v6 = 1;
      if ( v7 > 0 )
        gStatus[0] = v7;
    }
    else if ( !strcmp(__s1, kStatusMsgID) )
    {
      if ( v4 )
      {
        qword_100015CB0 = convertToUTF8String((char *)v4);
        v6 = 1;
      }
      else
      {
        qword_100015CB0 = 0LL;
        v6 = 0;
      }
    }
    else if ( !strcmp(__s1, kSupplyLevelID) )
    {
      v6 = 1;
      if ( v4 )
      {
        v8 = v4;
        while ( 1 )
        {
          v9 = v8;
          v10 = v5;
          v11 = *v8;
          if ( v11 == 255 || v5 <= 0 )
            break;
          ++v8;
          --v5;
          datalen = v10 - 1;
          if ( v9[1] != 255 && v5 > 0 )
          {
            v8 = v9 + 2;
            v5 = v10 - 2;
            datalen = v10 - 2;
            v12 = v9[2];
            if ( (_DWORD)v12 != 255 && v5 > 0 )
            {
              v13 = v10 - 3;
              datalen = v13;
              v14 = (unsigned __int8)(v11 + 95);
              if ( (unsigned int)v14 > 3 )
              {
                v18 = (unsigned __int8)(v11 + 127);
                if ( (unsigned int)v18 > 3 )
                {
                  v22 = (unsigned __int8)(v11 + 122);
                  if ( (unsigned int)v22 > 3 )
                  {
                    if ( gModelInfo )
                    {
                      v26 = v9[(unsigned int)(v12 + 2)];
                      if ( v11 > 82 )
                      {
                        v27 = 13;
                        switch ( v11 )
                        {
                          case 'S':
                          case 'T':
                          case 'U':
                          case 'V':
                          case 'W':
                            LOBYTE(v11) = v11 - 75;
                            goto LABEL_48;
                          case 'a':
                            goto LABEL_65;
                          case 'c':
                            v27 = 14;
                            goto LABEL_65;
                          case 'd':
                            v27 = 7;
                            goto LABEL_65;
                          default:
                            goto LABEL_48;
                        }
                      }
                      if ( (unsigned int)(v11 - 49) < 7 )
                        LOBYTE(v11) = v11 - 49;
LABEL_48:
                      if ( (unsigned __int8)v11 <= 9u && (v28 = 783LL, _bittest64(&v28, (unsigned __int8)v11)) )
                      {
                        v29 = v26 - 1;
                        v30 = -1LL;
                        if ( v29 <= 3 )
                          v30 = qword_1000100A0[v29];
                        gStatus[(unsigned __int8)v11 + 3] = v30;
                      }
                      else
                      {
                        v27 = v11;
                        if ( (unsigned __int8)v11 <= 0xEu )
                        {
LABEL_65:
                          v31 = v26 - 1;
                          v32 = -1LL;
                          if ( v31 <= 2 )
                            v32 = qword_1000100C0[v31];
                          gStatus[v27 + 3] = v32;
                        }
                      }
                    }
                  }
                  else if ( (_BYTE)v12 )
                  {
                    switch ( gModelInfo )
                    {
                      case 0:
                        v25 = __OFSUB__(dword_100015D54, 13);
                        v23 = dword_100015D54 == 13;
                        v24 = dword_100015D54 - 13 < 0;
                        goto LABEL_61;
                      case 1:
                        v25 = __OFSUB__(dword_100015D54, 7);
                        v23 = dword_100015D54 == 7;
                        v24 = dword_100015D54 - 7 < 0;
                        goto LABEL_61;
                      case 2:
                        v25 = __OFSUB__(dword_100015D54, 4);
                        v23 = dword_100015D54 == 4;
                        v24 = dword_100015D54 - 4 < 0;
LABEL_61:
                        if ( !(v24 ^ v25 | v23) )
                          goto LABEL_62;
                        break;
                      case 3:
LABEL_62:
                        gLowLevel[v22] = (char)v9[(unsigned int)(v12 + 2)];
                        break;
                      default:
                        break;
                    }
                  }
                }
                else if ( (_BYTE)v12 )
                {
                  switch ( gModelInfo )
                  {
                    case 0:
                      v21 = __OFSUB__(dword_100015D54, 13);
                      v19 = dword_100015D54 == 13;
                      v20 = dword_100015D54 - 13 < 0;
                      goto LABEL_57;
                    case 1:
                      v21 = __OFSUB__(dword_100015D54, 7);
                      v19 = dword_100015D54 == 7;
                      v20 = dword_100015D54 - 7 < 0;
                      goto LABEL_57;
                    case 2:
                      v21 = __OFSUB__(dword_100015D54, 4);
                      v19 = dword_100015D54 == 4;
                      v20 = dword_100015D54 - 4 < 0;
LABEL_57:
                      if ( !(v20 ^ v21 | v19) )
                        goto LABEL_58;
                      break;
                    case 3:
LABEL_58:
                      gStatus[v18 + 3] = (char)v9[(unsigned int)(v12 + 2)];
                      break;
                    default:
                      break;
                  }
                }
              }
              else if ( (_DWORD)v12 == 2 && v13 >= 2 )
              {
                v15 = v9[4];
                v16 = 0LL;
                if ( v15 )
                {
                  v17 = (double)v9[3] / (double)v15 * 100.0;
                  v16 = 0LL;
                  if ( v17 > 0.0 )
                  {
                    v16 = 10LL;
                    if ( v17 >= 10.0 )
                    {
                      v16 = 25LL;
                      if ( v17 >= 25.0 )
                      {
                        v16 = 40LL;
                        if ( v17 >= 40.0 )
                        {
                          v16 = 55LL;
                          if ( v17 >= 55.0 )
                          {
                            v16 = 70LL;
                            if ( v17 >= 70.0 )
                            {
                              v16 = 100LL;
                              if ( v17 < 85.0 )
                                v16 = 85LL;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                gStatus[v14 + 3] = v16;
              }
              v8 = &v9[v12 + 3];
              datalen = v13 - v12;
              v5 = v13 - v12;
            }
          }
        }
      }
    }
    else
    {
      v6 = atoi((const char *)v4);
    }
    free(v4);
  }
  else
  {
    v6 = 0;
    fprintf(__stderrp, "%s%s %d\n", "DEBUG: ", "No response!", v2);
  }
  return v6;
}
// 1000100A0: using guessed type _QWORD qword_1000100A0[4];
// 1000100C0: using guessed type _QWORD qword_1000100C0[4];
// 100015CA8: using guessed type __int64 gStatus[];
// 100015CB0: using guessed type __int64 qword_100015CB0;
// 100015D40: using guessed type int gLowLevel[];
// 100015D50: using guessed type int gModelInfo;
// 100015D54: using guessed type int dword_100015D54;

//----- (00000001000026A8) ----------------------------------------------------
__int64 __fastcall getDeviceStatusSub(double a1)
{
  if ( gGetStatusMode == 2 )
    return getBackChannelData(a1);
  if ( gGetStatusMode == 1 )
    return getSideChannelSNMPData(kStatusID, a1);
  return 0LL;
}
// 100016C30: using guessed type int gGetStatusMode;

//----- (00000001000026D3) ----------------------------------------------------
__int64 __fastcall getDeviceStatus(double a1)
{
  int v1; // ecx
  unsigned int DeviceStatusSub; // r14d
  int v3; // r13d
  __int64 v4; // rbx
  char *v5; // rax
  char *v6; // r12
  char *StandardStatus; // r15
  char *v8; // r15
  bool v9; // al
  double v10; // xmm0_8
  char *__s1; // [rsp+20h] [rbp-50h]
  const char *__s2; // [rsp+28h] [rbp-48h]
  char *cStr; // [rsp+30h] [rbp-40h]
  int v15; // [rsp+3Ch] [rbp-34h]

  v1 = 200;
  if ( a1 < 10.0 )
    v1 = 500;
  v15 = v1;
  if ( !gStatus[0] || (DeviceStatusSub = 1, gStatus[0] == 10001) )
  {
    DeviceStatusSub = getDeviceStatusSub(a1);
    if ( !gStatus[0] )
      DeviceStatusSub = 0;
    fprintf(__stderrp, "%s-%s\n", "STATE: ", kWaitMsg);
    fprintf(__stderrp, "%s\n", "INFO: ");
    if ( isMessageAvailable(kBlackPrintMsg) )
    {
      fprintf(__stderrp, "%s-%s\n", "STATE: ", kBlackPrintMsg);
      fprintf(__stderrp, "%s-%s\n", "STATE: ", kNoBlackPrintMsg);
    }
    if ( gModelInfo && isCalledFromRasterFiler() )
      fprintf(__stderrp, "%s-%s\n", "STATE: ", kPaperOutMsg);
  }
  v3 = 0;
  do
  {
    if ( (int)DeviceStatusSub <= 0 )
      return DeviceStatusSub;
    v4 = gStatus[0];
    v5 = determineStatus(gStatus[0]);
    if ( !v5 )
      goto LABEL_81;
    v6 = v5;
    if ( !strcmp(v5, kDiscGuideMsg) && dword_100015CBC != -1 )
      goto LABEL_81;
    StandardStatus = getStandardStatus(v6);
    if ( StandardStatus )
      fprintf(__stderrp, "%s+%s\n", "STATE: ", StandardStatus);
    cStr = StandardStatus;
    if ( isMessageAvailable(kGenericMsg) && (strcmp(v6, kTonerOutMsg) || !isMessageAvailable(v6)) )
    {
      v8 = kGenericMsg;
      if ( strcmp(v6, kGenericMsg) )
      {
        if ( !(unsigned int)getStatusMessageFromResource(v6) )
        {
LABEL_28:
          if ( qword_100015CB0 )
            fprintf(__stderrp, "%s%s\n", "INFO: ", (const char *)qword_100015CB0);
          goto LABEL_30;
        }
        v8 = kGenericMsg;
      }
      if ( gModelInfo )
        getStatusMessageFromDevice(a1);
      v6 = v8;
      goto LABEL_28;
    }
LABEL_30:
    if ( !strstr(v6, "-error") && !strstr(v6, "-warning") )
    {
      if ( isMessageAvailable(v6) )
      {
        fprintf(__stderrp, "%s+%s\n", "STATE: ", v6);
        if ( a1 >= 10.0 || a1 == 0.1 )
          sleep(3u);
      }
      goto LABEL_81;
    }
    if ( !strcmp(v6, kGenericMsg) )
    {
      fprintf(__stderrp, "%s+%s\n", "STATE: ", v6);
      if ( a1 >= 10.0 || a1 == 0.1 )
      {
        sleep(2u);
        fprintf(__stderrp, "%s-%s\n", "STATE: ", v6);
      }
      goto LABEL_81;
    }
    if ( isMessageAvailable(v6) )
      fprintf(__stderrp, "%s+%s\n", "STATE: ", v6);
    if ( strcmp(v6, kTonerOutMsg) && strcmp(v6, kTonerMissMsg) )
    {
      __s1 = v6;
      v9 = strcmp(v6, kPaperOutMsg) != 0;
      if ( gModelInfo && (cStr != 0LL || !v9) )
      {
        __s2 = cStr;
        if ( !isCalledFromRasterFiler() )
          goto LABEL_59;
        goto LABEL_81;
      }
LABEL_57:
      __s2 = cStr;
      goto LABEL_59;
    }
    __s1 = v6;
    if ( gModelInfo || dword_100015D54 < 9 )
    {
      if ( gModelInfo == 2 && dword_100015D54 >= 2 )
      {
        if ( qword_100015CB0 )
        {
          fprintf(__stderrp, "%s\n", "INFO: ");
          qword_100015CB0 = 0LL;
        }
        if ( a1 == 0.1 )
        {
          dword_100015CB8 = 1;
        }
        else
        {
          __s2 = cStr;
          if ( !dword_100015CB8 )
            goto LABEL_59;
        }
        goto LABEL_82;
      }
      goto LABEL_57;
    }
    if ( qword_100015CB0 )
    {
      fprintf(__stderrp, "%s\n", "INFO: ");
      qword_100015CB0 = 0LL;
    }
    if ( dword_100015CB8 || (unsigned __int8)canBlackPrint() )
    {
      dword_100015CB8 = 1;
LABEL_81:
      qword_100015CB0 = 0LL;
LABEL_82:
      gStatus[0] = 0LL;
      return DeviceStatusSub;
    }
    __s2 = 0LL;
    if ( cStr )
    {
      fprintf(__stderrp, "%s-%s\n", "STATE: ", cStr);
      __s2 = convertWarningErrorStatusMessage(cStr);
      fprintf(__stderrp, "%s+%s\n", "STATE: ", __s2);
    }
LABEL_59:
    while ( DeviceStatusSub )
    {
      if ( gStatus[0] != 0 && gStatus[0] != v4 || v3 >= v15 )
        goto LABEL_65;
      sleep(3u);
      v10 = 3.0;
      if ( a1 > 0.0 || gModelInfo != 0 )
        v10 = a1;
      ++v3;
      DeviceStatusSub = getDeviceStatusSub(v10);
    }
    DeviceStatusSub = 0;
LABEL_65:
    fprintf(__stderrp, "%s-%s\n", "STATE: ", __s1);
    if ( __s2 && strcmp(__s1, __s2) )
      fprintf(__stderrp, "%s-%s\n", "STATE: ", __s2);
    fprintf(__stderrp, "%s\n", "INFO: ");
    if ( !strcmp(__s1, kTonerOutMsg) && isMessageAvailable(kBlackPrintMsg) )
    {
      fprintf(__stderrp, "%s-%s\n", "STATE: ", kBlackPrintMsg);
      fprintf(__stderrp, "%s-%s\n", "STATE: ", kNoBlackPrintMsg);
    }
  }
  while ( v3 < v15 );
  fprintf(__stderrp, "%s Timeout\n", "INFO: ");
  return DeviceStatusSub;
}
// 100015CA8: using guessed type __int64 gStatus[];
// 100015CB0: using guessed type __int64 qword_100015CB0;
// 100015CB8: using guessed type int dword_100015CB8;
// 100015CBC: using guessed type int dword_100015CBC;
// 100015D50: using guessed type int gModelInfo;
// 100015D54: using guessed type int dword_100015D54;

//----- (0000000100002DB8) ----------------------------------------------------
char *__fastcall determineStatus(__int64 a1)
{
  const char *v1; // r14
  __int64 v2; // rcx
  int v3; // ebx
  char **v4; // rax
  char *v5; // rbx
  unsigned __int64 v7; // rax

  v1 = 0LL;
  if ( a1 > 40009 )
  {
    if ( a1 == 40010 )
      goto LABEL_25;
  }
  else if ( a1 > 39999 )
  {
    if ( a1 == 40000 )
      goto LABEL_176;
  }
  else if ( a1 > 30034 )
  {
    if ( a1 == 30035 )
      goto LABEL_151;
  }
  else if ( a1 > 30015 )
  {
    if ( a1 == 30016 )
    {
      v1 = (const char *)kMemoryOutMsg;
      goto LABEL_176;
    }
  }
  else if ( a1 > 12200 )
  {
    if ( a1 == 12201 )
      goto LABEL_143;
  }
  else if ( a1 > 10022 )
  {
    if ( a1 == 10023 )
      goto LABEL_176;
  }
  else
  {
    switch ( a1 )
    {
      case 10001LL:
        goto LABEL_176;
      case 10003LL:
        v1 = (const char *)kWaitMsg;
        goto LABEL_176;
      case 10006LL:
        v1 = kTonerLowMsg;
        goto LABEL_176;
    }
  }
  if ( (unsigned __int64)(a1 - 40409) <= 3 )
  {
LABEL_25:
    v1 = kTonerMissMsg;
    goto LABEL_176;
  }
  if ( a1 > 70899 )
  {
    if ( a1 != 70900 )
      goto LABEL_174;
    goto LABEL_157;
  }
  if ( a1 > 70499 )
  {
    switch ( a1 )
    {
      case 70500LL:
        goto LABEL_161;
      case 70501LL:
        v1 = (const char *)kE51Msg;
        break;
      case 70502LL:
        v1 = (const char *)kE52Msg;
        break;
      case 70503LL:
        v1 = (const char *)kE54Msg;
        break;
      case 70504LL:
        goto LABEL_167;
      default:
        goto LABEL_174;
    }
  }
  else
  {
    if ( a1 > 70419 )
    {
      if ( a1 != 70420 )
        goto LABEL_174;
      goto LABEL_167;
    }
    if ( a1 > 70399 )
    {
      if ( a1 != 70400 )
        goto LABEL_174;
      goto LABEL_167;
    }
    if ( a1 > 70299 )
    {
      if ( a1 != 70300 )
        goto LABEL_174;
      goto LABEL_169;
    }
    if ( a1 > 70199 )
    {
      if ( a1 != 70200 )
        goto LABEL_174;
      goto LABEL_171;
    }
    if ( a1 > 70099 )
    {
      if ( a1 == 70100 )
        goto LABEL_173;
      goto LABEL_174;
    }
    if ( a1 > 70049 )
    {
      switch ( a1 )
      {
        case 70050LL:
          v1 = kWasteNearFullMsg[0];
          break;
        case 70051LL:
          v1 = (const char *)kHighTemperMsg;
          break;
        case 70052LL:
          v1 = (const char *)kLowTemperMsg;
          break;
        case 70053LL:
          v1 = (const char *)kCartridgeMsg;
          break;
        case 70054LL:
          v1 = kDiscGuideMsg;
          break;
        case 70055LL:
        case 70060LL:
          v1 = (const char *)kCartridge2Msg;
          break;
        case 70056LL:
          v1 = (const char *)kVersionMsg;
          break;
        case 70057LL:
          v1 = (const char *)kCartridge3Msg;
          break;
        case 70058LL:
          v1 = (const char *)kCartridgeColorMsg;
          break;
        case 70059LL:
          v1 = (const char *)kCartridgeStrMsg;
          break;
        case 70061LL:
          v1 = (const char *)kCartridgeOldMsg;
          break;
        default:
          goto LABEL_174;
      }
    }
    else if ( a1 > 70000 )
    {
      if ( a1 > 70019 )
      {
        if ( a1 == 70020 )
          goto LABEL_95;
        goto LABEL_174;
      }
      if ( a1 > 70013 )
      {
        if ( a1 != 70014 )
          goto LABEL_174;
        goto LABEL_96;
      }
      switch ( a1 )
      {
        case 70001LL:
          v1 = (const char *)kJournalFullMsg;
          break;
        case 70004LL:
          goto LABEL_97;
        case 70005LL:
          goto LABEL_123;
        case 70007LL:
          v1 = (const char *)kWrongPaperMsg;
          break;
        default:
          goto LABEL_174;
      }
    }
    else
    {
      if ( a1 > 65063 )
      {
        if ( a1 != 65064 )
          goto LABEL_174;
        goto LABEL_112;
      }
      if ( a1 > 65031 )
      {
        if ( a1 != 65032 )
          goto LABEL_174;
        goto LABEL_112;
      }
      if ( a1 <= 7013 )
      {
        if ( a1 == 7004 )
        {
LABEL_97:
          v1 = (const char *)kDocumentJamMsg;
          goto LABEL_176;
        }
        goto LABEL_174;
      }
      if ( a1 > 65015 )
      {
        if ( a1 != 65016 )
          goto LABEL_174;
        goto LABEL_112;
      }
      if ( a1 > 65000 )
      {
        if ( (unsigned __int64)(a1 - 65001) > 7 )
          goto LABEL_174;
        v2 = 139LL;
        if ( !_bittest64(&v2, a1 - 65001) )
          goto LABEL_174;
        goto LABEL_112;
      }
      if ( a1 > 64001 )
      {
        if ( a1 != 64002 )
        {
          if ( a1 != 64004 )
            goto LABEL_174;
          if ( gModelInfo == 2 )
          {
            v1 = (const char *)kBackCoverMsg;
            goto LABEL_176;
          }
        }
        v1 = kCoverOpenMsg[0];
        goto LABEL_176;
      }
      if ( a1 > 60169 )
      {
        if ( a1 == 60170 )
        {
          v1 = (const char *)kStorageMsg;
          goto LABEL_176;
        }
        goto LABEL_174;
      }
      if ( a1 <= 60141 )
      {
        if ( a1 > 60029 )
        {
          if ( a1 == 60030 )
          {
            v1 = (const char *)kPrintMsg;
            goto LABEL_176;
          }
          goto LABEL_174;
        }
        if ( a1 > 60003 )
        {
          if ( a1 != 60004 )
            goto LABEL_174;
          goto LABEL_151;
        }
        if ( a1 > 50029 )
        {
          if ( a1 != 50030 )
            goto LABEL_174;
          goto LABEL_151;
        }
        if ( a1 > 45037 )
        {
          if ( a1 != 45038 )
            goto LABEL_174;
          goto LABEL_147;
        }
        if ( a1 > 41299 )
        {
          if ( a1 == 41300 )
            goto LABEL_145;
          if ( a1 != 41301 )
            goto LABEL_174;
        }
        else
        {
          if ( a1 <= 41199 )
          {
            if ( a1 <= 40999 )
            {
              if ( a1 > 40308 )
              {
                if ( (unsigned __int64)(a1 - 40309) >= 4 )
                  goto LABEL_174;
                goto LABEL_147;
              }
              if ( a1 > 40120 )
              {
                if ( a1 == 40121 )
                {
                  v1 = (const char *)kDuplexMsg;
                  goto LABEL_176;
                }
                goto LABEL_174;
              }
              if ( a1 <= 40056 )
              {
                if ( a1 <= 40037 )
                {
                  if ( a1 <= 40020 )
                  {
                    if ( a1 <= 7899 )
                    {
                      if ( a1 > 7499 )
                      {
                        if ( a1 == 7500 )
                        {
LABEL_161:
                          if ( gModelInfo == 3 )
                            v1 = kWasteFullMsg[0];
                          else
                            v1 = (const char *)kInitUnableMsg;
                          goto LABEL_176;
                        }
                        goto LABEL_174;
                      }
                      if ( a1 > 7419 )
                      {
                        if ( a1 != 7420 )
                          goto LABEL_174;
                      }
                      else
                      {
                        if ( a1 <= 7399 )
                        {
                          if ( a1 <= 7299 )
                          {
                            if ( a1 <= 7199 )
                            {
                              if ( a1 != 7014 )
                              {
                                if ( a1 == 7020 )
                                {
LABEL_95:
                                  v1 = (const char *)kMachineHotMsg;
                                  goto LABEL_176;
                                }
                                if ( a1 == 7100 )
                                {
LABEL_173:
                                  v1 = (const char *)kScanLockMsg;
                                  goto LABEL_176;
                                }
LABEL_174:
                                v1 = 0LL;
                                if ( isMessageAvailable(kGenericMsg) )
                                  v1 = kGenericMsg;
                                goto LABEL_176;
                              }
LABEL_96:
                              v1 = (const char *)kScanCoverOpenMsg;
                              goto LABEL_176;
                            }
                            if ( a1 != 7200 )
                              goto LABEL_174;
LABEL_171:
                            v1 = (const char *)kCommErrorMsg;
                            goto LABEL_176;
                          }
                          if ( a1 != 7300 )
                            goto LABEL_174;
LABEL_169:
                          v1 = (const char *)kPrintUnableMsg;
                          goto LABEL_176;
                        }
                        if ( a1 != 7400 )
                          goto LABEL_174;
                      }
LABEL_167:
                      v1 = kScanUnableMsg;
                      goto LABEL_176;
                    }
                    if ( a1 != 7900 )
                      goto LABEL_174;
LABEL_157:
                    v1 = (const char *)kPrinterLockMsg;
                    goto LABEL_176;
                  }
                  if ( a1 == 40021 )
                  {
                    v1 = (const char *)kFrontCoverMsg;
                    goto LABEL_176;
                  }
                  if ( a1 != 40022 )
                    goto LABEL_174;
LABEL_112:
                  v1 = kPaperJamMsg;
                  goto LABEL_176;
                }
                if ( a1 != 40038 )
                  goto LABEL_174;
LABEL_147:
                v1 = kTonerOutMsg;
                goto LABEL_176;
              }
              if ( a1 != 40057 )
                goto LABEL_174;
LABEL_151:
              v1 = kServiceCallMsg;
              goto LABEL_176;
            }
            if ( a1 != 41000 )
              goto LABEL_174;
LABEL_145:
            v1 = kPaperOutMsg;
            goto LABEL_176;
          }
          if ( a1 == 41200 )
            goto LABEL_145;
          if ( a1 != 41201 )
            goto LABEL_174;
        }
LABEL_143:
        v1 = kNoTrayMsg;
        goto LABEL_176;
      }
      if ( a1 <= 60147 )
      {
        if ( a1 == 60142 )
        {
LABEL_123:
          v1 = (const char *)kSizeMsg;
          goto LABEL_176;
        }
        goto LABEL_174;
      }
      switch ( a1 )
      {
        case 60148LL:
          goto LABEL_145;
        case 60152LL:
          v1 = (const char *)kDeviceMsg;
          break;
        case 60153LL:
          v1 = (const char *)kRegistMsg;
          break;
        case 60157LL:
          v1 = (const char *)kShortPaperMsg;
          break;
        case 60158LL:
          v1 = (const char *)kSmallPaperMsg;
          break;
        case 60159LL:
          v1 = (const char *)kCondensationMsg;
          break;
        default:
          goto LABEL_174;
      }
    }
  }
LABEL_176:
  v3 = gModelInfo;
  if ( !gModelInfo
    || v1 && strcmp(v1, kGenericMsg) && strcmp(v1, kPaperJamMsg) && strcmp(v1, kPaperOutMsg) && strcmp(v1, kNoTrayMsg)
    || a1 == 10001
    || a1 == 10023 )
  {
    return (char *)v1;
  }
  if ( (unsigned __int64)(a1 - 10205) <= 3 )
    return (char *)kDrumLowMsg;
  if ( (unsigned __int64)(a1 - 10209) <= 3 )
    return kTonerLowMsg;
  if ( a1 == 10215 )
    return (char *)kBeltUnitLowMsg;
  if ( (unsigned __int64)(a1 - 10305) <= 3 )
    return (char *)kDrumOutMsg;
  if ( a1 > 30016 )
  {
    if ( a1 == 30017 )
      return (char *)kOverrunMsg;
  }
  else
  {
    if ( a1 <= 12200 )
    {
      if ( a1 == 10315 )
        return (char *)kBeltUnitOutMsg;
      if ( a1 == 10316 )
        return (char *)kUnitOutMsg;
      goto LABEL_207;
    }
    if ( a1 > 15000 )
    {
      if ( a1 > 15010 )
      {
        if ( a1 != 15011 && a1 != 15021 )
        {
          if ( a1 == 15022 )
            return (char *)kOptionalOutputFullMsg;
          goto LABEL_207;
        }
      }
      else if ( a1 != 15001 )
      {
        goto LABEL_207;
      }
      return kOutputBinFullMsg[0];
    }
    if ( a1 == 12201 )
      return kNoTrayMsg;
  }
LABEL_207:
  if ( (unsigned __int64)(a1 - 35040) <= 9 )
    return (char *)kResolutionMsg;
  if ( a1 <= 40025 )
  {
    if ( a1 == 40000 )
      return (char *)v1;
    goto LABEL_233;
  }
  if ( a1 <= 40140 )
  {
    if ( a1 == 40026 )
      return (char *)kWasteMissMsg;
    goto LABEL_233;
  }
  if ( a1 <= 40304 )
  {
    if ( a1 != 40141 )
      goto LABEL_233;
    return kWasteFullMsg[0];
  }
  if ( a1 <= 40414 )
  {
    if ( (unsigned __int64)(a1 - 40305) >= 4 )
      goto LABEL_233;
    return (char *)kDrumMsg;
  }
  if ( a1 <= 40999 )
  {
    if ( a1 != 40415 )
      goto LABEL_233;
    return (char *)kBeltUnitMissMsg;
  }
  if ( a1 > 60101 )
  {
    if ( a1 == 60102 )
      return kWasteFullMsg[0];
    if ( a1 != 60149 )
    {
      if ( a1 != 60156 )
        goto LABEL_233;
      return (char *)kDrumMsg;
    }
    return (char *)kBeltUnitMissMsg;
  }
  if ( a1 == 41000 )
  {
    if ( !isMessageAvailable(kScanUnableMsg) )
      return (char *)kMPSizeMsg;
    return kPaperOutMsg;
  }
LABEL_233:
  if ( (unsigned __int64)(a1 - 41001) <= 8 )
    return (char *)kMPSizeMsg;
  if ( (unsigned __int64)(a1 - 41100) <= 0x63 )
    return (char *)kManualSizeMsg;
  if ( a1 == 41200 )
  {
    if ( !isMessageAvailable(kScanUnableMsg) )
      return (char *)kTray1SizeMsg;
    return kPaperOutMsg;
  }
  if ( (unsigned __int64)(a1 - 41201) <= 0x62 )
    return (char *)kTray1SizeMsg;
  if ( a1 == 41300 )
  {
    if ( isMessageAvailable(kScanUnableMsg) )
      return kPaperOutMsg;
    return (char *)kTray2SizeMsg;
  }
  if ( (unsigned __int64)(a1 - 41301) <= 0x62 )
    return (char *)kTray2SizeMsg;
  if ( (unsigned __int64)(a1 - 41400) <= 0x63 )
    return (char *)kTray3SizeMsg;
  if ( (unsigned __int64)(a1 - 41500) <= 0x63 )
    return (char *)kTray4SizeMsg;
  if ( a1 <= 44100 )
  {
    switch ( a1 )
    {
      case 42101LL:
        return (char *)kA1JamMsg;
      case 42102LL:
        return (char *)kA2JamMsg;
      case 42103LL:
        return (char *)kBJamMsg;
      case 42104LL:
        return (char *)kCJamMsg;
      case 42107LL:
        return (char *)kDuplexJamMsg;
      default:
        goto LABEL_261;
    }
  }
  if ( a1 > 44113 )
  {
    switch ( a1 )
    {
      case 44114LL:
        return (char *)kTray1JamMsg;
      case 44115LL:
        return (char *)kInsideJamMsg;
      case 44116LL:
        return (char *)kDuplexJamMsg;
    }
  }
  else
  {
    if ( a1 == 44101 )
      return (char *)kMPJamMsg;
    if ( a1 == 44102 )
      return (char *)kRearJamMsg;
  }
LABEL_261:
  if ( (unsigned __int64)(a1 - 50000) > 9 )
  {
    if ( a1 > 50075 )
    {
      if ( a1 > 59999 )
      {
        if ( a1 <= 60102 )
        {
          if ( a1 > 60020 )
          {
            switch ( a1 )
            {
              case 60021LL:
              case 60029LL:
                v1 = (const char *)kBackCoverMsg;
                break;
              case 60023LL:
                v1 = (const char *)kAutoSizeMsg;
                break;
              case 60026LL:
                v1 = (const char *)kNoDXTrayMsg;
                break;
              case 60027LL:
                v1 = (const char *)kDuplexLeverMsg;
                break;
              default:
                goto LABEL_326;
            }
          }
          else
          {
            switch ( a1 )
            {
              case 60000LL:
                if ( isMessageAvailable(kStorageFullMsg) )
                  v1 = kStorageFullMsg;
                else
LABEL_334:
                  v1 = (const char *)kTrayManyMsg;
                break;
              case 60003LL:
                v1 = (const char *)kInsideHotMsg;
                break;
              case 60004LL:
                return kServiceCallMsg;
              case 60005LL:
                if ( !isMessageAvailable(kDrumDustMsg) )
                  return (char *)kDrumMsg;
                v1 = kDrumDustMsg;
                break;
              case 60009LL:
                goto LABEL_306;
              default:
                goto LABEL_326;
            }
          }
          return (char *)v1;
        }
        if ( a1 > 60111 )
        {
          if ( a1 > 60159 )
          {
            switch ( a1 )
            {
              case 60160LL:
                v1 = (const char *)kDrumOut2Msg;
                break;
              case 60161LL:
                v1 = (const char *)kBeltUnitOut2Msg;
                break;
              case 60162LL:
                if ( v3 == 2 )
                  v1 = (const char *)kHighTemperMsg;
                break;
              case 60163LL:
                v1 = (const char *)kTonerEnd2Msg;
                break;
              default:
                goto LABEL_326;
            }
            return (char *)v1;
          }
          if ( a1 > 60143 )
          {
            switch ( a1 )
            {
              case 60144LL:
                v1 = (const char *)kCartridgeMsg;
                break;
              case 60146LL:
                v1 = (const char *)kTray1MissMsg;
                break;
              case 60147LL:
                v1 = (const char *)kTray2MissMsg;
                break;
              case 60148LL:
                return kPaperOutMsg;
              case 60150LL:
                v1 = (const char *)kELMsg;
                break;
              case 60151LL:
LABEL_306:
                v1 = (const char *)kTonerMsg;
                break;
              default:
                goto LABEL_326;
            }
            return (char *)v1;
          }
          if ( a1 > 60130 )
          {
            if ( a1 == 60131 )
              return (char *)kT1SizeMsg;
            if ( a1 == 60132 )
              return (char *)kT2SizeMsg;
          }
          else if ( a1 > 60119 )
          {
            if ( a1 == 60120 )
              return (char *)kDuplexMsg;
            if ( a1 == 60122 )
              return (char *)kDrumMissMsg;
          }
          else
          {
            if ( a1 == 60112 )
              return (char *)kRollerMissMsg;
            if ( a1 == 60114 )
              return (char *)kOutputTrayMsg;
          }
        }
        else
        {
          if ( a1 == 60103 )
            return (char *)kBeltMissMsg;
          if ( a1 == 60104 )
            return (char *)kUnitMissMsg;
        }
      }
      else if ( a1 == 50076 )
      {
        return (char *)kUnitMsg;
      }
    }
    else if ( a1 == 50010 )
    {
      if ( v3 == 2 || isMessageAvailable(kScanUnableMsg) )
        return (char *)kUnitHotMsg;
      if ( isMessageAvailable(kE49Msg) )
        return kE49Msg;
      return kServiceCallMsg;
    }
LABEL_326:
    if ( (a1 & 0xFFFFFFFFFFFFFFFCLL) == 0xEB04 )
      return (char *)kLogAccessMsg;
    switch ( a1 )
    {
      case 60168LL:
        return (char *)kTray3MissMsg;
      case 60169LL:
        return (char *)kTray4MissMsg;
      case 60171LL:
        return (char *)kTrayID1MissMsg;
      case 60172LL:
        return (char *)kTrayID2MissMsg;
      case 60173LL:
        return (char *)kTrayID3MissMsg;
      case 60174LL:
        return (char *)kTrayID4MissMsg;
      default:
        if ( (unsigned __int64)(a1 - 60175) > 3 )
        {
          if ( a1 > 62001 )
          {
            if ( a1 > 62101 )
            {
              switch ( a1 )
              {
                case 62102LL:
                  v1 = kWasteNearFullMsg[0];
                  break;
                case 62103LL:
                  v1 = kBeltOutMsg[0];
                  break;
                case 62104LL:
                  return (char *)kUnitOutMsg;
                case 62105LL:
                  v1 = (const char *)kKitOutMsg;
                  break;
                case 62109LL:
                  v1 = (const char *)kKit1OutMsg;
                  break;
                case 62110LL:
                  v1 = (const char *)kKit2OutMsg;
                  break;
                case 62111LL:
                  v1 = (const char *)kKit3OutMsg;
                  break;
                case 62112LL:
                  v1 = (const char *)kKit4OutMsg;
                  break;
                case 62116LL:
                  v1 = (const char *)kKitMPOutMsg;
                  break;
                case 62117LL:
                  return (char *)kBeltUnitOutMsg;
                case 62119LL:
                  return (char *)kDrumOutMsg;
                case 62120LL:
                  return (char *)kBeltUnitLowMsg;
                case 62121LL:
                  v1 = (const char *)kTonerEndMsg;
                  break;
                default:
                  goto LABEL_352;
              }
              return (char *)v1;
            }
            if ( a1 == 62002 )
              return (char *)kLserUnitOutMsg;
            if ( a1 == 62003 )
              return (char *)kDrumLowMsg;
          }
          else if ( a1 == 60179 )
          {
            goto LABEL_334;
          }
LABEL_352:
          if ( (unsigned __int64)(a1 - 62122) > 3 )
          {
            if ( a1 == 65001 )
              return (char *)kMPJamMsg;
            v7 = a1 & 0xFFFFFFFFFFFFFFFELL;
            if ( (__int64)(a1 & 0xFFFFFFFFFFFFFFFELL) > 65007 )
            {
              switch ( v7 )
              {
                case 0xFDF0uLL:
                  return (char *)kTray3JamMsg;
                case 0xFDF4uLL:
                  return (char *)kTray4JamMsg;
                case 0xFDF6uLL:
                  return (char *)kInsideJamMsg;
              }
            }
            else
            {
              if ( v7 == 65002 )
                return (char *)kTray1JamMsg;
              if ( v7 == 65004 )
                return (char *)kTray2JamMsg;
            }
            if ( a1 > 65031 )
            {
              switch ( a1 )
              {
                case 65032LL:
                  return (char *)kRearJamMsg;
                case 65048LL:
                  return (char *)kOptionJamMsg;
                case 65064LL:
                  return (char *)kDuplexJamMsg;
              }
            }
            else if ( a1 == 65016 )
            {
              return (char *)kCJamMsg;
            }
            if ( isMessageAvailable(kGenericMsg) )
              return kGenericMsg;
            return (char *)v1;
          }
          v1 = kMediaLowMsg[0];
        }
        else
        {
          v1 = (const char *)kWrongSizeMsg;
        }
        break;
    }
    return (char *)v1;
  }
  if ( (unsigned __int64)(a1 - 50000) > 8 )
    v4 = &kServiceCallMsg;
  else
    v4 = (char **)*(&off_100014470 + a1 - 50000);
  v5 = *v4;
  if ( !isMessageAvailable(*v4) )
    return kServiceCallMsg;
  return v5;
}
// 100014470: using guessed type _UNKNOWN *off_100014470;
// 100015750: using guessed type char *kWasteFullMsg[11];
// 100015758: using guessed type char *kWasteNearFullMsg[10];
// 100015760: using guessed type char *kCoverOpenMsg[9];
// 100015768: using guessed type char *kMediaLowMsg[8];
// 100015780: using guessed type char *kBeltOutMsg[5];
// 100015790: using guessed type char *kOutputBinFullMsg[3];
// 1000157A0: using guessed type char *kServiceCallMsg;
// 100015D50: using guessed type int gModelInfo;

//----- (00000001000040D4) ----------------------------------------------------
char *__fastcall getStandardStatus(char *__s1)
{
  char *v1; // rbx
  CFStringRef v2; // r15
  __CFBundle *v3; // rax
  __CFBundle *v4; // r12
  const __CFDictionary *v5; // rax
  const __CFDictionary *v6; // r13
  const __CFString *StatusValue; // rax

  v1 = __s1;
  __bzero(getStandardStatus_buf, 512LL);
  if ( !strncmp(__s1, "com", 3uLL) )
  {
    v2 = CFStringCreateWithCString(kCFAllocatorDefault, __s1, 0x600u);
    v1 = 0LL;
    if ( v2 )
    {
      v3 = copyCommandFilterBundle();
      v4 = v3;
      v1 = 0LL;
      if ( v3 )
      {
        v5 = copyPlistfromBundle(v3, CFSTR("StandardStatus"));
        v6 = v5;
        v1 = 0LL;
        if ( v5 )
        {
          StatusValue = (const __CFString *)getStatusValue(v5, v2);
          v1 = 0LL;
          if ( StatusValue )
          {
            v1 = 0LL;
            if ( CFStringGetCString(StatusValue, getStandardStatus_buf, 512LL, 0x600u) )
              v1 = getStandardStatus_buf;
          }
          CFRelease(v6);
        }
        CFRelease(v4);
      }
      CFRelease(v2);
    }
  }
  return v1;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);
// 100015510: using guessed type __CFString cfstr_Standardstatus;

//----- (00000001000041B7) ----------------------------------------------------
__int64 __fastcall getStatusMessageFromResource(char *cStr)
{
  CFStringRef v1; // r12
  __CFBundle *v2; // r14
  CFStringRef v3; // rax
  CFStringRef v5; // r15
  const __CFDictionary *v6; // rax
  const __CFDictionary *Value; // rax
  const __CFDictionary *v8; // rbx
  const void *v9; // rax
  const __CFString *v10; // rax
  const __CFString *v11; // r13
  CFStringRef v12; // rax
  const __CFString *v13; // rbx
  const void *StatusValue; // [rsp+8h] [rbp-38h]
  const __CFDictionary *v15; // [rsp+10h] [rbp-30h]

  if ( isMessageAvailable(cStr) )
  {
    __bzero(getStatusMessageFromResource_buf, 512LL);
    v1 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x600u);
    if ( v1 )
    {
      v2 = copyCommandFilterBundle();
      if ( v2 )
      {
        if ( isMessageAvailable(kScanUnableMsg) )
          v3 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, CFSTR("%d"), (unsigned int)gModelInfo);
        else
          v3 = CFStringCreateWithFormat(
                 kCFAllocatorDefault,
                 0LL,
                 CFSTR("%d-%d"),
                 (unsigned int)gModelInfo,
                 (unsigned int)dword_100015D54);
        v5 = v3;
        if ( v3 )
        {
          v6 = copyPlistfromBundle(v2, CFSTR("StatusMessage"));
          if ( v6 )
          {
            v15 = v6;
            Value = (const __CFDictionary *)CFDictionaryGetValue(v6, v5);
            v8 = Value;
            if ( Value )
            {
              StatusValue = getStatusValue(Value, CFSTR("model"));
              v9 = getStatusValue(v8, v1);
              if ( StatusValue )
              {
                if ( v9 )
                {
                  v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, CFSTR("%@%@"), StatusValue, v9);
                  v11 = v10;
                  if ( v10 )
                  {
                    v12 = CFBundleCopyLocalizedString(v2, v10, v10, 0LL);
                    v13 = v12;
                    if ( v12 )
                    {
                      if ( !CFEqual(v12, v11) )
                      {
                        if ( CFStringGetCString(v13, getStatusMessageFromResource_buf, 512LL, 0x8000100u) )
                          qword_100015CB0 = (__int64)getStatusMessageFromResource_buf;
                      }
                      CFRelease(v13);
                    }
                    CFRelease(v11);
                  }
                }
              }
            }
            CFRelease(v15);
          }
          CFRelease(v5);
        }
        CFRelease(v2);
      }
      CFRelease(v1);
    }
    return (unsigned int)-(qword_100015CB0 == 0);
  }
  else
  {
    qword_100015CB0 = 0LL;
    return 0LL;
  }
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);
// 1000154B0: using guessed type __CFString cfstr_Statusmessage;
// 1000154D0: using guessed type __CFString cfstr_Model;
// 100015CB0: using guessed type __int64 qword_100015CB0;
// 100015D50: using guessed type int gModelInfo;
// 100015D54: using guessed type int dword_100015D54;

//----- (000000010000439C) ----------------------------------------------------
__int64 __fastcall getStatusMessageFromDevice(double a1)
{
  if ( gGetStatusMode == 1 )
    return getSideChannelSNMPData(kStatusMsgID, a1);
  else
    return (unsigned int)(((gGetStatusMode != 2) | (unsigned __int8)(qword_100015CB0 == 0)) << 31 >> 31);
}
// 100015CB0: using guessed type __int64 qword_100015CB0;
// 100016C30: using guessed type int gGetStatusMode;

//----- (00000001000043D6) ----------------------------------------------------
char *__fastcall convertWarningErrorStatusMessage(char *cStr)
{
  char *v1; // rbx
  const __CFString *v2; // rax
  const __CFString *v3; // r14
  CFIndex Length; // rax
  const __CFString *MutableCopy; // rax
  __CFString *v6; // r15
  CFIndex v7; // rax
  const __CFString *v8; // rsi
  const __CFString *v9; // rdx

  xmmword_100017360 = 0LL;
  xmmword_100017350 = 0LL;
  xmmword_100017340 = 0LL;
  xmmword_100017330 = 0LL;
  xmmword_100017320 = 0LL;
  xmmword_100017310 = 0LL;
  xmmword_100017300 = 0LL;
  *(_OWORD *)convertWarningErrorStatusMessage_buf = 0LL;
  v1 = 0LL;
  if ( cStr )
  {
    v2 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x600u);
    v3 = v2;
    v1 = 0LL;
    if ( v2 )
    {
      Length = CFStringGetLength(v2);
      MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, Length, v3);
      v6 = (__CFString *)MutableCopy;
      v1 = 0LL;
      if ( !MutableCopy )
      {
LABEL_12:
        CFRelease(v3);
        return v1;
      }
      if ( CFStringHasSuffix(MutableCopy, CFSTR("-report")) )
      {
        v7 = CFStringGetLength(v6);
        v8 = CFSTR("-report");
        v9 = CFSTR("-warning");
      }
      else
      {
        if ( !CFStringHasSuffix(v6, CFSTR("-warning")) )
        {
LABEL_9:
          v1 = 0LL;
          if ( CFStringGetCString(v6, convertWarningErrorStatusMessage_buf, 128LL, 0x8000100u) )
            v1 = convertWarningErrorStatusMessage_buf;
          CFRelease(v6);
          goto LABEL_12;
        }
        v7 = CFStringGetLength(v6);
        v8 = CFSTR("-warning");
        v9 = CFSTR("-report");
      }
      CFStringFindAndReplace(v6, v8, v9, (CFRange)__PAIR128__(v7, 0LL), 0LL);
      goto LABEL_9;
    }
  }
  return v1;
}
// 100017300: using guessed type __int128 xmmword_100017300;
// 100017310: using guessed type __int128 xmmword_100017310;
// 100017320: using guessed type __int128 xmmword_100017320;
// 100017330: using guessed type __int128 xmmword_100017330;
// 100017340: using guessed type __int128 xmmword_100017340;
// 100017350: using guessed type __int128 xmmword_100017350;
// 100017360: using guessed type __int128 xmmword_100017360;

//----- (000000010000451A) ----------------------------------------------------
__int64 __fastcall getDeviceSupplyLevels(double a1)
{
  int BackChannelData; // eax
  int v2; // ebx
  __int64 v3; // r12
  char *v4; // r14
  size_t v5; // r15
  char *v6; // r13
  size_t v7; // r12
  __int64 v8; // rbx
  size_t v9; // r14
  char v10; // al
  char *v11; // rdi
  size_t v12; // r12
  __int64 v13; // rbx
  size_t v14; // r14
  char v15; // al
  size_t v16; // r14
  __int64 v17; // rbx
  size_t v18; // r14
  char v19; // al
  __int64 v20; // rax
  char *v21; // r14
  char *v22; // rdi
  __int64 v23; // rdx
  char *v24; // rax
  const char *v25; // rbx
  size_t v26; // r12
  size_t v27; // rax
  size_t v28; // rdx
  size_t v29; // rcx
  const char *v30; // rbx
  const char *v31; // rcx
  size_t v32; // r12
  size_t v33; // rax
  size_t v34; // r14
  char *v35; // rbx
  char *v36; // rbx
  char *v37; // r15
  char *v39; // [rsp+20h] [rbp-1070h]
  int v40; // [rsp+28h] [rbp-1068h]
  size_t v41; // [rsp+30h] [rbp-1060h]
  size_t v42; // [rsp+38h] [rbp-1058h]
  size_t v43; // [rsp+40h] [rbp-1050h]
  int SideChannelSNMPData; // [rsp+4Ch] [rbp-1044h]
  char *v45; // [rsp+50h] [rbp-1040h]
  char *v46; // [rsp+58h] [rbp-1038h]
  size_t v47; // [rsp+58h] [rbp-1038h]
  char *v48; // [rsp+58h] [rbp-1038h]
  char v49[1024]; // [rsp+60h] [rbp-1030h] BYREF
  char v50[1024]; // [rsp+460h] [rbp-C30h] BYREF
  char v51[1024]; // [rsp+860h] [rbp-830h] BYREF
  char __s[1024]; // [rsp+C60h] [rbp-430h] BYREF

  qword_100015D38 = -1LL;
  qword_100015D30 = -1LL;
  qword_100015D28 = -1LL;
  qword_100015D20 = -1LL;
  qword_100015D18 = -1LL;
  qword_100015D10 = -1LL;
  qword_100015D08 = -1LL;
  qword_100015D00 = -1LL;
  qword_100015CF8 = -1LL;
  qword_100015CF0 = -1LL;
  qword_100015CE8 = -1LL;
  qword_100015CE0 = -1LL;
  qword_100015CD8 = -1LL;
  qword_100015CD0 = -1LL;
  qword_100015CC8 = -1LL;
  qword_100015CC0 = -1LL;
  if ( gGetStatusMode == 2 )
  {
    BackChannelData = getBackChannelData(a1);
    switch ( gModelInfo )
    {
      case 0:
      case 3:
        goto LABEL_12;
      case 1:
        if ( dword_100015D54 > 7 )
          goto LABEL_12;
        goto LABEL_14;
      case 2:
        if ( dword_100015D54 <= 4 )
          goto LABEL_14;
LABEL_12:
        if ( qword_100015CC0 >= 0 )
        {
          v40 = 0;
          goto LABEL_19;
        }
        v40 = 0;
        SideChannelSNMPData = BackChannelData;
        getBackChannelData(a1);
        goto LABEL_20;
      default:
LABEL_14:
        v40 = 1;
        if ( BackChannelData <= 0 )
          goto LABEL_19;
        v2 = 0;
        break;
    }
    while ( 1 )
    {
      SideChannelSNMPData = BackChannelData;
      if ( gStatus[0] != 10003 && gStatus[0] != 0 || v2 > 2 )
        break;
      BackChannelData = getBackChannelData(a1);
      ++v2;
      if ( BackChannelData <= 0 )
        goto LABEL_19;
    }
  }
  else
  {
    v40 = 0;
    if ( gGetStatusMode == 1 )
    {
      BackChannelData = getSideChannelSNMPData(kSupplyLevelID, a1);
      if ( qword_100015CC0 >= 0 )
      {
LABEL_19:
        SideChannelSNMPData = BackChannelData;
      }
      else
      {
        SideChannelSNMPData = BackChannelData;
        if ( gModelInfo == 1 && dword_100015D54 <= 7 )
        {
          SideChannelSNMPData = getSideChannelSNMPData(kStatusID, a1);
          v40 = 1;
        }
      }
    }
    else
    {
      SideChannelSNMPData = -1;
    }
  }
LABEL_20:
  v3 = 0LL;
  __sprintf_chk(__s, 0, 0x400uLL, "%s", kMarkerColor);
  v43 = strlen(__s);
  v46 = &__s[v43];
  __sprintf_chk(v51, 0, 0x400uLL, "%s", kMarkerLevel[0]);
  v42 = strlen(v51);
  v45 = &v51[v42];
  __sprintf_chk(v50, 0, 0x400uLL, "%s", kMarkerName[0]);
  v41 = strlen(v50);
  v4 = &v50[v41];
  __sprintf_chk(v49, 0, 0x400uLL, "%s", kMarkerType);
  v5 = strlen(v49);
  v6 = &v49[v5];
  v39 = &v50[v41];
  switch ( gModelInfo )
  {
    case 0:
      do
      {
        if ( gStatus[v3 + 3] < 0 )
          gStatus[v3 + 3] = -1LL;
        ++v3;
      }
      while ( v3 != 4 );
      if ( dword_100015D54 > 14 )
      {
        v7 = v41;
        v17 = 0LL;
        __sprintf_chk(v46, 0, 0xFFFFFFFFFFFFFFFFLL, "#ff00ff,#00ffff,#ffff00,#000000");
        v47 = strlen(v46);
        __sprintf_chk(
          v45,
          0,
          0xFFFFFFFFFFFFFFFFLL,
          "%ld,%ld,%ld,%ld",
          qword_100015CD0,
          qword_100015CC8,
          qword_100015CD8,
          qword_100015CC0);
        v18 = v42 + strlen(v45);
        v19 = 1;
        do
        {
          if ( gLowLevel[v17] < 0 )
            v19 = 0;
          ++v17;
        }
        while ( v17 != 4 );
        if ( v19 )
        {
          __sprintf_chk(
            &v51[v18],
            0,
            0xFFFFFFFFFFFFFFFFLL,
            " %s%d,%d,%d,%d",
            kMarkerLowLevel[0],
            dword_100015D48,
            dword_100015D44,
            dword_100015D4C,
            gLowLevel[0]);
          v45 = &v51[v18 + strlen(&v51[v18])];
        }
        else
        {
          v45 = &v51[v18];
        }
        v30 = &v50[v41];
        __sprintf_chk(v39, 0, 0xFFFFFFFFFFFFFFFFLL, "Magenta,Cyan,Yellow,Black");
      }
      else
      {
        v7 = v41;
        v8 = 0LL;
        __sprintf_chk(v46, 0, 0xFFFFFFFFFFFFFFFFLL, "#000000,#ffff00,#00ffff,#ff00ff");
        v47 = strlen(v46);
        __sprintf_chk(
          v45,
          0,
          0xFFFFFFFFFFFFFFFFLL,
          "%ld,%ld,%ld,%ld",
          qword_100015CC0,
          qword_100015CD8,
          qword_100015CC8,
          qword_100015CD0);
        v9 = v42 + strlen(v45);
        v10 = 1;
        do
        {
          if ( gLowLevel[v8] < 0 )
            v10 = 0;
          ++v8;
        }
        while ( v8 != 4 );
        if ( v10 )
        {
          __sprintf_chk(
            &v51[v9],
            0,
            0xFFFFFFFFFFFFFFFFLL,
            " %s%d,%d,%d,%d",
            kMarkerLowLevel[0],
            gLowLevel[0],
            dword_100015D4C,
            dword_100015D44,
            dword_100015D48);
          v45 = &v51[v9 + strlen(&v51[v9])];
        }
        else
        {
          v45 = &v51[v9];
        }
        v30 = &v50[v41];
        __sprintf_chk(v39, 0, 0xFFFFFFFFFFFFFFFFLL, "Black,Yellow,Cyan,Magenta");
      }
      v4 = &v50[v7 + strlen(v30)];
      v46 = &__s[v43 + v47];
      v31 = "ink,ink,ink,ink";
      goto LABEL_81;
    case 1:
      v11 = &__s[v43];
      if ( dword_100015D54 <= 7 )
      {
        if ( gGetStatusMode != 1 || v40 )
        {
          if ( SideChannelSNMPData > 0 )
          {
            v24 = determineStatus(gStatus[0]);
            v25 = v24;
            if ( v24 )
            {
              if ( !strcmp(v24, kTonerLowMsg) )
              {
                qword_100015CC0 = 10LL;
                v11 = &__s[v43];
              }
              else
              {
                v11 = &__s[v43];
                if ( !strcmp(v25, kTonerOutMsg) )
                  qword_100015CC0 = 0LL;
              }
            }
            else
            {
              qword_100015CC0 = -3LL;
              v11 = &__s[v43];
            }
          }
        }
        else if ( qword_100015CC0 < 0 )
        {
          qword_100015CC0 = -1LL;
        }
        else if ( qword_100015CC0 >= 11 )
        {
          qword_100015CC0 = -3LL;
        }
      }
      __sprintf_chk(v11, 0, 0xFFFFFFFFFFFFFFFFLL, "#000000");
      v32 = v43 + strlen(v11);
      __sprintf_chk(v45, 0, 0xFFFFFFFFFFFFFFFFLL, "%ld", qword_100015CC0);
      v33 = strlen(v45);
      v34 = v42 + v33;
      v35 = &v51[v42 + v33];
      if ( gLowLevel[0] < 0 )
      {
        v45 = &v51[v42 + v33];
      }
      else
      {
        __sprintf_chk(v35, 0, 0xFFFFFFFFFFFFFFFFLL, " %s%d", kMarkerLowLevel[0], gLowLevel[0]);
        v45 = &v51[v34 + strlen(v35)];
      }
      v46 = &__s[v32];
      v3 = 0LL;
      __sprintf_chk(v39, 0, 0xFFFFFFFFFFFFFFFFLL, "Black");
      v4 = &v50[v41 + strlen(v39)];
      v31 = "toner";
      goto LABEL_89;
    case 2:
      if ( dword_100015D54 < 5 )
      {
        v20 = 0LL;
        if ( gGetStatusMode == 1 )
        {
          v21 = &v51[v42];
          v22 = &__s[v43];
          do
          {
            v23 = gStatus[v20 + 3];
            if ( v23 < 0 )
            {
              gStatus[v20 + 3] = -1LL;
            }
            else if ( v23 >= 11 )
            {
              gStatus[v20 + 3] = -3LL;
            }
            ++v20;
          }
          while ( v20 != 4 );
        }
        else
        {
          v21 = &v51[v42];
          v22 = &__s[v43];
          if ( SideChannelSNMPData > 0 )
          {
            v22 = &__s[v43];
            if ( !determineStatus(gStatus[0]) )
            {
              memset_pattern16(&qword_100015CC0, &memset_pattern, 0x20uLL);
              v22 = &__s[v43];
            }
          }
        }
        __sprintf_chk(v22, 0, 0xFFFFFFFFFFFFFFFFLL, "#00ffff,#ff00ff,#ffff00,#000000");
        v26 = strlen(v22);
        __sprintf_chk(
          v21,
          0,
          0xFFFFFFFFFFFFFFFFLL,
          "%ld,%ld,%ld,%ld",
          qword_100015CC8,
          qword_100015CD0,
          qword_100015CD8,
          qword_100015CC0);
        v45 = &v51[v42 + strlen(v21)];
        __sprintf_chk(v39, 0, 0xFFFFFFFFFFFFFFFFLL, "Cyan,Magenta,Yellow,Black");
        v27 = strlen(v39);
        v28 = v26;
        v29 = v43;
        v12 = v41;
      }
      else
      {
        v12 = v41;
        v13 = 0LL;
        __sprintf_chk(v46, 0, 0xFFFFFFFFFFFFFFFFLL, "#000000,#00ffff,#ff00ff,#ffff00");
        v48 = (char *)strlen(v46);
        __sprintf_chk(
          v45,
          0,
          0xFFFFFFFFFFFFFFFFLL,
          "%ld,%ld,%ld,%ld",
          qword_100015CC0,
          qword_100015CC8,
          qword_100015CD0,
          qword_100015CD8);
        v14 = v42 + strlen(v45);
        v15 = 1;
        do
        {
          if ( gLowLevel[v13] < 0 )
            v15 = 0;
          ++v13;
        }
        while ( v13 != 4 );
        if ( v15 )
        {
          __sprintf_chk(
            &v51[v14],
            0,
            0xFFFFFFFFFFFFFFFFLL,
            " %s%d,%d,%d,%d",
            kMarkerLowLevel[0],
            gLowLevel[0],
            dword_100015D44,
            dword_100015D48,
            dword_100015D4C);
          v45 = &v51[v14 + strlen(&v51[v14])];
        }
        else
        {
          v45 = &v51[v14];
        }
        __sprintf_chk(v39, 0, 0xFFFFFFFFFFFFFFFFLL, "Black,Cyan,Magenta,Yellow");
        v27 = strlen(v39);
        v29 = v43;
        v28 = (size_t)v48;
      }
      v4 = &v50[v12 + v27];
      v46 = &__s[v29 + v28];
      v31 = "toner,toner,toner,toner";
LABEL_81:
      v3 = 0LL;
LABEL_89:
      __sprintf_chk(v6, 0, 0xFFFFFFFFFFFFFFFFLL, v31);
      goto LABEL_90;
    case 3:
      if ( qword_100015CC0 < 0 )
        qword_100015CC0 = -1LL;
      __sprintf_chk(v46, 0, 0xFFFFFFFFFFFFFFFFLL, "#000000");
      v16 = v43 + strlen(v46);
      __sprintf_chk(v45, 0, 0xFFFFFFFFFFFFFFFFLL, "%ld", qword_100015CC0);
      if ( gLowLevel[0] >= 0 )
        __sprintf_chk(v45, 0, 0xFFFFFFFFFFFFFFFFLL, " %s%d", kMarkerLowLevel[0], gLowLevel[0]);
      v46 = &__s[v16];
      v45 = &v51[v42 + strlen(v45)];
      v3 = 0LL;
      __sprintf_chk(v39, 0, 0xFFFFFFFFFFFFFFFFLL, "Black");
      v4 = &v50[v41 + strlen(v39)];
      __sprintf_chk(v6, 0, 0xFFFFFFFFFFFFFFFFLL, "ink");
LABEL_90:
      v6 = &v49[v5 + strlen(v6)];
      break;
    default:
      goto LABEL_91;
  }
  do
  {
LABEL_91:
    if ( *(unsigned __int64 *)((char *)&gStatus[7] + v3) <= 0xA )
    {
      if ( !strcmp(__s, kMarkerColor) )
      {
        v37 = v45;
        v36 = v46;
      }
      else
      {
        *v46 = 44;
        v36 = v46 + 1;
        *v45 = 44;
        v37 = v45 + 1;
        *v4++ = 44;
        *v6++ = 44;
      }
      __sprintf_chk(v36, 0, 0xFFFFFFFFFFFFFFFFLL, "none");
      v46 = &v36[strlen(v36)];
      __sprintf_chk(v37, 0, 0xFFFFFFFFFFFFFFFFLL, "%ld", *(__int64 *)((char *)&gStatus[7] + v3));
      v45 = &v37[strlen(v37)];
      __sprintf_chk(v4, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", *(char **)((char *)supplyName + v3));
      v4 += strlen(v4);
      __sprintf_chk(v6, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", *(char **)((char *)supplyType + v3));
      v6 += strlen(v6);
    }
    v3 += 8LL;
  }
  while ( v3 != 96 );
  if ( strcmp(__s, kMarkerColor) )
    fprintf(__stderrp, "%s%s %s %s %s\n", "ATTR: ", __s, v51, v50, v49);
  return (unsigned int)SideChannelSNMPData;
}
// 100015BA8: using guessed type char *kMarkerLevel[4];
// 100015BB0: using guessed type char *kMarkerLowLevel[3];
// 100015BB8: using guessed type char *kMarkerName[2];
// 100015BC0: using guessed type char *kMarkerType;
// 100015BD0: using guessed type char *supplyName[27];
// 100015C30: using guessed type char *supplyType[15];
// 100015CA8: using guessed type __int64 gStatus[];
// 100015CC0: using guessed type __int64 qword_100015CC0;
// 100015CC8: using guessed type __int64 qword_100015CC8;
// 100015CD0: using guessed type __int64 qword_100015CD0;
// 100015CD8: using guessed type __int64 qword_100015CD8;
// 100015CE0: using guessed type __int64 qword_100015CE0;
// 100015CE8: using guessed type __int64 qword_100015CE8;
// 100015CF0: using guessed type __int64 qword_100015CF0;
// 100015CF8: using guessed type __int64 qword_100015CF8;
// 100015D00: using guessed type __int64 qword_100015D00;
// 100015D08: using guessed type __int64 qword_100015D08;
// 100015D10: using guessed type __int64 qword_100015D10;
// 100015D18: using guessed type __int64 qword_100015D18;
// 100015D20: using guessed type __int64 qword_100015D20;
// 100015D28: using guessed type __int64 qword_100015D28;
// 100015D30: using guessed type __int64 qword_100015D30;
// 100015D38: using guessed type __int64 qword_100015D38;
// 100015D40: using guessed type int gLowLevel[];
// 100015D44: using guessed type int dword_100015D44;
// 100015D48: using guessed type int dword_100015D48;
// 100015D4C: using guessed type int dword_100015D4C;
// 100015D50: using guessed type int gModelInfo;
// 100015D54: using guessed type int dword_100015D54;
// 100016C30: using guessed type int gGetStatusMode;

//----- (0000000100005380) ----------------------------------------------------
__int64 getDeviceCharCode()
{
  int SideChannelSNMPData; // r14d
  char *v1; // rbx
  __int64 v3; // [rsp+0h] [rbp-30h] BYREF

  if ( gGetStatusMode == 2 )
  {
    SideChannelSNMPData = 0;
    if ( !gEncodingNum )
    {
      gEncodingNum = -1;
      return (unsigned int)-1;
    }
  }
  else
  {
    SideChannelSNMPData = -1;
    if ( gGetStatusMode == 1 )
    {
      SideChannelSNMPData = getSideChannelSNMPData(kCharCodeIndexID, 0.5);
      if ( SideChannelSNMPData < 0 )
      {
        fprintf(__stderrp, "%s getDeviceCharCode(): unknown device charcode\n", "DEBUG: ");
        gEncodingNum = -1;
      }
      else
      {
        v1 = (char *)&v3
           - (((unsigned int)strlen(kCharCodeID) + SideChannelSNMPData / 10 + 3 + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
        __sprintf_chk(v1, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", kCharCodeID, SideChannelSNMPData);
        if ( (unsigned int)getSideChannelSNMPData(v1, 0.5) == 106 )
        {
          gEncodingNum = 134217984;
          return 106;
        }
        else
        {
          SideChannelSNMPData = getSideChannelSNMPData(kLanguageID, 0.5);
          switch ( SideChannelSNMPData )
          {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
              gEncodingNum = 1280;
              break;
            case 12:
              gEncodingNum = 1284;
              SideChannelSNMPData = 12;
              break;
            case 13:
            case 16:
            case 17:
            case 18:
            case 20:
              gEncodingNum = 1281;
              break;
            case 14:
              gEncodingNum = 2561;
              SideChannelSNMPData = 14;
              break;
            case 15:
            case 19:
              gEncodingNum = 1282;
              break;
            default:
              gEncodingNum = -1;
              break;
          }
        }
      }
    }
  }
  return (unsigned int)SideChannelSNMPData;
}
// 100016C30: using guessed type int gGetStatusMode;

//----- (00000001000055A4) ----------------------------------------------------
int __fastcall showStatusMessage(__int64 a1)
{
  char *v1; // rbx
  FILE *v2; // rdi
  const char *v3; // rsi
  int result; // eax

  v1 = determineStatus(a1);
  v2 = __stderrp;
  v3 = "%s%s\n";
  if ( !v1 )
    return fprintf(v2, v3, "DEBUG: ");
  fprintf(__stderrp, "%s%s\n", "DEBUG: ", v1);
  result = isMessageAvailable(kGenericMsg);
  if ( (_BYTE)result )
  {
    if ( strcmp(v1, kTonerOutMsg) || (result = isMessageAvailable(v1), !(_BYTE)result) )
    {
      if ( !strcmp(v1, kGenericMsg) )
      {
        v2 = __stderrp;
      }
      else
      {
        getStatusMessageFromResource(v1);
        v2 = __stderrp;
        if ( qword_100015CB0 )
          return fprintf(__stderrp, "%sMessage=%s\n", "DEBUG: ");
      }
      v3 = "%sMessage=%s\n";
      return fprintf(v2, v3, "DEBUG: ");
    }
  }
  return result;
}
// 100015CB0: using guessed type __int64 qword_100015CB0;

//----- (000000010000566F) ----------------------------------------------------
CFDictionaryRef __fastcall copyPlistfromBundle(__CFBundle *a1, const __CFString *a2)
{
  CFPropertyListRef v2; // r14
  const __CFURL *v3; // rbx
  const __CFDictionary *InfoDictionary; // rax
  SInt32 errorCode; // [rsp+Ch] [rbp-24h] BYREF
  CFDataRef resourceData; // [rsp+10h] [rbp-20h] BYREF

  if ( a2 )
  {
    v2 = 0LL;
    v3 = CFBundleCopyResourceURL(a1, a2, CFSTR("plist"), 0LL);
    if ( v3 )
    {
      v2 = 0LL;
      resourceData = CFURLCreateData(kCFAllocatorDefault, v3, 0x8000100u, 0);
      if ( CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault, v3, &resourceData, 0LL, 0LL, &errorCode) == 1
        && !errorCode )
      {
        if ( resourceData )
        {
          v2 = CFPropertyListCreateFromXMLData(kCFAllocatorDefault, resourceData, 0LL, 0LL);
          CFRelease(resourceData);
        }
      }
      CFRelease(v3);
    }
    return (CFDictionaryRef)v2;
  }
  else
  {
    InfoDictionary = CFBundleGetInfoDictionary(a1);
    return CFDictionaryCreateCopy(kCFAllocatorDefault, InfoDictionary);
  }
}

//----- (0000000100005743) ----------------------------------------------------
const void *__fastcall getStatusValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value; // rbx
  const void *result; // rax
  CFTypeID v4; // r14
  CFTypeID v5; // r14
  CFTypeID TypeID; // rcx

  Value = CFDictionaryGetValue(a1, a2);
  result = 0LL;
  if ( Value )
  {
    v4 = CFGetTypeID(Value);
    if ( v4 != CFArrayGetTypeID() )
      goto LABEL_6;
    if ( CFArrayGetCount((CFArrayRef)Value) > gModelInfo )
      Value = CFArrayGetValueAtIndex((CFArrayRef)Value, gModelInfo);
    result = 0LL;
    if ( Value )
    {
LABEL_6:
      v5 = CFGetTypeID(Value);
      TypeID = CFStringGetTypeID();
      result = 0LL;
      if ( v5 == TypeID )
        return Value;
    }
  }
  return result;
}
// 100015D50: using guessed type int gModelInfo;

//----- (00000001000057B5) ----------------------------------------------------
__int64 determineModel()
{
  char *v0; // rax
  ppd_file_t *v1; // rax
  ppd_file_t *v2; // r14
  unsigned int v3; // ebx

  v0 = getenv("PPD");
  v1 = ppdOpenFile(v0);
  v2 = v1;
  v3 = -1;
  if ( v1 )
  {
    gModelInfo = 1 - ((v1->color_device == 0) - 1);
    dword_100015D54 = v1->model_number;
    v3 = ppdFindAttr(v1, "cupsCommands", 0LL) == 0LL ? -1 : 1;
    ppdClose(v2);
  }
  return v3;
}
// 100015D50: using guessed type int gModelInfo;
// 100015D54: using guessed type int dword_100015D54;

//----- (0000000100005823) ----------------------------------------------------
__int64 canBlackPrint()
{
  int v0; // ebx
  int SideChannelSNMPData; // eax
  FILE *v2; // rdi
  const char *v3; // rcx

  if ( gGetStatusMode != 2 )
  {
    SideChannelSNMPData = 0;
    if ( gGetStatusMode == 1 )
    {
      SideChannelSNMPData = getSideChannelSNMPData(kBlackPrintID, 5.0);
      qword_100015CB0 = 0LL;
      gStatus[0] = 0LL;
    }
LABEL_7:
    v0 = 0;
    if ( SideChannelSNMPData >= 0 )
      v0 = SideChannelSNMPData;
    if ( v0 )
    {
      if ( !isMessageAvailable(kBlackPrintMsg) )
        return (unsigned __int8)v0;
      fprintf(__stderrp, "%s\n", "INFO: ");
      v2 = __stderrp;
      v3 = kBlackPrintMsg;
    }
    else
    {
      if ( !isMessageAvailable(kNoBlackPrintMsg) )
        return (unsigned __int8)v0;
      v2 = __stderrp;
      v3 = kNoBlackPrintMsg;
    }
    fprintf(v2, "%s+%s\n", "STATE: ", v3);
    return (unsigned __int8)v0;
  }
  if ( !isCalledFromRasterFiler() )
  {
    setDeviceOff();
    printf("%s", "\x1B%-12345X@PJL\n");
    printf("%s", "@PJL INFO BLACKPRINT\n");
    printf("%s", "\x1B%-12345X");
    printf("%s", "\f");
    setDeviceOn();
    SideChannelSNMPData = getBackChannelData(5.0);
    goto LABEL_7;
  }
  LOBYTE(v0) = 0;
  return (unsigned __int8)v0;
}
// 100015CA8: using guessed type __int64 gStatus[];
// 100015CB0: using guessed type __int64 qword_100015CB0;
// 100016C30: using guessed type int gGetStatusMode;

//----- (0000000100005962) ----------------------------------------------------
_BOOL8 canPrintFromAnotherTray()
{
  return gModelInfo && isCalledFromRasterFiler();
}
// 100015D50: using guessed type int gModelInfo;

//----- (0000000100005982) ----------------------------------------------------
_BOOL8 isWirelessInterface()
{
  return gGetStatusMode != 2 && (unsigned int)getSideChannelSNMPData(kInterfaceID, 10.0) == 2;
}
// 100016C30: using guessed type int gGetStatusMode;

//----- (00000001000059B2) ----------------------------------------------------
__int64 isBRMaintenanceAvailable()
{
  __int64 result; // rax

  switch ( gModelInfo )
  {
    case 0:
      return dword_100015D54 > 13;
    case 1:
      LOBYTE(result) = dword_100015D54 > 7;
      return (unsigned __int8)result;
    case 2:
      LOBYTE(result) = dword_100015D54 > 4;
      return (unsigned __int8)result;
    case 3:
      LOBYTE(result) = 1;
      return (unsigned __int8)result;
    default:
      LOBYTE(result) = 0;
      return (unsigned __int8)result;
  }
}
// 100015D50: using guessed type int gModelInfo;
// 100015D54: using guessed type int dword_100015D54;

//----- (0000000100005A14) ----------------------------------------------------
__int64 isIPPPrinting()
{
  char *v0; // rbx
  __int64 result; // rax

  v0 = getenv("DEVICE_URI");
  LOBYTE(result) = !strncmp("ipp://", v0, 6uLL) || strstr(v0, "._ipp");
  return (unsigned __int8)result;
}

//----- (0000000100005A65) ----------------------------------------------------
_BOOL8 isCalledFromRasterFiler()
{
  __CFBundle *MainBundle; // rax
  const __CFString *Identifier; // rax

  MainBundle = CFBundleGetMainBundle();
  return MainBundle
      && (Identifier = CFBundleGetIdentifier(MainBundle)) != 0LL
      && CFStringFind(Identifier, CFSTR("raster"), 1uLL).location != -1;
}

//----- (0000000100005AA4) ----------------------------------------------------
CFBundleRef copyCommandFilterBundle()
{
  char *v0; // rax
  ppd_file_t *v1; // rax
  CFBundleRef v2; // rbx
  unsigned int num_filters; // r15d
  char **filters; // r13
  __int64 v5; // r12
  const char *v6; // rbx
  const __CFString *v7; // rax
  const __CFString *v8; // rbx
  CFIndex Length; // rax
  CFMutableStringRef MutableCopy; // r15
  CFIndex location; // rax
  CFIndex v12; // rbx
  CFIndex v13; // rax
  const __CFURL *v14; // rax
  const __CFURL *v15; // r12
  ppd_file_t *ppd; // [rsp+0h] [rbp-30h]

  v0 = getenv("PPD");
  v1 = ppdOpenFile(v0);
  v2 = 0LL;
  if ( v1 )
  {
    num_filters = v1->num_filters;
    ppd = v1;
    if ( !num_filters )
      goto LABEL_17;
    filters = v1->filters;
    v5 = 0LL;
    while ( 1 )
    {
      v6 = filters[v5];
      if ( v6 )
      {
        if ( strstr(filters[v5], "commandto") )
          break;
      }
      if ( (unsigned int)++v5 >= num_filters )
        goto LABEL_17;
    }
    v7 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x600u);
    v8 = v7;
    if ( v7 )
    {
      Length = CFStringGetLength(v7);
      MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, Length, v8);
      CFRelease(v8);
      location = CFStringFind(MutableCopy, CFSTR("/Library"), 0LL).location;
      if ( location > 0 )
        CFStringDelete(MutableCopy, (CFRange)__PAIR128__(location, 0LL));
      v12 = CFStringFind(MutableCopy, CFSTR("/Contents"), 0LL).location;
      if ( v12 != -1 )
      {
        v13 = CFStringGetLength(MutableCopy);
        CFStringDelete(MutableCopy, (CFRange)__PAIR128__(v13 - v12, v12));
      }
      ppdClose(ppd);
      v2 = 0LL;
      if ( MutableCopy )
      {
        v2 = 0LL;
        v14 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, MutableCopy, kCFURLPOSIXPathStyle, 1u);
        v15 = v14;
        if ( v14 )
        {
          v2 = CFBundleCreate(kCFAllocatorDefault, v14);
          CFRelease(v15);
        }
        CFRelease(MutableCopy);
      }
    }
    else
    {
LABEL_17:
      ppdClose(ppd);
      return 0LL;
    }
  }
  return v2;
}

//----- (0000000100005C27) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  cups_file_t *v3; // r15
  int v4; // ebx
  __int64 v5; // rax
  double v6; // xmm0_8
  int v7; // eax
  double v8; // xmm0_8
  int v9; // ecx
  int v10; // eax
  char *v11; // r14
  int linenum; // [rsp+4h] [rbp-43Ch] BYREF
  char *value; // [rsp+8h] [rbp-438h] BYREF
  char buf[1024]; // [rsp+10h] [rbp-430h] BYREF

  setupLanguage();
  signal(15, (void (__cdecl *)(int))cancelJob);
  gGetStatusMode = CheckBackChannel();
  if ( (argc & 0xFFFFFFFE) != 6 )
  {
    fprintf(__stderrp, "%s%s", "ERROR: ", "Need arguments: job-id user title copies options [file]\n");
    return 1;
  }
  if ( argc == 7 )
  {
    v3 = cupsFileOpen(argv[6], "r");
    if ( !v3 )
    {
      fprintf(__stderrp, "%s%s", "ERROR: ", "Unable to open command file\n");
      sleep(5u);
      return 1;
    }
  }
  else
  {
    v3 = cupsFileStdin();
  }
  linenum = 0;
  while ( cupsFileGetConf(v3, buf, 0x400uLL, &value, &linenum) )
  {
    if ( !strcasecmp(buf, "Clean") )
    {
      clean_print_head();
    }
    else if ( !strncasecmp(buf, "Print", 5uLL) )
    {
      print_self_test_page(buf);
    }
    else
    {
      if ( !strncasecmp(buf, "PJL", 3uLL) )
      {
        if ( gGetStatusMode == 2 )
          runPJLUtilityCommand(buf, value);
        continue;
      }
      if ( !strcasecmp(buf, "ReportLevels") )
      {
        fflush(__stdoutp);
        if ( gGetStatusMode == 2 )
        {
          if ( gModelInfo || (unsigned __int8)isBRMaintenanceAvailable() )
          {
            if ( (unsigned __int8)isBRMaintenanceAvailable() )
              setMaintenance(1);
            setDeviceOn();
            sleep(2u);
          }
          else
          {
            setDeviceOff();
            setDevice2Off();
            setDevice2On();
          }
        }
        if ( gModelInfo )
          v6 = 5.0;
        else
          v6 = 10.0;
        getDeviceSupplyLevels(v6);
        fprintf(__stderrp, "%s\n", "STATE: ");
        v7 = gModelInfo;
        if ( gGetStatusMode == 2 && !gModelInfo )
        {
          if ( !(unsigned __int8)isBRMaintenanceAvailable() )
          {
            setDevice2Off();
            setDeviceOn();
          }
          v7 = gModelInfo;
        }
        if ( v7 && !(unsigned __int8)isBRMaintenanceAvailable() )
        {
          v8 = 0.1;
LABEL_42:
          getDeviceStatus(v8);
        }
        else if ( !(unsigned __int8)isIPPPrinting() || !(unsigned __int8)isBRMaintenanceAvailable() )
        {
          v8 = 10.0;
          goto LABEL_42;
        }
        if ( gGetStatusMode == 2 )
        {
          if ( (unsigned __int8)isBRMaintenanceAvailable() )
            setMaintenance(0);
          setDeviceOff();
        }
        v9 = gModelInfo;
        v10 = *(&gModelInfo + 1);
        if ( gModelInfo == 2 && v10 >= 4 )
        {
          AutoCalibration(5.0);
          v9 = gModelInfo;
          v10 = *(&gModelInfo + 1);
        }
        if ( !v9 && v10 >= 15 )
          executeRetriveData(1);
        continue;
      }
      if ( !strcasecmp(buf, "StatusMessage") && value )
      {
        v5 = atol(value);
        showStatusMessage(v5);
      }
    }
  }
  v4 = 0;
  if ( gGetStatusMode == 1 )
  {
    v11 = getenv("DEVICE_URI");
    if ( !strncmp("ipp://", v11, 6uLL) || !strncmp("lpd://", v11, 6uLL) || strstr(v11, "._ipp") )
      dummyPrint();
  }
  return v4;
}
// 100015D50: using guessed type int gModelInfo;
// 100016C30: using guessed type int gGetStatusMode;

//----- (000000010000604B) ----------------------------------------------------
void __fastcall cancelJob()
{
  int v0; // ecx

  gStatus[0] = 10001LL;
  v0 = gGetStatusMode;
  gGetStatusMode = 0;
  if ( v0 == 2 )
    setDeviceOff();
  fprintf(__stderrp, "%s\n", "STATE: ");
}
// 100015CA8: using guessed type __int64 gStatus[];
// 100016C30: using guessed type int gGetStatusMode;

//----- (0000000100006098) ----------------------------------------------------
int dummyPrint()
{
  printf("%s", "\x1B%-12345X@PJL\n");
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}

//----- (00000001000060DC) ----------------------------------------------------
int startDeviceStatusTimer()
{
  itimerval v1; // [rsp+0h] [rbp-20h] BYREF

  v1.it_interval.tv_sec = 30LL;
  v1.it_interval.tv_usec = 0;
  v1.it_value.tv_sec = 3LL;
  v1.it_value.tv_usec = 0;
  return setitimer(0, &v1, 0LL);
}

//----- (0000000100006115) ----------------------------------------------------
int resetDeviceStatusTimer()
{
  itimerval v1; // [rsp+0h] [rbp-20h] BYREF

  v1.it_interval.tv_sec = 0LL;
  v1.it_interval.tv_usec = 0;
  v1.it_value.tv_sec = 0LL;
  v1.it_value.tv_usec = 0;
  return setitimer(0, &v1, 0LL);
}

//----- (000000010000614E) ----------------------------------------------------
int __fastcall getDeviceStatusAlarm(int a1)
{
  int result; // eax
  itimerval v2; // [rsp+8h] [rbp-28h] BYREF

  if ( a1 == 14 )
  {
    v2.it_value.tv_sec = 0LL;
    v2.it_value.tv_usec = 0;
    v2.it_interval.tv_sec = 0LL;
    v2.it_interval.tv_usec = 0;
    setitimer(0, &v2, 0LL);
    fflush(__stdoutp);
    getDeviceStatus(0.0);
    v2.it_value.tv_sec = 30LL;
    v2.it_value.tv_usec = 0;
    v2.it_interval.tv_sec = 3LL;
    v2.it_interval.tv_usec = 0;
    return setitimer(0, &v2, 0LL);
  }
  return result;
}

//----- (00000001000061D2) ----------------------------------------------------
int __fastcall print_self_test_page(char *a1)
{
  __int64 v1; // rbx

  if ( gGetStatusMode == 2 )
  {
    setDeviceOn();
    getDeviceStatus(5.0);
    setDeviceOff();
  }
  else
  {
    getDeviceStatus(5.0);
  }
  v1 = 4096LL;
  if ( gModelInfo == 3 && *(&gModelInfo + 1) < 2 )
    goto LABEL_8;
  do
  {
    putchar(0);
    --v1;
  }
  while ( v1 );
  if ( gModelInfo )
LABEL_8:
    printf("%s", "\x1B%-12345X@PJL\n");
  else
    printf("%s", "\x1B%-12345X");
  if ( !strcasecmp(a1, "PrintSelfTestPage") )
  {
    if ( gModelInfo && gModelInfo != 3 )
      printf("%s", "@PJL EXECUTE TESTPRINT\r\n");
    else
      printf("%s", "@PJL EXECUTE PINCHKPRINT\r\n");
  }
  else if ( !strcasecmp(a1, "PrintResiFontPage") )
  {
    printf("%s", "@PJL EXECUTE RESIFONT\r\n");
  }
  else if ( !strcasecmp(a1, "PrintPrefFontPage") )
  {
    printf("%s", "@PJL EXECUTE PERMFONT\r\n");
  }
  else if ( !strcasecmp(a1, "PrintConfigPage") )
  {
    printf("%s", "@PJL EXECUTE PRTCONFIG\r\n");
  }
  printf("%s", "\x1B%-12345X");
  return fprintf(__stderrp, "%s1 1\n", "PAGE: ");
}
// 100015D50: using guessed type int gModelInfo;
// 100016C30: using guessed type int gGetStatusMode;

//----- (0000000100006350) ----------------------------------------------------
int sendNULLData()
{
  __int64 v0; // rbx
  int result; // eax

  v0 = 4096LL;
  do
  {
    result = putchar(0);
    --v0;
  }
  while ( v0 );
  return result;
}

//----- (000000010000636E) ----------------------------------------------------
int clean_print_head()
{
  __int64 v0; // rbx

  if ( gGetStatusMode == 2 )
  {
    setDeviceOn();
    getDeviceStatus(5.0);
    setDeviceOff();
  }
  else
  {
    getDeviceStatus(5.0);
  }
  v0 = 4096LL;
  if ( gModelInfo == 3 && *(&gModelInfo + 1) < 2 )
    goto LABEL_8;
  do
  {
    putchar(0);
    --v0;
  }
  while ( v0 );
  if ( gModelInfo )
LABEL_8:
    printf("%s", "\x1B%-12345X@PJL\n");
  else
    printf("%s", "\x1B%-12345X");
  if ( gModelInfo == 3 )
    printf("%s", "@PJL EXECUTE NORMALPURGE\r\n");
  else
    printf("%s", "@PJL EXECUTE NORMALPURGE=ALL\r\n");
  return printf("%s", "\x1B%-12345X");
}
// 100015D50: using guessed type int gModelInfo;
// 100016C30: using guessed type int gGetStatusMode;

//----- (000000010000643F) ----------------------------------------------------
void __fastcall setupLanguage()
{
  void *v0; // rax
  char *v1; // rax
  CFArrayRef v2; // rbx
  void *values; // [rsp+0h] [rbp-10h] BYREF

  values = v0;
  v1 = getenv("APPLE_LANGUAGE");
  if ( v1 || (v1 = getenv("LANG")) != 0LL )
  {
    values = (void *)CFStringCreateWithCString(kCFAllocatorDefault, v1, 0x8000100u);
    if ( values )
    {
      v2 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
      if ( v2 )
      {
        CFPreferencesSetAppValue(CFSTR("AppleLanguages"), v2, kCFPreferencesCurrentApplication);
        setlocale(6, "");
        CFRelease(v2);
      }
      CFRelease(values);
    }
  }
}
// 100006444: variable 'v0' is possibly undefined

//----- (00000001000064EC) ----------------------------------------------------
char *__fastcall BRLocalizedString(char *cStr)
{
  char *v1; // rbx
  const __CFString *v2; // r15
  __CFBundle *MainBundle; // rax
  const __CFString *v4; // rax
  const __CFString *v5; // r12

  __bzero(BRLocalizedString_buf, 512LL);
  v1 = 0LL;
  if ( cStr )
  {
    v2 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
    MainBundle = CFBundleGetMainBundle();
    v1 = 0LL;
    v4 = CFBundleCopyLocalizedString(MainBundle, v2, v2, 0LL);
    v5 = v4;
    if ( v4 )
    {
      v1 = 0LL;
      if ( CFStringGetCString(v4, BRLocalizedString_buf, 512LL, 0x8000100u) )
        v1 = BRLocalizedString_buf;
      CFRelease(v5);
    }
    CFRelease(v2);
  }
  return v1;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (0000000100006587) ----------------------------------------------------
int __fastcall BRPrintInfoMessage(char *a1)
{
  char *v1; // rax

  v1 = BRLocalizedString(a1);
  if ( v1 )
    LODWORD(v1) = fprintf(__stderrp, "%s%s\n", "INFO: ", v1);
  return (int)v1;
}

//----- (00000001000065BA) ----------------------------------------------------
int __fastcall BRPrintErrorMessage(char *a1)
{
  char *v1; // rax

  v1 = BRLocalizedString(a1);
  if ( v1 )
    LODWORD(v1) = fprintf(__stderrp, "%s%s\n", "ERROR: ", v1);
  return (int)v1;
}

//----- (00000001000065ED) ----------------------------------------------------
__int64 __fastcall AutoCalibration(double a1)
{
  char *v1; // r15
  char *v2; // rax
  const char *v3; // rbx
  int BackChannelLUTData; // r14d
  __int128 v6; // [rsp+10h] [rbp-40h] BYREF

  v1 = getenv("PRINTER");
  v2 = getenv("PPD");
  v3 = v2;
  BackChannelLUTData = 0;
  if ( v1 && v2 && BRCalibrationNeedAutoCalibration(&gModelInfo, v1, v2) )
  {
    gCalib600DPI[22] = 0;
    *(_QWORD *)&gCalib600DPI[20] = 0LL;
    *(_QWORD *)&gCalib600DPI[18] = 0LL;
    *(_QWORD *)&gCalib600DPI[16] = 0LL;
    *(_QWORD *)&gCalib600DPI[14] = 0LL;
    *(_QWORD *)&gCalib600DPI[12] = 0LL;
    *(_QWORD *)&gCalib600DPI[10] = 0LL;
    *(_QWORD *)&gCalib600DPI[8] = 0LL;
    *(_QWORD *)&gCalib600DPI[6] = 0LL;
    *(_QWORD *)&gCalib600DPI[4] = 0LL;
    *(_QWORD *)&gCalib600DPI[2] = 0LL;
    *(_QWORD *)gCalib600DPI = 0LL;
    gCalibCAPT[22] = 0;
    *(_QWORD *)&gCalibCAPT[20] = 0LL;
    *(_QWORD *)&gCalibCAPT[18] = 0LL;
    *(_QWORD *)&gCalibCAPT[16] = 0LL;
    *(_QWORD *)&gCalibCAPT[14] = 0LL;
    *(_QWORD *)&gCalibCAPT[12] = 0LL;
    *(_QWORD *)&gCalibCAPT[10] = 0LL;
    *(_QWORD *)&gCalibCAPT[8] = 0LL;
    *(_QWORD *)&gCalibCAPT[6] = 0LL;
    *(_QWORD *)&gCalibCAPT[4] = 0LL;
    *(_QWORD *)&gCalibCAPT[2] = 0LL;
    *(_QWORD *)gCalibCAPT = 0xFFFFFFFFLL;
    gCalib600DPI[0] = -1;
    if ( gGetStatusMode == 2 )
    {
      if ( !gStatus[0] || gStatus[0] == 10001 )
        getBackChannelData(0.0);
      infoLUT();
      sleep(2u);
      BackChannelLUTData = getBackChannelLUTData(a1);
    }
    else
    {
      BackChannelLUTData = 0;
      if ( gGetStatusMode == 1 )
        BackChannelLUTData = cupsSideChannelSNMPWalk(
                               kCommandOIDLUTParentChar[0],
                               a1,
                               (cups_sc_walk_func_t)WalkCallback,
                               0LL) == CUPS_SC_STATUS_OK;
    }
    if ( BackChannelLUTData > 0 && !gCalib600DPI[0] && gCalibCAPT[0] == 1 )
    {
      v6 = *(_OWORD *)off_1000144C0;
      return (unsigned int)BRCalibrationAutoCalibration((int **)&v6, 2, &gModelInfo, v1, v3);
    }
  }
  return (unsigned int)BackChannelLUTData;
}
// 1000144C0: using guessed type int (*off_1000144C0[2])[23];
// 100015CA8: using guessed type __int64 gStatus[];
// 100015D50: using guessed type int gModelInfo;
// 1000166C8: using guessed type char *kCommandOIDLUTParentChar[9];
// 100016C30: using guessed type int gGetStatusMode;
// 100016C38: using guessed type _DWORD gCalib600DPI[23];
// 100016C94: using guessed type _DWORD gCalibCAPT[23];

//----- (000000010000683D) ----------------------------------------------------
void __fastcall WalkCallback(const char *a1, const char *a2, int a3, void *a4)
{
  size_t v5; // rax
  size_t v6; // rax
  size_t v7; // rax
  size_t v8; // rax
  size_t v9; // rax
  size_t v10; // rax
  size_t v11; // rax
  size_t v12; // rax
  char *v13; // r12

  if ( a2 )
  {
    v5 = strlen(kCommandOIDFCyanLUTChar[0]);
    if ( !strncmp(a1, kCommandOIDFCyanLUTChar[0], v5) )
    {
      v13 = (char *)&gCalib600DPI + 4;
    }
    else
    {
      v6 = strlen(kCommandOIDFMagentaLUTChar[0]);
      if ( !strncmp(a1, kCommandOIDFMagentaLUTChar[0], v6) )
      {
        v13 = (char *)&gCalib600DPI + 26;
      }
      else
      {
        v7 = strlen(kCommandOIDFYellowLUTChar[0]);
        if ( !strncmp(a1, kCommandOIDFYellowLUTChar[0], v7) )
        {
          v13 = (char *)&gCalib600DPI + 48;
        }
        else
        {
          v8 = strlen(kCommandOIDFBlackLUTChar[0]);
          if ( !strncmp(a1, kCommandOIDFBlackLUTChar[0], v8) )
          {
            gCalib600DPI = 0;
            v13 = (char *)&gCalib600DPI + 70;
          }
          else
          {
            v9 = strlen(kCommandOIDSFCyanLUTChar[0]);
            if ( !strncmp(a1, kCommandOIDSFCyanLUTChar[0], v9) )
            {
              v13 = (char *)&gCalibCAPT + 4;
            }
            else
            {
              v10 = strlen(kCommandOIDSFMagentaLUTChar[0]);
              if ( !strncmp(a1, kCommandOIDSFMagentaLUTChar[0], v10) )
              {
                v13 = (char *)&gCalibCAPT + 26;
              }
              else
              {
                v11 = strlen(kCommandOIDSFYeloowLUTChar[0]);
                if ( !strncmp(a1, kCommandOIDSFYeloowLUTChar[0], v11) )
                {
                  v13 = (char *)&gCalibCAPT + 48;
                }
                else
                {
                  v12 = strlen(kCommandOIDSFBlackLUTChar);
                  if ( strncmp(a1, kCommandOIDSFBlackLUTChar, v12) )
                    return;
                  gCalibCAPT = 1;
                  v13 = (char *)&gCalibCAPT + 70;
                }
              }
            }
          }
        }
      }
    }
    if ( (unsigned int)copyCalibDataArray((__int64)v13, a2, a3) )
    {
      gCalib600DPI = -1;
      gCalibCAPT = -1;
    }
  }
}
// 1000166D0: using guessed type char *kCommandOIDFCyanLUTChar[8];
// 1000166D8: using guessed type char *kCommandOIDFMagentaLUTChar[7];
// 1000166E0: using guessed type char *kCommandOIDFYellowLUTChar[6];
// 1000166E8: using guessed type char *kCommandOIDFBlackLUTChar[5];
// 1000166F0: using guessed type char *kCommandOIDSFCyanLUTChar[4];
// 1000166F8: using guessed type char *kCommandOIDSFMagentaLUTChar[3];
// 100016700: using guessed type char *kCommandOIDSFYeloowLUTChar[2];
// 100016708: using guessed type char *kCommandOIDSFBlackLUTChar;

//----- (0000000100006A4C) ----------------------------------------------------
__int64 __fastcall getBackChannelLUTData(double a1)
{
  int v1; // eax
  int v2; // ebx
  char *v3; // r13
  __int64 v4; // r15
  __int128 v5; // xmm0
  __int64 v6; // rax
  char v7; // cl
  size_t v8; // r12
  int v9; // ecx
  __int64 result; // rax
  char *v11; // rax
  char *v12; // rax
  char *v13; // rax
  int v14; // eax
  char buffer[1024]; // [rsp+20h] [rbp-430h] BYREF

  __bzero(buffer, 1024LL);
  v1 = cupsBackChannelRead(buffer, 0x3FFuLL, a1);
  v2 = v1;
  if ( v1 > 0 )
  {
    buffer[v1] = 0;
    v3 = 0LL;
    LODWORD(v4) = 0;
    v5 = 0LL;
    do
    {
      xmmword_1000175A0 = v5;
      xmmword_100017590 = v5;
      xmmword_100017580 = v5;
      *(_OWORD *)getBackChannelLUTData_tmp = v5;
      v14 = (unsigned __int8)buffer[(int)v4];
      if ( v14 == 10 || (unsigned __int8)v14 == 13 )
      {
        LODWORD(v4) = v4 + 1;
        continue;
      }
      v6 = 0LL;
LABEL_4:
      v4 = (int)v4;
LABEL_6:
      v7 = buffer[v4];
      while ( v7 != 10 && v7 != 13 )
      {
        if ( (int)v4 >= v2 )
          goto LABEL_41;
        if ( v7 == 12 || v7 == 34 )
        {
          ++v4;
          goto LABEL_6;
        }
        if ( (unsigned int)v6 <= 0x3F )
        {
          LODWORD(v4) = v4 + 1;
          getBackChannelLUTData_tmp[v6++] = v7;
          goto LABEL_4;
        }
      }
      if ( (int)v4 >= v2 )
        continue;
      v8 = strlen(getBackChannelLUTData_tmp);
      if ( !strncmp(getBackChannelLUTData_tmp, "@PJL INQUIRE FCYANLUT\r\n", v8) )
      {
        v3 = (char *)&gCalib600DPI[1];
        v5 = 0LL;
      }
      else
      {
        if ( !strncmp(getBackChannelLUTData_tmp, "@PJL INQUIRE FMAGENTALUT\r\n", v8) )
        {
          v11 = (char *)gCalib600DPI;
        }
        else
        {
          if ( !strncmp(getBackChannelLUTData_tmp, "@PJL INQUIRE FYELLOWLUT\r\n", v8) )
          {
            v12 = (char *)gCalib600DPI;
LABEL_30:
            v3 = v12 + 48;
            v5 = 0LL;
            continue;
          }
          if ( !strncmp(getBackChannelLUTData_tmp, "@PJL INQUIRE FBLACKLUT\r\n", v8) )
          {
            v13 = (char *)gCalib600DPI;
            gCalib600DPI[0] = 0;
LABEL_32:
            v3 = v13 + 70;
            v5 = 0LL;
            continue;
          }
          if ( !strncmp(getBackChannelLUTData_tmp, "@PJL INQUIRE SFCYANLUT\r\n", v8) )
          {
            v3 = (char *)&gCalibCAPT[1];
            v5 = 0LL;
            continue;
          }
          if ( strncmp(getBackChannelLUTData_tmp, "@PJL INQUIRE SFMAGENTALUT\r\n", v8) )
          {
            if ( strncmp(getBackChannelLUTData_tmp, "@PJL INQUIRE SFYELLOWLUT\r\n", v8) )
            {
              if ( strncmp(getBackChannelLUTData_tmp, "@PJL INQUIRE SFBLACKLUT\r\n", v8) )
              {
                if ( v3 )
                {
                  v9 = copyCalibDataArray((__int64)v3, getBackChannelLUTData_tmp, v8);
                  result = 0xFFFFFFFFLL;
                  v3 = 0LL;
                  v5 = 0LL;
                  if ( v9 )
                    return result;
                }
                else
                {
                  v3 = 0LL;
                  v5 = 0LL;
                }
                continue;
              }
              v13 = (char *)gCalibCAPT;
              gCalibCAPT[0] = 1;
              goto LABEL_32;
            }
            v12 = (char *)gCalibCAPT;
            goto LABEL_30;
          }
          v11 = (char *)gCalibCAPT;
        }
        v3 = v11 + 26;
        v5 = 0LL;
      }
LABEL_41:
      ;
    }
    while ( (int)v4 < v2 );
  }
  return (unsigned int)v2;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);
// 100016C38: using guessed type _DWORD gCalib600DPI[23];
// 100016C94: using guessed type _DWORD gCalibCAPT[23];
// 100017580: using guessed type __int128 xmmword_100017580;
// 100017590: using guessed type __int128 xmmword_100017590;
// 1000175A0: using guessed type __int128 xmmword_1000175A0;

//----- (0000000100006D35) ----------------------------------------------------
int infoLUT()
{
  __int64 i; // rbx

  printf("%s", "\x1B%-12345X@PJL\r\n");
  for ( i = 0LL; i != 8; ++i )
    printf("%s", off_1000144D0[i]);
  printf("%s", "\x1B%-12345X");
  return fflush(__stdoutp);
}
// 1000144D0: using guessed type char *off_1000144D0[8];

//----- (0000000100006DA6) ----------------------------------------------------
__int64 __fastcall copyCalibDataArray(__int64 a1, const char *a2, int a3)
{
  __int64 v3; // rax
  const char *v4; // r14
  __int64 v5; // r13
  __int64 v6; // rax
  int i; // r12d
  unsigned int v8; // ebx
  _QWORD v10[6]; // [rsp+0h] [rbp-30h] BYREF

  v10[0] = v3;
  v4 = a2;
  v5 = a1;
  v6 = 0LL;
  if ( a3 == 22 )
  {
    v10[0] = v10;
    BYTE2(v10[-2]) = 0;
    LOWORD(v10[-2]) = 0;
    for ( i = 0; i <= 10; ++i )
    {
      strncpy((char *)&v10[-2], v4, 2uLL);
      v8 = -1;
      if ( strlen((const char *)&v10[-2]) != 2 )
        break;
      if ( !sscanf((const char *)&v10[-2], "%hx", v5) )
        break;
      v5 += 2LL;
      v4 += 2;
      v8 = 0;
    }
  }
  else
  {
    v8 = -1;
    if ( a3 == 11 )
    {
      do
      {
        *(_WORD *)(a1 + 2 * v6) = (unsigned __int8)a2[v6];
        ++v6;
        v8 = 0;
      }
      while ( v6 != 11 );
    }
  }
  return v8;
}
// 100006DB3: variable 'v3' is possibly undefined

//----- (0000000100006E61) ----------------------------------------------------
double __fastcall getTimeout(char *__src)
{
  __int64 v1; // rax
  char *v2; // rbx
  char *v3; // rax
  char *v4; // rax
  __int64 v6; // [rsp+0h] [rbp-20h] BYREF

  v6 = v1;
  v2 = (char *)&v6 - ((strlen(__src) + 16) & 0xFFFFFFFFFFFFFFF0LL);
  strcpy(v2, __src);
  v3 = strstr(v2, "-TimeOut=\"");
  if ( !v3 )
    return -1.0;
  strtok(v3, "\"");
  v4 = strtok(0LL, "\"");
  return atof(v4);
}
// 100006E6A: variable 'v1' is possibly undefined

//----- (0000000100006EF5) ----------------------------------------------------
char *__fastcall copyPJLCommand(char *__s)
{
  char *v1; // rbx
  char *v2; // rax
  char *v3; // rbx
  char *v4; // r15
  size_t v5; // rax
  __int64 v7; // [rsp+0h] [rbp-30h] BYREF

  v1 = (char *)&v7 - ((strlen(__s) + 16) & 0xFFFFFFFFFFFFFFF0LL);
  strcpy(v1, __s);
  v2 = strstr(v1, "-PJLCommand=\"");
  v3 = 0LL;
  if ( v2 )
  {
    strtok(v2, "\"");
    v3 = 0LL;
    v4 = strtok(0LL, "\"");
    if ( v4 )
    {
      v5 = strlen(__s);
      v3 = (char *)malloc(v5 + 1);
      strcpy(v3, v4);
    }
  }
  return v3;
}

//----- (0000000100006FAD) ----------------------------------------------------
char *__fastcall copySerchCommand(char *a1)
{
  char *v1; // rax
  char *v2; // r14
  char *v3; // rbx
  const char *v4; // r15
  size_t v5; // rax

  v1 = copyPJLCommand(a1);
  v2 = v1;
  v3 = 0LL;
  if ( v1 )
  {
    if ( !strcmp(v1, "@PJL SET NOTIFYBRMAINTENANCE=ON") )
    {
      v4 = "@PJL INFO BRMAINTENANCE";
    }
    else if ( !strcmp(v2, "@PJL USTATUS DEVICE=ON") )
    {
      v4 = "@PJL USTATUS DEVICE";
    }
    else if ( !strcmp(v2, "@PJL USTATUS DEVICE2=ON") )
    {
      v4 = "@PJL USTATUS DEVICE2";
    }
    else
    {
      v4 = v2;
      if ( !strcmp(v2, "@PJL SET NOTIFYBRDEVSTATUS=ON") )
        v4 = "@PJL INFO BRDEVSTATUS";
    }
    v5 = strlen(v4);
    v3 = (char *)malloc(v5 + 1);
    strcpy(v3, v4);
    free(v2);
  }
  return v3;
}

//----- (0000000100007072) ----------------------------------------------------
char *__fastcall copyOutputPath(char *__s)
{
  char *v1; // rbx
  char *v2; // rax
  char *v3; // rbx
  char *v4; // r15
  size_t v5; // rax
  __int64 v7; // [rsp+0h] [rbp-30h] BYREF

  v1 = (char *)&v7 - ((strlen(__s) + 16) & 0xFFFFFFFFFFFFFFF0LL);
  strcpy(v1, __s);
  v2 = strstr(v1, "-OutputPath=\"");
  v3 = 0LL;
  if ( v2 )
  {
    strtok(v2, "\"");
    v3 = 0LL;
    v4 = strtok(0LL, "\"");
    if ( v4 )
    {
      v5 = strlen(__s);
      v3 = (char *)malloc(v5 + 1);
      strcpy(v3, v4);
    }
  }
  return v3;
}

//----- (000000010000712A) ----------------------------------------------------
int __fastcall changePermissions(char *a1)
{
  if ( a1 && !access(a1, 0x100000) )
    return chmod(a1, 0x1FFu);
  else
    return 1;
}

//----- (0000000100007168) ----------------------------------------------------
__int64 __fastcall createCachesDirectory(char *a1)
{
  unsigned int v1; // ebx
  size_t v2; // rax
  const __CFURL *v3; // rax
  const __CFURL *v4; // r14
  const __CFURL *PathComponent; // rax
  const __CFURL *v6; // r15
  const __CFString *v7; // rax
  const __CFString *v9; // [rsp+8h] [rbp-438h]
  char __s[1024]; // [rsp+10h] [rbp-430h] BYREF

  v1 = 1;
  if ( a1 )
  {
    v1 = 0;
    if ( access(a1, 0) )
    {
      v2 = strlen(a1);
      v1 = 1;
      v3 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, (const UInt8 *)a1, v2, 1u);
      v4 = v3;
      if ( v3 )
      {
        PathComponent = CFURLCreateCopyDeletingLastPathComponent(kCFAllocatorDefault, v3);
        v6 = PathComponent;
        v1 = 1;
        if ( PathComponent )
        {
          v7 = CFURLCopyPath(PathComponent);
          v1 = 1;
          if ( v7 )
          {
            v9 = v7;
            CFStringGetCString(v7, __s, 1024LL, 0x8000100u);
            if ( !access(__s, 0) || (v1 = 1, !(unsigned int)createCachesDirectory(__s, 0LL)) )
            {
              v1 = 1;
              if ( !mkdir(a1, 0x1FFu) )
              {
                changePermissions(a1);
                v1 = 0;
              }
            }
            CFRelease(v9);
          }
          CFRelease(v6);
        }
        CFRelease(v4);
      }
    }
  }
  return v1;
}

//----- (00000001000072B5) ----------------------------------------------------
__int64 __fastcall makeFolderAndFile(const void *a1, int a2, const char *a3)
{
  size_t v4; // rax
  unsigned int v5; // r12d
  const __CFURL *v6; // rax
  const __CFURL *v7; // r13
  const __CFURL *PathComponent; // rax
  const __CFURL *v9; // r14
  const __CFString *v10; // rax
  const __CFString *v11; // r15
  bool v12; // bl
  FILE *v13; // r14
  int v14; // ebx
  char buffer[1024]; // [rsp+20h] [rbp-430h] BYREF

  v4 = strlen(a3);
  v5 = 1;
  v6 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, (const UInt8 *)a3, v4, 1u);
  v7 = v6;
  if ( v6 )
  {
    PathComponent = CFURLCreateCopyDeletingLastPathComponent(kCFAllocatorDefault, v6);
    v9 = PathComponent;
    if ( PathComponent )
    {
      v10 = CFURLCopyPath(PathComponent);
      v11 = v10;
      v5 = 1;
      if ( v10 )
      {
        CFStringGetCString(v10, buffer, 1024LL, 0x8000100u);
        v12 = (unsigned int)createCachesDirectory(buffer) != 0;
        CFRelease(v11);
        v5 = 3 * v12;
      }
      CFRelease(v9);
      CFRelease(v7);
      if ( !v5 )
      {
        v13 = fopen(a3, "w");
        v5 = 4;
        if ( v13 )
        {
          if ( a2 <= 0 || (v14 = fwrite(a1, 1uLL, a2 - 1, v13), fclose(v13), v5 = 5, v14 >= 0) )
          {
            v5 = 6;
            if ( !chmod(a3, 0x1FFu) )
              return 0;
          }
        }
      }
    }
    else
    {
      CFRelease(v7);
      return 2;
    }
  }
  return v5;
}

//----- (0000000100007458) ----------------------------------------------------
__int64 __fastcall saveFileWithData(CFDataRef theData, char *__filename)
{
  unsigned int v2; // r13d
  const UInt8 *BytePtr; // r14
  CFIndex Length; // rax
  __int64 v5; // r15
  FILE *v6; // r12
  __int64 v7; // rbx

  v2 = 1;
  if ( theData )
  {
    if ( __filename )
    {
      BytePtr = CFDataGetBytePtr(theData);
      Length = CFDataGetLength(theData);
      v5 = Length;
      if ( BytePtr )
      {
        if ( Length )
        {
          v6 = fopen(__filename, "w");
          if ( v6 )
          {
            if ( v5 <= 0 )
            {
LABEL_10:
              v2 = 0;
            }
            else
            {
              v7 = 0LL;
              while ( 1 )
              {
                v2 = 1;
                if ( putc(BytePtr[v7], v6) == -1 )
                  break;
                if ( ++v7 >= v5 )
                  goto LABEL_10;
              }
            }
            fclose(v6);
          }
        }
      }
    }
  }
  return v2;
}

//----- (00000001000074F7) ----------------------------------------------------
__int64 __fastcall runPJLWriteCommand(char *a1)
{
  char *v1; // rbx
  __int64 result; // rax

  v1 = copyPJLCommand(a1);
  result = 1LL;
  if ( v1 )
  {
    sendPJLCommand(v1);
    free(v1);
    return 0LL;
  }
  return result;
}

//----- (0000000100007528) ----------------------------------------------------
__int64 deleteTrashData()
{
  __int64 result; // rax
  int v1; // [rsp+Ch] [rbp-824h] BYREF
  _BYTE __dst[2048]; // [rsp+10h] [rbp-820h] BYREF

  do
  {
    v1 = 2048;
    result = getBackChannelRowData(__dst, &v1, 0.1);
  }
  while ( !(_DWORD)result && v1 );
  return result;
}

//----- (0000000100007598) ----------------------------------------------------
__int64 __fastcall runPJLReadCommand(char *__s)
{
  char *v1; // r13
  char *v2; // r15
  unsigned int FolderAndFile; // r14d
  __darwin_suseconds_t tv_usec; // [rsp+4h] [rbp-87Ch]
  int tv_sec; // [rsp+8h] [rbp-878h]
  double Timeout; // [rsp+18h] [rbp-868h]
  double v8; // [rsp+20h] [rbp-860h]
  timeval v9; // [rsp+28h] [rbp-858h] BYREF
  timeval v10; // [rsp+38h] [rbp-848h] BYREF
  int v11; // [rsp+4Ch] [rbp-834h] BYREF
  char __big[2048]; // [rsp+50h] [rbp-830h] BYREF

  Timeout = getTimeout(__s);
  v1 = copyOutputPath(__s);
  v2 = copySerchCommand(__s);
  FolderAndFile = 1;
  if ( Timeout >= 0.0 )
  {
    if ( v1 )
    {
      FolderAndFile = gettimeofday(&v10, 0LL);
      if ( !FolderAndFile )
      {
        tv_sec = v10.tv_sec;
        tv_usec = v10.tv_usec;
        v8 = Timeout;
        FolderAndFile = 1;
        while ( 1 )
        {
          v11 = 2048;
          if ( !(unsigned int)getBackChannelRowData(__big, &v11, v8) && (!v2 || strstr(__big, v2)) )
            break;
          if ( !gettimeofday(&v9, 0LL) )
          {
            v8 = Timeout - ((double)(v9.tv_usec - tv_usec) / 1000000.0 + (double)(LODWORD(v9.tv_sec) - tv_sec));
            if ( v8 <= 0.0 )
              goto LABEL_12;
          }
        }
        FolderAndFile = makeFolderAndFile(__big, v11, v1);
      }
    }
  }
LABEL_12:
  if ( v1 )
    free(v1);
  if ( v2 )
    free(v2);
  return FolderAndFile;
}

//----- (000000010000776C) ----------------------------------------------------
void __fastcall runPJLUtilityCommand(char *a1, char *__s)
{
  int v2; // eax

  if ( __s && a1 )
  {
    if ( !strncasecmp(a1, "PJLBidirectional", 0x10uLL) )
    {
      if ( (unsigned int)deleteTrashData() )
        return;
      v2 = runPJLWriteCommand(__s);
    }
    else
    {
      if ( !strncasecmp(a1, "PJLWrite", 8uLL) )
      {
        runPJLWriteCommand(__s);
        return;
      }
      v2 = strncasecmp(a1, "PJLRead", 7uLL);
    }
    if ( !v2 )
      runPJLReadCommand(__s);
  }
}

//----- (00000001000077FB) ----------------------------------------------------
void __fastcall runRetriveDataCommand(__int64 a1, char *a2)
{
  char *v2; // rbx
  int v3; // eax
  char v4[24]; // [rsp+8h] [rbp-18h] BYREF

  v2 = copyOutputPath(a2);
  if ( v2 )
  {
    *(_QWORD *)v4 = 0LL;
    v3 = executeRetriveData(0);
    __sprintf_chk(v4, 0, 8uLL, "%d", v3);
    makeFolderAndFile(v4, 8, v2);
    free(v2);
  }
}

//----- (0000000100007868) ----------------------------------------------------
__int64 __fastcall BrMakeGammaTable4150(
        unsigned __int16 *a1,
        __int16 *a2,
        __int64 a3,
        char a4,
        int a5,
        unsigned __int8 a6,
        double a7,
        __m128d a8,
        unsigned __int8 a9,
        unsigned __int8 a10)
{
  unsigned __int8 v14; // si
  unsigned __int8 v15; // r8
  int v16; // eax
  __int16 v17; // cx
  __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int16 v20; // cx
  __int64 v21; // rax
  float v22; // xmm2_4
  __int64 i; // rax
  float v24; // xmm2_4
  __int64 j; // rax
  unsigned __int16 v26; // ax
  float v27; // xmm2_4
  float v28; // xmm3_4
  unsigned __int16 v29; // ax
  unsigned __int16 v30; // di
  unsigned __int16 v31; // bx
  float v32; // xmm4_4
  __int64 k; // rcx
  __int64 v34; // rax
  __int16 v35; // di
  char *v36; // r11
  unsigned __int8 v37; // r12
  __int64 v38; // rdi
  __int16 *v39; // r13
  __int64 m; // rcx
  int v41; // ebx
  unsigned int v42; // eax
  int v43; // r9d
  int v44; // r8d
  int v45; // r14d
  int v46; // r12d
  __int64 v47; // rax
  __m128d v48; // xmm0
  __m128d v49; // xmm1
  __m128d v50; // xmm0
  __m128d v51; // xmm1
  __int64 v52; // rax
  __m128i v53; // xmm2
  __m128i v54; // xmm3
  _WORD *v55; // rdi
  __m128 v56; // xmm5
  __m128d v57; // xmm0
  __m128d v58; // xmm1
  __m128d v59; // xmm0
  __m128d v60; // xmm1
  __int64 v61; // rax
  __m128i si128; // xmm2
  __m128i v63; // xmm3
  __m128 v64; // xmm5
  __m128d v65; // xmm0
  __m128d v66; // xmm1
  __m128d v67; // xmm0
  __m128d v68; // xmm1
  __int64 v69; // rax
  __m128i v70; // xmm2
  __m128i v71; // xmm3
  __m128 v72; // xmm5
  __int64 v73; // rcx
  __int64 v74; // rsi
  __int16 v75; // ax
  __m128d v76; // xmm0
  __m128d v77; // xmm0
  __m128d v78; // xmm1
  __int64 v79; // rax
  __m128i v80; // xmm2
  __m128i v81; // xmm3
  __m128 v82; // xmm5
  unsigned int v83; // ecx
  int v84; // eax
  unsigned __int16 v85; // si
  __int64 v86; // rdx
  float v87; // xmm1_4
  float v88; // xmm0_4
  unsigned __int16 v89; // si
  float v90; // xmm0_4
  float v91; // xmm2_4
  _WORD *v92; // rax
  int v93; // ecx
  __int64 v94; // rdx
  int v95; // r10d
  __int64 v96; // rcx
  __int64 v97; // rax
  unsigned __int16 v98; // si
  unsigned __int16 v99; // ax
  __int64 v100; // rax
  __int16 v101; // dx
  unsigned __int8 v103; // [rsp+Ch] [rbp-8A4h]
  __int64 v104; // [rsp+10h] [rbp-8A0h]
  _WORD *v106; // [rsp+28h] [rbp-888h]
  unsigned __int16 v107; // [rsp+30h] [rbp-880h]
  __int64 v108; // [rsp+32h] [rbp-87Eh]
  __int64 v109; // [rsp+3Ah] [rbp-876h]
  int v110; // [rsp+42h] [rbp-86Eh]
  __int64 v111[6]; // [rsp+50h] [rbp-860h] BYREF
  _WORD v112[512]; // [rsp+80h] [rbp-830h] BYREF
  _DWORD v113[256]; // [rsp+480h] [rbp-430h] BYREF

  v106 = malloc(2LL * (unsigned int)(a5 + 2));
  if ( !v106 )
    return __stack_chk_guard;
  v14 = a10;
  v15 = a9;
  v16 = *a1;
  v17 = *a2;
  if ( v16 == 255 )
  {
    if ( v17 == 255 )
    {
      v107 = 0;
      if ( a6 == 1 )
      {
        v110 = *(_DWORD *)(a2 + 9);
        v18 = *(_QWORD *)(a2 + 1);
        v19 = *(_QWORD *)(a2 + 5);
      }
      else
      {
        v110 = *(_DWORD *)(a1 + 9);
        v18 = *(_QWORD *)(a1 + 1);
        v19 = *(_QWORD *)(a1 + 5);
      }
      v109 = v19;
      v108 = v18;
      goto LABEL_37;
    }
LABEL_7:
    v107 = 0;
    HIWORD(v110) = ext_uwCalTarget_BC[4 * a6 + a9];
    v20 = HIWORD(v110);
    LOWORD(v108) = (int)((float)HIWORD(v110) / 10.0 + 0.5);
    v21 = 2LL;
    a8 = (__m128d)0x3FE0000000000000uLL;
    while ( 1 )
    {
      *(&v107 + v21) = (int)((float)(int)(v21 * v20) / 10.0 + 0.5);
      if ( v21 == 9 )
        break;
      ++v21;
      v20 = HIWORD(v110);
    }
    goto LABEL_37;
  }
  if ( v17 == 255 )
    goto LABEL_7;
  v22 = (float)(unsigned __int16)(a1[7] + (a1[6] << 8));
  v112[0] = (int)((float)((float)(unsigned __int16)v16 * v22) / 255.0 + 0.5);
  for ( i = 1LL; i != 6; ++i )
    v112[i] = (int)((float)((float)a1[i] * v22) / 255.0 + 0.5);
  LOWORD(v111[0]) = a2[7] + (a2[6] << 8);
  v24 = (float)LOWORD(v111[0]);
  for ( j = 1LL; j != 6; ++j )
    *((_WORD *)v111 + j) = (int)((float)((float)(unsigned __int16)a2[j] * v24) / 255.0 + 0.5);
  v26 = a1[8];
  v27 = 1.0;
  v28 = 1.0;
  if ( v26 )
    v28 = (float)v26 / 100.0;
  v104 = a3;
  v29 = a2[8];
  if ( v29 )
    v27 = (float)v29 / 100.0;
  v30 = v111[0];
  v31 = v112[0];
  v32 = (float)((float)LOWORD(v111[0]) * v27) - (float)((float)v112[0] * v28);
  for ( k = 0LL; ; ++k )
  {
    v34 = (unsigned __int16)(int)((float)(v32 - (float)((float)((float)v30 * v27) - (float)((float)v31 * v28)))
                                * 255.0
                                / v32
                                + 0.5);
    if ( (unsigned int)v34 > 0xFF )
      v34 = 255LL;
    v35 = ext_ubConvTableInside_BC[256 * (unsigned __int64)a9 + v34];
    if ( (_DWORD)k == 1 )
      *(&v107 + k) = v35;
    else
      *(&v107 + 2 * k) = v35;
    if ( k == 5 )
      break;
    v30 = *((_WORD *)v111 + k + 1);
    v31 = v112[k + 1];
  }
  WORD1(v108) = (int)((float)((float)((float)(HIWORD(v108) - (unsigned __int16)v108) / 3.0)
                            + (float)(unsigned __int16)v108)
                    + 0.5);
  a8 = (__m128d)0x3F000000u;
  WORD2(v108) = (int)((float)((float)((float)(HIWORD(v108) - WORD1(v108)) * 0.5) + (float)WORD1(v108)) + 0.5);
  LOWORD(v109) = (int)((float)((float)((float)(WORD1(v109) - HIWORD(v108)) * 0.5) + (float)HIWORD(v108)) + 0.5);
  WORD2(v109) = (int)((float)((float)((float)(HIWORD(v109) - WORD1(v109)) * 0.5) + (float)WORD1(v109)) + 0.5);
  LOWORD(v110) = (int)((float)((float)((float)(HIWORD(v110) - HIWORD(v109)) * 0.5) + (float)HIWORD(v109)) + 0.5);
  LOWORD(v113[0]) = v107;
  v103 = a6;
  v36 = (char *)&ext_ubConvTableBase_BC + 44 * a6;
  v37 = v36[11 * a9];
  v38 = 0LL;
  v39 = (__int16 *)v113;
  for ( m = 0LL; m != 10; ++m )
  {
    v41 = v37;
    v37 = v36[11 * a9 + 1 + m];
    v42 = (unsigned __int16)(v41 + 1);
    if ( v42 <= v37 )
    {
      v43 = *(&v107 + m);
      v44 = *((unsigned __int16 *)&v108 + m) - v43;
      v45 = v41 + 2;
      do
      {
        *((_WORD *)v113 + (unsigned __int16)(v45 - 1)) = v43 + (int)(v44 * (v42 - v41)) / (v37 - v41);
        v42 = (unsigned __int16)v45++;
      }
      while ( v42 <= v37 );
    }
  }
  v14 = a10;
  v15 = a9;
  do
  {
    *(&v107 + v38++) = *v39;
    v39 += 10;
  }
  while ( v38 != 11 );
  a3 = v104;
  a6 = v103;
LABEL_37:
  v46 = ext_uwCalTarget_BC[4 * a6 + v15];
  v47 = 0LL;
  if ( v14 < 3u )
  {
    do
    {
      *((float *)v111 + v47) = (float)*(&v107 + v47);
      ++v47;
    }
    while ( v47 != 11 );
    CorrectSpline(v111, (__int64)v113, a5);
    if ( v14 == 2 )
    {
      v57 = (__m128d)(unsigned int)v113[a5 - 1];
      v57.f64[0] = (float)((float)((float)(*(float *)v57.f64 * 80.0) / 100.0) - (float)v107);
      v58 = 0LL;
      v58.f64[0] = (double)v107;
      v59 = _mm_unpacklo_pd(v57, v57);
      v60 = _mm_unpacklo_pd(v58, v58);
      v61 = 0LL;
      si128 = _mm_load_si128((const __m128i *)&xmmword_100010140);
      v63 = _mm_load_si128((const __m128i *)&xmmword_100010150);
      v55 = v106;
      do
      {
        v64 = _mm_div_ps(
                _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v61), 0), si128), v63)),
                (__m128)xmmword_100010160);
        *(__m128 *)&v112[2 * v61] = _mm_movelh_ps(
                                      _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v64), v59), v60)),
                                      _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v64, v64)), v59), v60)));
        v61 += 4LL;
      }
      while ( v61 != 256 );
LABEL_78:
      if ( (_WORD)a5 )
      {
        v95 = a5 - 1;
        v96 = 0LL;
        do
        {
          v97 = 0LL;
          do
          {
            if ( *(float *)&v113[v97] >= *(float *)&v112[2 * v96] )
              break;
            ++v97;
          }
          while ( (unsigned __int16)v97 < (unsigned int)(unsigned __int16)a5 );
          if ( !(_WORD)v96 )
            LOWORD(v97) = 0;
          v98 = v97;
          if ( (_DWORD)v96 == v95 && (unsigned __int16)v97 != v95 )
            v98 = a5 - 1;
          if ( (_WORD)v96 != 0 && v98 == 0 )
            v98 = 1;
          v99 = v98;
          if ( v98 > v95 )
            v99 = a5 - 1;
          v55[v96++] = v99;
        }
        while ( (unsigned __int16)v96 != (unsigned __int16)a5 );
      }
      goto LABEL_92;
    }
    v76 = 0LL;
    v76.f64[0] = (float)(v46 - v107);
    a8.f64[0] = (double)v107;
    v77 = _mm_unpacklo_pd(v76, v76);
    v78 = _mm_unpacklo_pd(a8, a8);
    v79 = 0LL;
    v80 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v81 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    do
    {
      v82 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v79), 0), v80), v81)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v112[2 * v79] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v82), v77), v78)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v82, v82)), v77), v78)));
      v79 += 4LL;
    }
    while ( v79 != 256 );
    v83 = 80 * a5 / 0x64u;
    v84 = a5 - 1;
    v85 = v83;
    if ( (unsigned __int16)v83 > (unsigned int)a5 )
    {
      v85 = a5 - 1;
      LOWORD(v83) = a5 - 1;
    }
    v86 = v85;
    v87 = *(float *)&v112[2 * v85];
    v88 = *(float *)&v113[v84];
    v55 = v106;
    if ( v87 > v88 )
    {
      if ( (unsigned __int16)v83 >= 0x33u )
      {
        if ( v88 > v87 )
        {
LABEL_73:
          LOWORD(v83) = v86;
          goto LABEL_75;
        }
        v89 = v85 - 1;
        while ( v89 >= 0x33u )
        {
          v87 = *((float *)&v111[5] + v86-- + 1);
          --v89;
          if ( v88 > v87 )
            goto LABEL_73;
        }
      }
      v87 = *(float *)&v113[v84];
    }
LABEL_75:
    if ( (unsigned __int16)v83 < (unsigned int)(unsigned __int16)a5 )
    {
      v90 = v88 - v87;
      v91 = (float)(v84 - (unsigned __int16)v83);
      v92 = &v112[2 * (unsigned __int16)v83];
      v93 = (unsigned __int16)(a5 - v83);
      v94 = 0LL;
      do
      {
        *(float *)&v92[2 * v94] = (float)((float)((float)(int)v94 * v90) / v91) + v87;
        ++v94;
      }
      while ( v93 != (unsigned __int16)v94 );
    }
    goto LABEL_78;
  }
  do
  {
    *((float *)v111 + v47) = (float)*(&v107 + v47);
    ++v47;
  }
  while ( v47 != 11 );
  CorrectSpline(v111, (__int64)v113, a5);
  if ( v14 == 5 )
  {
    v48 = (__m128d)(unsigned int)v113[a5 - 1];
    v48.f64[0] = (float)((float)((float)(*(float *)v48.f64 * 50.0) / 100.0) - (float)v107);
    v49 = 0LL;
    v49.f64[0] = (double)v107;
    v50 = _mm_unpacklo_pd(v48, v48);
    v51 = _mm_unpacklo_pd(v49, v49);
    v52 = 0LL;
    v53 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v54 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    v55 = v106;
    do
    {
      v56 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v52), 0), v53), v54)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v112[2 * v52] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v56), v50), v51)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v56, v56)), v50), v51)));
      v52 += 4LL;
    }
    while ( v52 != 256 );
  }
  else
  {
    v65 = 0LL;
    v65.f64[0] = (float)((float)((float)((float)v46 * 70.0) / 100.0) - (float)v107);
    v66 = 0LL;
    v66.f64[0] = (double)v107;
    v67 = _mm_unpacklo_pd(v65, v65);
    v68 = _mm_unpacklo_pd(v66, v66);
    v69 = 0LL;
    v70 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v71 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    v55 = v106;
    do
    {
      v72 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v69), 0), v70), v71)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v112[2 * v69] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v72), v67), v68)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v72, v72)), v67), v68)));
      v69 += 4LL;
    }
    while ( v69 != 256 );
  }
  if ( (_WORD)a5 )
  {
    v73 = 0LL;
    do
    {
      v74 = 0LL;
      do
      {
        if ( *(float *)&v113[v74] >= *(float *)&v112[2 * v73] )
          break;
        ++v74;
      }
      while ( (unsigned __int16)v74 < (unsigned int)(unsigned __int16)a5 );
      if ( !(_WORD)v73 )
        LOWORD(v74) = 0;
      if ( (_WORD)v73 != 0 && (_WORD)v74 == 0 )
        LOWORD(v74) = 1;
      v75 = v74;
      if ( (unsigned __int16)v74 > a5 - 1 )
        v75 = a5 - 1;
      v55[v73++] = v75;
    }
    while ( (unsigned __int16)v73 != (unsigned __int16)a5 );
  }
LABEL_92:
  if ( (_WORD)a5 )
  {
    v100 = 0LL;
    do
    {
      v101 = v55[v100];
      if ( a4 == 1 )
        *(_WORD *)(a3 + 2 * v100) = v101;
      else
        *(_BYTE *)(a3 + v100) = v101;
      ++v100;
    }
    while ( (int)v100 < a5 );
  }
  free(v55);
  return __stack_chk_guard;
}
// 100010140: using guessed type __int128 xmmword_100010140;
// 100010150: using guessed type __int128 xmmword_100010150;
// 100010160: using guessed type __int128 xmmword_100010160;
// 100015D60: using guessed type unsigned __int16 ext_uwCalTarget_BC[16];
// 100015E10: using guessed type unsigned __int8 ext_ubConvTableInside_BC[1024];

//----- (0000000100008307) ----------------------------------------------------
void __fastcall CorrectSpline(__int64 *a1, __int64 a2, int a3)
{
  float *v3; // r13
  _QWORD *v4; // r12
  void *v5; // rbx
  float *v6; // r15
  float *v7; // rax
  float *v9; // r14
  float v10; // xmm0_4
  __int64 v11; // rax
  __int64 i; // rax
  float v13; // xmm1_4
  float v14; // xmm2_4
  __int64 v15; // rax
  float v16; // xmm3_4
  float v17; // xmm4_4
  float v18; // xmm5_4
  float v19; // xmm3_4
  float v20; // xmm4_4
  float v21; // xmm3_4
  float v22; // xmm2_4
  __int64 j; // rax
  float v24; // xmm1_4
  float v25; // xmm5_4
  float v26; // xmm6_4
  float v27; // xmm7_4
  float v28; // xmm2_4
  float v29; // xmm1_4
  __int64 v30; // rax
  float v31; // xmm2_4
  __int64 v32; // rax
  float v33; // xmm3_4
  int v34; // ecx
  int v35; // esi
  int v36; // edx
  int v37; // edx
  bool v38; // cc
  int v39; // esi
  __int64 v40; // rcx
  float v41; // xmm4_4
  float v42; // xmm5_4
  float v43; // xmm7_4
  float v44; // xmm4_4
  float v45; // xmm3_4

  v3 = (float *)malloc(0x40uLL);
  v4 = malloc(0x40uLL);
  v5 = malloc(0x40uLL);
  v6 = (float *)malloc(0x40uLL);
  v7 = (float *)malloc(0x40uLL);
  v9 = v7;
  *((_QWORD *)v3 + 7) = 0LL;
  *((_QWORD *)v3 + 6) = 0LL;
  *((_QWORD *)v3 + 5) = 0LL;
  *((_QWORD *)v3 + 4) = 0LL;
  *((_QWORD *)v3 + 3) = 0LL;
  *((_QWORD *)v3 + 2) = 0LL;
  *((_QWORD *)v3 + 1) = 0LL;
  *(_QWORD *)v3 = 0LL;
  v4[7] = 0LL;
  v4[6] = 0LL;
  v4[5] = 0LL;
  v4[4] = 0LL;
  v4[3] = 0LL;
  v4[2] = 0LL;
  v4[1] = 0LL;
  *v4 = 0LL;
  if ( v3 )
  {
    if ( v4 )
    {
      if ( v5 )
      {
        if ( v6 )
        {
          if ( v7 )
          {
            v10 = (float)(a3 - 1);
            *((_DWORD *)v4 + 10) = *((_DWORD *)a1 + 10);
            v4[4] = a1[4];
            v4[3] = a1[3];
            v4[2] = a1[2];
            v11 = *a1;
            v4[1] = a1[1];
            *v4 = v11;
            for ( i = 0LL; i != 11; ++i )
              v3[i] = (float)((float)(int)i * v10) / 10.0;
            *((_DWORD *)v5 + 10) = 0;
            *(_DWORD *)v5 = 0;
            v13 = *v3;
            v14 = *(float *)v4;
            v15 = 0LL;
            v16 = *v3;
            do
            {
              v17 = v3[v15 + 1];
              v18 = v17 - v16;
              v9[v15] = v17 - v16;
              v19 = *((float *)v4 + v15 + 1);
              v6[++v15] = (float)(v19 - v14) / v18;
              v14 = v19;
              v16 = v17;
            }
            while ( v15 != 10 );
            v20 = v6[2];
            v21 = (float)(*v9 * -0.0) + (float)(v20 - v6[1]);
            *((float *)v5 + 1) = v21;
            v22 = (float)(v3[2] - v13) + (float)(v3[2] - v13);
            v6[1] = v22;
            for ( j = 0LL; j != 8; ++j )
            {
              v24 = v9[j + 1];
              v25 = v24 / v22;
              v26 = v6[j + 3];
              v27 = (float)(v26 - v20) - (float)(v21 * (float)(v24 / v22));
              *((float *)v5 + j + 2) = v27;
              v28 = v3[j + 3] - v3[j + 1];
              v22 = (float)(v28 + v28) - (float)(v25 * v24);
              v6[j + 2] = v22;
              v21 = v27;
              v20 = v26;
            }
            v29 = *((float *)v5 + 10);
            *((float *)v5 + 9) = *((float *)v5 + 9) - (float)(v9[9] * v29);
            v30 = 9LL;
            do
            {
              v31 = (float)(*((float *)v5 + v30) - (float)(v29 * v9[v30])) / v6[v30];
              *((float *)v5 + v30--) = v31;
              v29 = v31;
            }
            while ( (int)v30 > 0 );
            v32 = 0LL;
            if ( a3 > 0 )
            {
              do
              {
                v33 = (float)(int)v32;
                v34 = 10;
                v35 = 0;
                do
                {
                  while ( 1 )
                  {
                    v36 = (v35 + v34) / 2;
                    if ( v33 <= v3[v36] )
                      break;
                    v37 = v36 + 1;
                    v35 = v37;
                    if ( v37 >= v34 )
                      goto LABEL_20;
                  }
                  v38 = v35 < v36;
                  v34 = (v35 + v34) / 2;
                  v37 = v35;
                }
                while ( v38 );
LABEL_20:
                v39 = v37 - (v37 > 0);
                v40 = v39 + 1;
                v41 = v3[v39];
                v42 = v3[v40] - v41;
                v43 = *((float *)v5 + v39);
                v44 = (float)((float)((float)((float)((float)(*((float *)v4 + v40) - *((float *)v4 + v39)) / v42)
                                            - (float)((float)((float)(v43 + v43) + *((float *)v5 + v40)) * v42))
                                    + (float)((float)((float)(v43 * 3.0)
                                                    + (float)((float)((float)(*((float *)v5 + v40) - v43)
                                                                    * (float)(v33 - v41))
                                                            / v42))
                                            * (float)(v33 - v41)))
                            * (float)(v33 - v41))
                    + *((float *)v4 + v39);
                v45 = (float)(a3 - 1);
                if ( v44 <= v10 )
                {
                  v45 = v44;
                  if ( v44 < 0.0 )
                    v45 = 0.0;
                }
                *(float *)(a2 + 4 * v32++) = v45;
              }
              while ( (_DWORD)v32 != a3 );
            }
          }
        }
      }
    }
  }
  if ( v3 )
    free(v3);
  if ( v4 )
    free(v4);
  if ( v5 )
    free(v5);
  if ( v6 )
    free(v6);
  if ( v9 )
    free(v9);
}

//----- (0000000100008717) ----------------------------------------------------
__int64 __fastcall BrMakeGammaTable3150(
        unsigned __int16 *a1,
        __int16 *a2,
        __int64 a3,
        char a4,
        int a5,
        unsigned __int8 a6,
        double a7,
        __m128d a8,
        unsigned __int8 a9,
        unsigned __int8 a10)
{
  unsigned __int8 v14; // si
  unsigned __int8 v15; // r8
  int v16; // eax
  __int16 v17; // cx
  __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int16 v20; // cx
  __int64 v21; // rax
  float v22; // xmm2_4
  __int64 i; // rax
  float v24; // xmm2_4
  __int64 j; // rax
  unsigned __int16 v26; // ax
  float v27; // xmm2_4
  float v28; // xmm3_4
  unsigned __int16 v29; // ax
  unsigned __int16 v30; // di
  unsigned __int16 v31; // bx
  float v32; // xmm4_4
  __int64 k; // rcx
  __int64 v34; // rax
  __int16 v35; // di
  char *v36; // r11
  unsigned __int8 v37; // r12
  __int64 v38; // rdi
  __int16 *v39; // r13
  __int64 m; // rcx
  int v41; // ebx
  unsigned int v42; // eax
  int v43; // r9d
  int v44; // r8d
  int v45; // r14d
  int v46; // r12d
  __int64 v47; // rax
  __m128d v48; // xmm0
  __m128d v49; // xmm1
  __m128d v50; // xmm0
  __m128d v51; // xmm1
  __int64 v52; // rax
  __m128i v53; // xmm2
  __m128i v54; // xmm3
  _WORD *v55; // rdi
  __m128 v56; // xmm5
  __m128d v57; // xmm0
  __m128d v58; // xmm1
  __m128d v59; // xmm0
  __m128d v60; // xmm1
  __int64 v61; // rax
  __m128i si128; // xmm2
  __m128i v63; // xmm3
  __m128 v64; // xmm5
  __m128d v65; // xmm0
  __m128d v66; // xmm1
  __m128d v67; // xmm0
  __m128d v68; // xmm1
  __int64 v69; // rax
  __m128i v70; // xmm2
  __m128i v71; // xmm3
  __m128 v72; // xmm5
  __int64 v73; // rcx
  __int64 v74; // rsi
  __int16 v75; // ax
  __m128d v76; // xmm0
  __m128d v77; // xmm0
  __m128d v78; // xmm1
  __int64 v79; // rax
  __m128i v80; // xmm2
  __m128i v81; // xmm3
  __m128 v82; // xmm5
  unsigned int v83; // ecx
  int v84; // eax
  unsigned __int16 v85; // si
  __int64 v86; // rdx
  float v87; // xmm1_4
  float v88; // xmm0_4
  unsigned __int16 v89; // si
  float v90; // xmm0_4
  float v91; // xmm2_4
  _WORD *v92; // rax
  int v93; // ecx
  __int64 v94; // rdx
  int v95; // r10d
  __int64 v96; // rcx
  __int64 v97; // rax
  unsigned __int16 v98; // si
  unsigned __int16 v99; // ax
  __int64 v100; // rax
  __int16 v101; // dx
  unsigned __int8 v103; // [rsp+Ch] [rbp-8A4h]
  __int64 v104; // [rsp+10h] [rbp-8A0h]
  _WORD *v106; // [rsp+28h] [rbp-888h]
  unsigned __int16 v107; // [rsp+30h] [rbp-880h]
  __int64 v108; // [rsp+32h] [rbp-87Eh]
  __int64 v109; // [rsp+3Ah] [rbp-876h]
  int v110; // [rsp+42h] [rbp-86Eh]
  __int64 v111[6]; // [rsp+50h] [rbp-860h] BYREF
  _WORD v112[512]; // [rsp+80h] [rbp-830h] BYREF
  _DWORD v113[256]; // [rsp+480h] [rbp-430h] BYREF

  v106 = malloc(2LL * (unsigned int)(a5 + 2));
  if ( !v106 )
    return __stack_chk_guard;
  v14 = a10;
  v15 = a9;
  v16 = *a1;
  v17 = *a2;
  if ( v16 == 255 )
  {
    if ( v17 == 255 )
    {
      v107 = 0;
      if ( a6 == 1 )
      {
        v110 = *(_DWORD *)(a2 + 9);
        v18 = *(_QWORD *)(a2 + 1);
        v19 = *(_QWORD *)(a2 + 5);
      }
      else
      {
        v110 = *(_DWORD *)(a1 + 9);
        v18 = *(_QWORD *)(a1 + 1);
        v19 = *(_QWORD *)(a1 + 5);
      }
      v109 = v19;
      v108 = v18;
      goto LABEL_37;
    }
LABEL_7:
    v107 = 0;
    HIWORD(v110) = ext_uwCalTarget_DCL[4 * a6 + a9];
    v20 = HIWORD(v110);
    LOWORD(v108) = (int)((float)HIWORD(v110) / 10.0 + 0.5);
    v21 = 2LL;
    a8 = (__m128d)0x3FE0000000000000uLL;
    while ( 1 )
    {
      *(&v107 + v21) = (int)((float)(int)(v21 * v20) / 10.0 + 0.5);
      if ( v21 == 9 )
        break;
      ++v21;
      v20 = HIWORD(v110);
    }
    goto LABEL_37;
  }
  if ( v17 == 255 )
    goto LABEL_7;
  v22 = (float)(unsigned __int16)(a1[7] + (a1[6] << 8));
  v112[0] = (int)((float)((float)(unsigned __int16)v16 * v22) / 255.0 + 0.5);
  for ( i = 1LL; i != 6; ++i )
    v112[i] = (int)((float)((float)a1[i] * v22) / 255.0 + 0.5);
  LOWORD(v111[0]) = a2[7] + (a2[6] << 8);
  v24 = (float)LOWORD(v111[0]);
  for ( j = 1LL; j != 6; ++j )
    *((_WORD *)v111 + j) = (int)((float)((float)(unsigned __int16)a2[j] * v24) / 255.0 + 0.5);
  v26 = a1[8];
  v27 = 1.0;
  v28 = 1.0;
  if ( v26 )
    v28 = (float)v26 / 100.0;
  v104 = a3;
  v29 = a2[8];
  if ( v29 )
    v27 = (float)v29 / 100.0;
  v30 = v111[0];
  v31 = v112[0];
  v32 = (float)((float)LOWORD(v111[0]) * v27) - (float)((float)v112[0] * v28);
  for ( k = 0LL; ; ++k )
  {
    v34 = (unsigned __int16)(int)((float)(v32 - (float)((float)((float)v30 * v27) - (float)((float)v31 * v28)))
                                * 255.0
                                / v32
                                + 0.5);
    if ( (unsigned int)v34 > 0xFF )
      v34 = 255LL;
    v35 = ext_ubConvTableInside_DCL[256 * (unsigned __int64)a9 + v34];
    if ( (_DWORD)k == 1 )
      *(&v107 + k) = v35;
    else
      *(&v107 + 2 * k) = v35;
    if ( k == 5 )
      break;
    v30 = *((_WORD *)v111 + k + 1);
    v31 = v112[k + 1];
  }
  WORD1(v108) = (int)((float)((float)((float)(HIWORD(v108) - (unsigned __int16)v108) / 3.0)
                            + (float)(unsigned __int16)v108)
                    + 0.5);
  a8 = (__m128d)0x3F000000u;
  WORD2(v108) = (int)((float)((float)((float)(HIWORD(v108) - WORD1(v108)) * 0.5) + (float)WORD1(v108)) + 0.5);
  LOWORD(v109) = (int)((float)((float)((float)(WORD1(v109) - HIWORD(v108)) * 0.5) + (float)HIWORD(v108)) + 0.5);
  WORD2(v109) = (int)((float)((float)((float)(HIWORD(v109) - WORD1(v109)) * 0.5) + (float)WORD1(v109)) + 0.5);
  LOWORD(v110) = (int)((float)((float)((float)(HIWORD(v110) - HIWORD(v109)) * 0.5) + (float)HIWORD(v109)) + 0.5);
  LOWORD(v113[0]) = v107;
  v103 = a6;
  v36 = (char *)&ext_ubConvTableBase_DCL + 44 * a6;
  v37 = v36[11 * a9];
  v38 = 0LL;
  v39 = (__int16 *)v113;
  for ( m = 0LL; m != 10; ++m )
  {
    v41 = v37;
    v37 = v36[11 * a9 + 1 + m];
    v42 = (unsigned __int16)(v41 + 1);
    if ( v42 <= v37 )
    {
      v43 = *(&v107 + m);
      v44 = *((unsigned __int16 *)&v108 + m) - v43;
      v45 = v41 + 2;
      do
      {
        *((_WORD *)v113 + (unsigned __int16)(v45 - 1)) = v43 + (int)(v44 * (v42 - v41)) / (v37 - v41);
        v42 = (unsigned __int16)v45++;
      }
      while ( v42 <= v37 );
    }
  }
  v14 = a10;
  v15 = a9;
  do
  {
    *(&v107 + v38++) = *v39;
    v39 += 10;
  }
  while ( v38 != 11 );
  a3 = v104;
  a6 = v103;
LABEL_37:
  v46 = (unsigned __int16)ext_uwCalTarget_DCL[4 * a6 + v15];
  v47 = 0LL;
  if ( v14 < 3u )
  {
    do
    {
      *((float *)v111 + v47) = (float)*(&v107 + v47);
      ++v47;
    }
    while ( v47 != 11 );
    CorrectSpline_0(v111, (__int64)v113, a5);
    if ( v14 == 2 )
    {
      v57 = (__m128d)(unsigned int)v113[a5 - 1];
      v57.f64[0] = (float)((float)((float)(*(float *)v57.f64 * 80.0) / 100.0) - (float)v107);
      v58 = 0LL;
      v58.f64[0] = (double)v107;
      v59 = _mm_unpacklo_pd(v57, v57);
      v60 = _mm_unpacklo_pd(v58, v58);
      v61 = 0LL;
      si128 = _mm_load_si128((const __m128i *)&xmmword_100010140);
      v63 = _mm_load_si128((const __m128i *)&xmmword_100010150);
      v55 = v106;
      do
      {
        v64 = _mm_div_ps(
                _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v61), 0), si128), v63)),
                (__m128)xmmword_100010160);
        *(__m128 *)&v112[2 * v61] = _mm_movelh_ps(
                                      _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v64), v59), v60)),
                                      _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v64, v64)), v59), v60)));
        v61 += 4LL;
      }
      while ( v61 != 256 );
LABEL_78:
      if ( (_WORD)a5 )
      {
        v95 = a5 - 1;
        v96 = 0LL;
        do
        {
          v97 = 0LL;
          do
          {
            if ( *(float *)&v113[v97] >= *(float *)&v112[2 * v96] )
              break;
            ++v97;
          }
          while ( (unsigned __int16)v97 < (unsigned int)(unsigned __int16)a5 );
          if ( !(_WORD)v96 )
            LOWORD(v97) = 0;
          v98 = v97;
          if ( (_DWORD)v96 == v95 && (unsigned __int16)v97 != v95 )
            v98 = a5 - 1;
          if ( (_WORD)v96 != 0 && v98 == 0 )
            v98 = 1;
          v99 = v98;
          if ( v98 > v95 )
            v99 = a5 - 1;
          v55[v96++] = v99;
        }
        while ( (unsigned __int16)v96 != (unsigned __int16)a5 );
      }
      goto LABEL_92;
    }
    v76 = 0LL;
    v76.f64[0] = (float)(v46 - v107);
    a8.f64[0] = (double)v107;
    v77 = _mm_unpacklo_pd(v76, v76);
    v78 = _mm_unpacklo_pd(a8, a8);
    v79 = 0LL;
    v80 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v81 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    do
    {
      v82 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v79), 0), v80), v81)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v112[2 * v79] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v82), v77), v78)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v82, v82)), v77), v78)));
      v79 += 4LL;
    }
    while ( v79 != 256 );
    v83 = 80 * a5 / 0x64u;
    v84 = a5 - 1;
    v85 = v83;
    if ( (unsigned __int16)v83 > (unsigned int)a5 )
    {
      v85 = a5 - 1;
      LOWORD(v83) = a5 - 1;
    }
    v86 = v85;
    v87 = *(float *)&v112[2 * v85];
    v88 = *(float *)&v113[v84];
    v55 = v106;
    if ( v87 > v88 )
    {
      if ( (unsigned __int16)v83 >= 0x33u )
      {
        if ( v88 > v87 )
        {
LABEL_73:
          LOWORD(v83) = v86;
          goto LABEL_75;
        }
        v89 = v85 - 1;
        while ( v89 >= 0x33u )
        {
          v87 = *((float *)&v111[5] + v86-- + 1);
          --v89;
          if ( v88 > v87 )
            goto LABEL_73;
        }
      }
      v87 = *(float *)&v113[v84];
    }
LABEL_75:
    if ( (unsigned __int16)v83 < (unsigned int)(unsigned __int16)a5 )
    {
      v90 = v88 - v87;
      v91 = (float)(v84 - (unsigned __int16)v83);
      v92 = &v112[2 * (unsigned __int16)v83];
      v93 = (unsigned __int16)(a5 - v83);
      v94 = 0LL;
      do
      {
        *(float *)&v92[2 * v94] = (float)((float)((float)(int)v94 * v90) / v91) + v87;
        ++v94;
      }
      while ( v93 != (unsigned __int16)v94 );
    }
    goto LABEL_78;
  }
  do
  {
    *((float *)v111 + v47) = (float)*(&v107 + v47);
    ++v47;
  }
  while ( v47 != 11 );
  CorrectSpline_0(v111, (__int64)v113, a5);
  if ( v14 == 5 )
  {
    v48 = (__m128d)(unsigned int)v113[a5 - 1];
    v48.f64[0] = (float)((float)((float)(*(float *)v48.f64 * 50.0) / 100.0) - (float)v107);
    v49 = 0LL;
    v49.f64[0] = (double)v107;
    v50 = _mm_unpacklo_pd(v48, v48);
    v51 = _mm_unpacklo_pd(v49, v49);
    v52 = 0LL;
    v53 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v54 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    v55 = v106;
    do
    {
      v56 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v52), 0), v53), v54)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v112[2 * v52] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v56), v50), v51)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v56, v56)), v50), v51)));
      v52 += 4LL;
    }
    while ( v52 != 256 );
  }
  else
  {
    v65 = 0LL;
    v65.f64[0] = (float)((float)((float)((float)v46 * 70.0) / 100.0) - (float)v107);
    v66 = 0LL;
    v66.f64[0] = (double)v107;
    v67 = _mm_unpacklo_pd(v65, v65);
    v68 = _mm_unpacklo_pd(v66, v66);
    v69 = 0LL;
    v70 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v71 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    v55 = v106;
    do
    {
      v72 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v69), 0), v70), v71)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v112[2 * v69] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v72), v67), v68)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v72, v72)), v67), v68)));
      v69 += 4LL;
    }
    while ( v69 != 256 );
  }
  if ( (_WORD)a5 )
  {
    v73 = 0LL;
    do
    {
      v74 = 0LL;
      do
      {
        if ( *(float *)&v113[v74] >= *(float *)&v112[2 * v73] )
          break;
        ++v74;
      }
      while ( (unsigned __int16)v74 < (unsigned int)(unsigned __int16)a5 );
      if ( !(_WORD)v73 )
        LOWORD(v74) = 0;
      if ( (_WORD)v73 != 0 && (_WORD)v74 == 0 )
        LOWORD(v74) = 1;
      v75 = v74;
      if ( (unsigned __int16)v74 > a5 - 1 )
        v75 = a5 - 1;
      v55[v73++] = v75;
    }
    while ( (unsigned __int16)v73 != (unsigned __int16)a5 );
  }
LABEL_92:
  if ( (_WORD)a5 )
  {
    v100 = 0LL;
    do
    {
      v101 = v55[v100];
      if ( a4 == 1 )
        *(_WORD *)(a3 + 2 * v100) = v101;
      else
        *(_BYTE *)(a3 + v100) = v101;
      ++v100;
    }
    while ( (int)v100 < a5 );
  }
  free(v55);
  return __stack_chk_guard;
}
// 100010140: using guessed type __int128 xmmword_100010140;
// 100010150: using guessed type __int128 xmmword_100010150;
// 100010160: using guessed type __int128 xmmword_100010160;
// 100016210: using guessed type __int16 ext_uwCalTarget_DCL[3];
// 1000162C0: using guessed type unsigned __int8 ext_ubConvTableInside_DCL[1024];

//----- (00000001000091B6) ----------------------------------------------------
void __fastcall CorrectSpline_0(__int64 *a1, __int64 a2, int a3)
{
  float *v3; // r13
  _QWORD *v4; // r12
  void *v5; // rbx
  float *v6; // r15
  float *v7; // rax
  float *v9; // r14
  float v10; // xmm0_4
  __int64 v11; // rax
  __int64 i; // rax
  float v13; // xmm1_4
  float v14; // xmm2_4
  __int64 v15; // rax
  float v16; // xmm3_4
  float v17; // xmm4_4
  float v18; // xmm5_4
  float v19; // xmm3_4
  float v20; // xmm4_4
  float v21; // xmm3_4
  float v22; // xmm2_4
  __int64 j; // rax
  float v24; // xmm1_4
  float v25; // xmm5_4
  float v26; // xmm6_4
  float v27; // xmm7_4
  float v28; // xmm2_4
  float v29; // xmm1_4
  __int64 v30; // rax
  float v31; // xmm2_4
  __int64 v32; // rax
  float v33; // xmm3_4
  int v34; // ecx
  int v35; // esi
  int v36; // edx
  int v37; // edx
  bool v38; // cc
  int v39; // esi
  __int64 v40; // rcx
  float v41; // xmm4_4
  float v42; // xmm5_4
  float v43; // xmm7_4
  float v44; // xmm4_4
  float v45; // xmm3_4

  v3 = (float *)malloc(0x40uLL);
  v4 = malloc(0x40uLL);
  v5 = malloc(0x40uLL);
  v6 = (float *)malloc(0x40uLL);
  v7 = (float *)malloc(0x40uLL);
  v9 = v7;
  *((_QWORD *)v3 + 7) = 0LL;
  *((_QWORD *)v3 + 6) = 0LL;
  *((_QWORD *)v3 + 5) = 0LL;
  *((_QWORD *)v3 + 4) = 0LL;
  *((_QWORD *)v3 + 3) = 0LL;
  *((_QWORD *)v3 + 2) = 0LL;
  *((_QWORD *)v3 + 1) = 0LL;
  *(_QWORD *)v3 = 0LL;
  v4[7] = 0LL;
  v4[6] = 0LL;
  v4[5] = 0LL;
  v4[4] = 0LL;
  v4[3] = 0LL;
  v4[2] = 0LL;
  v4[1] = 0LL;
  *v4 = 0LL;
  if ( v3 )
  {
    if ( v4 )
    {
      if ( v5 )
      {
        if ( v6 )
        {
          if ( v7 )
          {
            v10 = (float)(a3 - 1);
            *((_DWORD *)v4 + 10) = *((_DWORD *)a1 + 10);
            v4[4] = a1[4];
            v4[3] = a1[3];
            v4[2] = a1[2];
            v11 = *a1;
            v4[1] = a1[1];
            *v4 = v11;
            for ( i = 0LL; i != 11; ++i )
              v3[i] = (float)((float)(int)i * v10) / 10.0;
            *((_DWORD *)v5 + 10) = 0;
            *(_DWORD *)v5 = 0;
            v13 = *v3;
            v14 = *(float *)v4;
            v15 = 0LL;
            v16 = *v3;
            do
            {
              v17 = v3[v15 + 1];
              v18 = v17 - v16;
              v9[v15] = v17 - v16;
              v19 = *((float *)v4 + v15 + 1);
              v6[++v15] = (float)(v19 - v14) / v18;
              v14 = v19;
              v16 = v17;
            }
            while ( v15 != 10 );
            v20 = v6[2];
            v21 = (float)(*v9 * -0.0) + (float)(v20 - v6[1]);
            *((float *)v5 + 1) = v21;
            v22 = (float)(v3[2] - v13) + (float)(v3[2] - v13);
            v6[1] = v22;
            for ( j = 0LL; j != 8; ++j )
            {
              v24 = v9[j + 1];
              v25 = v24 / v22;
              v26 = v6[j + 3];
              v27 = (float)(v26 - v20) - (float)(v21 * (float)(v24 / v22));
              *((float *)v5 + j + 2) = v27;
              v28 = v3[j + 3] - v3[j + 1];
              v22 = (float)(v28 + v28) - (float)(v25 * v24);
              v6[j + 2] = v22;
              v21 = v27;
              v20 = v26;
            }
            v29 = *((float *)v5 + 10);
            *((float *)v5 + 9) = *((float *)v5 + 9) - (float)(v9[9] * v29);
            v30 = 9LL;
            do
            {
              v31 = (float)(*((float *)v5 + v30) - (float)(v29 * v9[v30])) / v6[v30];
              *((float *)v5 + v30--) = v31;
              v29 = v31;
            }
            while ( (int)v30 > 0 );
            v32 = 0LL;
            if ( a3 > 0 )
            {
              do
              {
                v33 = (float)(int)v32;
                v34 = 10;
                v35 = 0;
                do
                {
                  while ( 1 )
                  {
                    v36 = (v35 + v34) / 2;
                    if ( v33 <= v3[v36] )
                      break;
                    v37 = v36 + 1;
                    v35 = v37;
                    if ( v37 >= v34 )
                      goto LABEL_20;
                  }
                  v38 = v35 < v36;
                  v34 = (v35 + v34) / 2;
                  v37 = v35;
                }
                while ( v38 );
LABEL_20:
                v39 = v37 - (v37 > 0);
                v40 = v39 + 1;
                v41 = v3[v39];
                v42 = v3[v40] - v41;
                v43 = *((float *)v5 + v39);
                v44 = (float)((float)((float)((float)((float)(*((float *)v4 + v40) - *((float *)v4 + v39)) / v42)
                                            - (float)((float)((float)(v43 + v43) + *((float *)v5 + v40)) * v42))
                                    + (float)((float)((float)(v43 * 3.0)
                                                    + (float)((float)((float)(*((float *)v5 + v40) - v43)
                                                                    * (float)(v33 - v41))
                                                            / v42))
                                            * (float)(v33 - v41)))
                            * (float)(v33 - v41))
                    + *((float *)v4 + v39);
                v45 = (float)(a3 - 1);
                if ( v44 <= v10 )
                {
                  v45 = v44;
                  if ( v44 < 0.0 )
                    v45 = 0.0;
                }
                *(float *)(a2 + 4 * v32++) = v45;
              }
              while ( (_DWORD)v32 != a3 );
            }
          }
        }
      }
    }
  }
  if ( v3 )
    free(v3);
  if ( v4 )
    free(v4);
  if ( v5 )
    free(v5);
  if ( v6 )
    free(v6);
  if ( v9 )
    free(v9);
}

//----- (00000001000095C8) ----------------------------------------------------
void *__fastcall BRCalibrationGetBRCalibrationModuleInfoWithModelType(_DWORD *a1, _DWORD *a2)
{
  void *result; // rax

  result = 0LL;
  if ( a1 )
  {
    if ( *a1 == 2 && (unsigned int)(a1[1] - 1) <= 8 )
    {
      switch ( a1[1] )
      {
        case 4:
        case 0xD:
          *a2 = 24;
          result = &kCalibrationInfo4150;
          break;
        case 5:
        case 0xE:
          *a2 = 24;
          result = &kCalibrationInfo3150;
          break;
        case 6:
        case 0x10:
          *a2 = 16;
          result = &kCalibrationInfoBC2Model;
          break;
        case 7:
        case 0xF:
          *a2 = 24;
          result = &kCalibrationInfoDCLUFPModel;
          break;
        case 8:
        case 0x11:
          *a2 = 16;
          result = &kCalibrationInfoBC4Model;
          break;
        case 9:
        case 0x12:
          *a2 = 16;
          result = &kCalibrationInfoECLModel;
          break;
        default:
          goto LABEL_4;
      }
    }
    else
    {
LABEL_4:
      *a2 = 0;
      return 0LL;
    }
  }
  return result;
}

//----- (0000000100009684) ----------------------------------------------------
char *__fastcall BRCalibrationGetConfigFileNameWithModelType(_DWORD *a1)
{
  unsigned int v1; // eax
  unsigned int v2; // eax

  if ( a1 && *a1 == 2 && (v1 = a1[1] - 1, v1 <= 8) && (v2 = dword_1000101E0[v1] - 4, v2 <= 5) )
    return off_100015410[v2];
  else
    return 0LL;
}
// 1000101E0: using guessed type _DWORD dword_1000101E0[12];
// 100015410: using guessed type char *off_100015410[6];

//----- (00000001000096C3) ----------------------------------------------------
__int64 __fastcall BRCalibrationDetermineModel(const char *a1, int *a2)
{
  unsigned int v2; // r15d
  ppd_file_t *v3; // rax
  ppd_file_t *v4; // rbx
  ppd_attr_t *Attr; // rax
  int v6; // ecx
  const char *value; // r12
  char *v8; // rax
  int model_number; // eax

  v2 = 1;
  if ( a1 )
  {
    v3 = ppdOpenFile(a1);
    v4 = v3;
    if ( v3 )
    {
      v2 = 0;
      Attr = ppdFindAttr(v3, kAPPrinterIconPath, 0LL);
      v6 = -1;
      if ( Attr )
      {
        value = Attr->value;
        v8 = strstr(value, "Ink");
        v6 = 0;
        if ( !v8 )
          v6 = 1 - ((strstr(value, "CL") == 0LL) - 1);
      }
      model_number = v4->model_number;
      *a2 = v6;
      a2[1] = model_number;
      ppdClose(v4);
    }
  }
  return v2;
}

//----- (0000000100009760) ----------------------------------------------------
bool __fastcall BRCalibrationNeedAutoCalibration(_DWORD *a1, const char *a2, const char *a3)
{
  char v4; // bl
  bool PrintersLUTDirPath; // al
  int v6; // ebx
  const char *v7; // r9
  _BOOL4 v8; // ebx
  char v9; // al
  char v11[1024]; // [rsp+0h] [rbp-C30h] BYREF
  char v12[1024]; // [rsp+400h] [rbp-830h] BYREF
  char v13[1024]; // [rsp+800h] [rbp-430h] BYREF

  v4 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v4 = 0;
        if ( !access("/Library/Caches", 0) )
        {
          __bzero(v13, 1024LL);
          PrintersLUTDirPath = getPrintersLUTDirPath(a3, v13);
          v6 = PrintersLUTDirPath;
          if ( !PrintersLUTDirPath )
          {
            __bzero(v12, 1024LL);
            if ( *a1 == 2 && (unsigned int)(a1[1] - 1) <= 8 )
            {
              v7 = "calib09.plist";
              switch ( a1[1] )
              {
                case 4:
                case 0xD:
                  break;
                case 5:
                case 0xE:
                  v7 = "calib12.plist";
                  break;
                case 6:
                case 0x10:
                  v7 = "calib13.plist";
                  break;
                case 7:
                case 0xF:
                  v7 = "calib12_sp.plist";
                  break;
                case 8:
                case 0x11:
                  v7 = "calib16.plist";
                  break;
                case 9:
                case 0x12:
                  v7 = "calib17.plist";
                  break;
                default:
                  goto LABEL_8;
              }
            }
            else
            {
LABEL_8:
              v6 = 1;
              v7 = 0LL;
            }
            __sprintf_chk(v12, 0, 0x400uLL, "%s/%s", v13, v7);
          }
          if ( v6 )
          {
            LOBYTE(v8) = 0;
          }
          else
          {
            v9 = BRCalibrationInfoManagerAutoCalibrationEnabled(v12);
            v8 = v9 != 0;
            if ( !v9 )
            {
              __bzero(v11, 1024LL);
              if ( !getCachesLUTDirPath(a3, a2, v11) && !access(v11, 0) )
                removeRecursively(v11);
            }
          }
          return v8;
        }
      }
    }
  }
  return v4;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (0000000100009944) ----------------------------------------------------
_BOOL8 __fastcall getPrintersLUTDirPath(const char *a1, char *a2)
{
  _BOOL4 VendorDirNameFromIconPath; // ebx
  ppd_file_t *v3; // rax
  ppd_file_t *v4; // r14
  ppd_attr_t *Attr; // rax
  char __dst[16]; // [rsp+0h] [rbp-130h] BYREF
  __int128 v8; // [rsp+10h] [rbp-120h]
  __int128 v9; // [rsp+20h] [rbp-110h]
  __int128 v10; // [rsp+30h] [rbp-100h]
  __int128 v11; // [rsp+40h] [rbp-F0h]
  __int128 v12; // [rsp+50h] [rbp-E0h]
  __int128 v13; // [rsp+60h] [rbp-D0h]
  __int128 v14; // [rsp+70h] [rbp-C0h]
  __int128 v15; // [rsp+80h] [rbp-B0h]
  __int128 v16; // [rsp+90h] [rbp-A0h]
  __int128 v17; // [rsp+A0h] [rbp-90h]
  __int128 v18; // [rsp+B0h] [rbp-80h]
  __int128 v19; // [rsp+C0h] [rbp-70h]
  __int128 v20; // [rsp+D0h] [rbp-60h]
  __int128 v21; // [rsp+E0h] [rbp-50h]
  __int128 v22; // [rsp+F0h] [rbp-40h]

  VendorDirNameFromIconPath = 1;
  if ( a2 )
  {
    if ( a1 )
    {
      v3 = ppdOpenFile(a1);
      v4 = v3;
      if ( v3 )
      {
        Attr = ppdFindAttr(v3, kAPPrinterIconPath, 0LL);
        VendorDirNameFromIconPath = 1;
        if ( Attr )
        {
          v22 = 0LL;
          v21 = 0LL;
          v20 = 0LL;
          v19 = 0LL;
          v18 = 0LL;
          v17 = 0LL;
          v16 = 0LL;
          v15 = 0LL;
          v14 = 0LL;
          v13 = 0LL;
          v12 = 0LL;
          v11 = 0LL;
          v10 = 0LL;
          v9 = 0LL;
          v8 = 0LL;
          *(_OWORD *)__dst = 0LL;
          VendorDirNameFromIconPath = getVendorDirNameFromIconPath(Attr->value, __dst);
          if ( !VendorDirNameFromIconPath )
            __sprintf_chk(a2, 0, 0xFFFFFFFFFFFFFFFFLL, "/Library/Printers/%s/LUT", __dst);
        }
        ppdClose(v4);
      }
    }
  }
  return VendorDirNameFromIconPath;
}

//----- (0000000100009A75) ----------------------------------------------------
_BOOL8 __fastcall getCachesLUTDirPath(const char *a1, const char *a2, char *a3)
{
  _BOOL4 VendorDirNameFromIconPath; // ebx
  ppd_file_t *v5; // rax
  ppd_file_t *v6; // r15
  ppd_attr_t *Attr; // rax
  char __dst[16]; // [rsp+0h] [rbp-130h] BYREF
  __int128 v10; // [rsp+10h] [rbp-120h]
  __int128 v11; // [rsp+20h] [rbp-110h]
  __int128 v12; // [rsp+30h] [rbp-100h]
  __int128 v13; // [rsp+40h] [rbp-F0h]
  __int128 v14; // [rsp+50h] [rbp-E0h]
  __int128 v15; // [rsp+60h] [rbp-D0h]
  __int128 v16; // [rsp+70h] [rbp-C0h]
  __int128 v17; // [rsp+80h] [rbp-B0h]
  __int128 v18; // [rsp+90h] [rbp-A0h]
  __int128 v19; // [rsp+A0h] [rbp-90h]
  __int128 v20; // [rsp+B0h] [rbp-80h]
  __int128 v21; // [rsp+C0h] [rbp-70h]
  __int128 v22; // [rsp+D0h] [rbp-60h]
  __int128 v23; // [rsp+E0h] [rbp-50h]
  __int128 v24; // [rsp+F0h] [rbp-40h]

  VendorDirNameFromIconPath = 1;
  if ( a3 )
  {
    if ( a1 )
    {
      if ( a2 )
      {
        v5 = ppdOpenFile(a1);
        v6 = v5;
        if ( v5 )
        {
          Attr = ppdFindAttr(v5, kAPPrinterIconPath, 0LL);
          VendorDirNameFromIconPath = 1;
          if ( Attr )
          {
            v24 = 0LL;
            v23 = 0LL;
            v22 = 0LL;
            v21 = 0LL;
            v20 = 0LL;
            v19 = 0LL;
            v18 = 0LL;
            v17 = 0LL;
            v16 = 0LL;
            v15 = 0LL;
            v14 = 0LL;
            v13 = 0LL;
            v12 = 0LL;
            v11 = 0LL;
            v10 = 0LL;
            *(_OWORD *)__dst = 0LL;
            VendorDirNameFromIconPath = getVendorDirNameFromIconPath(Attr->value, __dst);
            if ( !VendorDirNameFromIconPath )
              __sprintf_chk(a3, 0, 0xFFFFFFFFFFFFFFFFLL, "/Library/Caches/%s/%s/LUT", __dst, a2);
          }
          ppdClose(v6);
        }
      }
    }
  }
  return VendorDirNameFromIconPath;
}

//----- (0000000100009BB9) ----------------------------------------------------
__int64 __fastcall removeRecursively(const char *a1)
{
  unsigned int v1; // r14d
  DIR *v2; // rax
  DIR *v3; // r14
  dirent *i; // r12
  const char *d_name; // r12
  char v7[1024]; // [rsp+0h] [rbp-430h] BYREF

  v1 = 1;
  if ( a1 )
  {
    v1 = 0;
    if ( !access(a1, 0) )
    {
      if ( remove(a1) )
      {
        v2 = opendir_INODE64(a1);
        v3 = v2;
        if ( v2 )
        {
          for ( i = readdir_INODE64(v2); i; i = readdir_INODE64(v3) )
          {
            d_name = i->d_name;
            if ( strcmp(d_name, ".") && strcmp(d_name, "..") )
            {
              __bzero(v7, 1024LL);
              __sprintf_chk(v7, 0, 0x400uLL, "%s/%s", a1, d_name);
              removeRecursively(v7);
            }
          }
          closedir(v3);
        }
        return (unsigned int)remove(a1);
      }
    }
  }
  return v1;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (0000000100009CEA) ----------------------------------------------------
__int64 __fastcall BRCalibrationCalibration(int **a1, int a2, _DWORD *a3, const char *a4, char *a5)
{
  int **v6; // r14
  unsigned int Directory; // r13d
  int v8; // eax
  unsigned int v9; // edx
  int *v10; // rax
  int *v11; // r13
  int **v12; // rcx
  int v13; // edx
  int *v14; // rdi
  __CFDictionary *Mutable; // r12
  int v16; // eax
  __CFString **v17; // rax
  bool v18; // zf
  __CFString *v19; // rax
  CFDataRef v20; // r13
  CFDataRef v21; // rbx
  __int64 v22; // r12
  const char *v23; // r14
  CFDictionaryRef Copy; // r15
  size_t v25; // rax
  CFURLRef v26; // rax
  CFURLRef v27; // rbx
  const void *v28; // rax
  int v29; // edx
  _BYTE *v30; // r12
  int v31; // r15d
  unsigned __int8 v32; // r14
  unsigned __int8 v33; // bl
  unsigned int v34; // eax
  _DWORD *v36; // [rsp+30h] [rbp-CA0h]
  __int64 v37; // [rsp+38h] [rbp-C98h]
  _DWORD *v38; // [rsp+40h] [rbp-C90h]
  int *v39; // [rsp+48h] [rbp-C88h]
  __int64 v40; // [rsp+48h] [rbp-C88h]
  signed int v42; // [rsp+58h] [rbp-C78h]
  _DWORD *v43; // [rsp+58h] [rbp-C78h]
  int *v44; // [rsp+60h] [rbp-C70h]
  __int64 v45; // [rsp+60h] [rbp-C70h]
  char *__s; // [rsp+68h] [rbp-C68h]
  __CFDictionary *theDict; // [rsp+70h] [rbp-C60h]
  CFMutableDictionaryRef theDicta; // [rsp+70h] [rbp-C60h]
  CFDataRef value; // [rsp+78h] [rbp-C58h]
  void *valuea; // [rsp+78h] [rbp-C58h]
  CFDataRef v51; // [rsp+80h] [rbp-C50h]
  const __CFDictionary *v52; // [rsp+80h] [rbp-C50h]
  __CFString *key; // [rsp+88h] [rbp-C48h]
  int keya; // [rsp+88h] [rbp-C48h]
  int allocator; // [rsp+90h] [rbp-C40h]
  int v56; // [rsp+98h] [rbp-C38h]
  int v57; // [rsp+98h] [rbp-C38h]
  char v58[1024]; // [rsp+A0h] [rbp-C30h] BYREF
  char v59[1024]; // [rsp+4A0h] [rbp-830h] BYREF
  char v60[1024]; // [rsp+8A0h] [rbp-430h] BYREF

  v6 = a1;
  Directory = 1;
  if ( a4 )
  {
    if ( a5 )
    {
      if ( a3 )
      {
        if ( *a3 == 2 )
        {
          v8 = a3[1] - 1;
          if ( (unsigned int)v8 <= 8 )
          {
            v9 = dword_1000101E0[v8] - 4;
            if ( v9 <= 5 )
            {
              v10 = *a1;
              if ( *a1 )
              {
                v42 = v9;
                v11 = 0LL;
                v44 = 0LL;
                if ( a2 > 0 )
                {
                  v12 = a1 + 1;
                  v13 = a2 - 1;
                  v11 = 0LL;
                  v14 = 0LL;
                  while ( 1 )
                  {
                    if ( *v10 )
                    {
                      if ( *v10 == 1 )
                        v14 = v10;
                    }
                    else
                    {
                      v11 = v10;
                    }
                    if ( !v13 )
                      break;
                    v10 = *v12++;
                    --v13;
                  }
                  v44 = v14;
                }
                theDict = CFDictionaryCreateMutable(
                            kCFAllocatorDefault,
                            0LL,
                            &kCFTypeDictionaryKeyCallBacks,
                            &kCFTypeDictionaryValueCallBacks);
                if ( theDict )
                {
                  v56 = a2;
                  v39 = v11;
                  __s = a5;
                  if ( v6 && a2 > 0 )
                  {
                    while ( 1 )
                    {
                      Mutable = CFDictionaryCreateMutable(
                                  kCFAllocatorDefault,
                                  0LL,
                                  &kCFTypeDictionaryKeyCallBacks,
                                  &kCFTypeDictionaryValueCallBacks);
                      if ( Mutable )
                        break;
LABEL_36:
                      ++v6;
                      if ( !--v56 )
                        goto LABEL_37;
                    }
                    v16 = **v6;
                    if ( v16 == 1 )
                    {
                      v17 = &kBRCalibrationInfoManagerQualityCAPTKey;
                    }
                    else
                    {
                      v18 = v16 == 0;
                      v19 = 0LL;
                      if ( !v18 )
                      {
LABEL_27:
                        key = v19;
                        v20 = CFDataCreateWithBytesNoCopy(
                                kCFAllocatorDefault,
                                (const UInt8 *)*v6 + 4,
                                22LL,
                                kCFAllocatorNull);
                        value = CFDataCreateWithBytesNoCopy(
                                  kCFAllocatorDefault,
                                  (const UInt8 *)*v6 + 26,
                                  22LL,
                                  kCFAllocatorNull);
                        v51 = CFDataCreateWithBytesNoCopy(
                                kCFAllocatorDefault,
                                (const UInt8 *)*v6 + 48,
                                22LL,
                                kCFAllocatorNull);
                        v21 = CFDataCreateWithBytesNoCopy(
                                kCFAllocatorDefault,
                                (const UInt8 *)*v6 + 70,
                                22LL,
                                kCFAllocatorNull);
                        if ( v20 )
                        {
                          CFDictionarySetValue(Mutable, kBRCalibrationInfoManagerCyanKey[0], v20);
                          CFRelease(v20);
                        }
                        if ( value )
                        {
                          CFDictionarySetValue(Mutable, kBRCalibrationInfoManagerMagentaKey[0], value);
                          CFRelease(value);
                        }
                        if ( v51 )
                        {
                          CFDictionarySetValue(Mutable, kBRCalibrationInfoManagerYellowKey[0], v51);
                          CFRelease(v51);
                        }
                        if ( v21 )
                        {
                          CFDictionarySetValue(Mutable, kBRCalibrationInfoManagerBlackKey[0], v21);
                          CFRelease(v21);
                        }
                        CFDictionarySetValue(theDict, key, Mutable);
                        CFRelease(Mutable);
                        goto LABEL_36;
                      }
                      v17 = kBRCalibrationInfoManagerQuality600Key;
                    }
                    v19 = *v17;
                    goto LABEL_27;
                  }
LABEL_37:
                  v22 = v42;
                  v23 = off_100015410[v42];
                  Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, theDict);
                  CFRelease(theDict);
                  __bzero(v60, 1024LL);
                  __sprintf_chk(v60, 0, 0x400uLL, "%s/%s", __s, v23);
                  Directory = BRCalibrationInfoManagerInitWithPath(v60);
                  if ( !Directory )
                  {
                    if ( (unsigned __int8)BRCalibrationInfoManagerFileExist()
                      || (v25 = strlen(__s),
                          Directory = 1,
                          v26 = CFURLCreateFromFileSystemRepresentation(
                                  kCFAllocatorDefault,
                                  (const UInt8 *)__s,
                                  v25,
                                  1u),
                          (v27 = v26) != 0LL)
                      && (Directory = createDirectory(v26), CFRelease(v27), !Directory) )
                    {
                      v28 = (const void *)BRCalibrationInfoManagerData();
                      if ( !Copy || !v28 || (Directory = 0, !CFEqual(Copy, v28)) )
                      {
                        Directory = 1;
                        if ( v39 )
                        {
                          if ( v44 )
                          {
                            v52 = Copy;
                            keya = dword_100010210[v42];
                            allocator = dword_100010230[v42];
                            valuea = v39 + 1;
                            theDicta = (CFMutableDictionaryRef)((char *)v39 + 26);
                            v43 = v39 + 12;
                            v38 = v44 + 1;
                            v37 = (__int64)v44 + 26;
                            v36 = v44 + 12;
                            v29 = 0;
                            v40 = (__int64)v39 + 70;
                            v45 = (__int64)v44 + 70;
                            v30 = (char *)*(&off_100015440 + v22) + 28;
                            do
                            {
                              v57 = v29;
                              __bzero(v59, 1024LL);
                              __bzero(v58, 1024LL);
                              __sprintf_chk(v59, 0, 0x400uLL, "%s/%s", a4, *(const char **)(v30 - 20));
                              __sprintf_chk(v58, 0, 0x400uLL, "%s/%s", __s, *(const char **)(v30 - 12));
                              v31 = *((_DWORD *)v30 - 7);
                              v32 = *(v30 - 4);
                              v33 = *v30;
                              if ( !access(v59, 0) )
                              {
                                Directory = 1;
                                switch ( (char)v31 )
                                {
                                  case 0:
                                    v34 = BRMakeDitherCacheTableFile(
                                            (unsigned __int8)v31,
                                            valuea,
                                            v38,
                                            v32,
                                            v59,
                                            v33,
                                            v58,
                                            keya);
                                    goto LABEL_53;
                                  case 1:
                                    v34 = BRMakeDitherCacheTableFile(
                                            (unsigned __int8)v31,
                                            theDicta,
                                            v37,
                                            v32,
                                            v59,
                                            v33,
                                            v58,
                                            keya);
                                    goto LABEL_53;
                                  case 2:
                                    v34 = BRMakeDitherCacheTableFile(
                                            (unsigned __int8)v31,
                                            v43,
                                            v36,
                                            v32,
                                            v59,
                                            v33,
                                            v58,
                                            keya);
                                    goto LABEL_53;
                                  case 3:
                                    v34 = BRMakeDitherCacheTableFile(
                                            (unsigned __int8)v31,
                                            v40,
                                            v45,
                                            v32,
                                            v59,
                                            v33,
                                            v58,
                                            keya);
LABEL_53:
                                    Directory = v34;
                                    if ( v34 )
                                      goto LABEL_59;
                                    changePermissions_0(v58);
                                    break;
                                  default:
LABEL_59:
                                    Copy = v52;
                                    if ( !access(__s, 0) )
                                      Directory = removeRecursively(__s);
                                    goto LABEL_61;
                                }
                              }
                              v30 += 32;
                              v29 = v57 + 1;
                            }
                            while ( v57 + 1 < allocator );
                            Copy = v52;
                            BRCalibrationInfoManagerSetData(v52);
                            Directory = BRCalibrationInfoManagerWriteToFile();
                            if ( !Directory )
                            {
                              changePermissions_0(v60);
                              Directory = 0;
                            }
                          }
                        }
                      }
                    }
                  }
LABEL_61:
                  BRCalibrationInfoManagerDeallocate();
                  if ( Copy )
                    CFRelease(Copy);
                }
                else
                {
                  BRCalibrationInfoManagerDeallocate();
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return Directory;
}
// 100009BB9: using guessed type __int64 __fastcall removeRecursively(_QWORD);
// 10000A3FC: using guessed type __int64 __fastcall createDirectory(_QWORD);
// 10000A7F7: using guessed type __int64 BRCalibrationInfoManagerDeallocate(void);
// 10000A82A: using guessed type __int64 BRCalibrationInfoManagerWriteToFile(void);
// 10000A9D2: using guessed type __int64 BRCalibrationInfoManagerFileExist(void);
// 10000A9EE: using guessed type __int64 BRCalibrationInfoManagerData(void);
// 10000AAE1: using guessed type __int64 __fastcall BRMakeDitherCacheTableFile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);
// 1000101E0: using guessed type _DWORD dword_1000101E0[12];
// 100010210: using guessed type _DWORD dword_100010210[8];
// 100010230: using guessed type _DWORD dword_100010230[8];
// 100015410: using guessed type char *off_100015410[6];
// 100015440: using guessed type _UNKNOWN *off_100015440;
// 100016710: using guessed type __CFString *kBRCalibrationInfoManagerCyanKey[6];
// 100016718: using guessed type __CFString *kBRCalibrationInfoManagerMagentaKey[5];
// 100016720: using guessed type __CFString *kBRCalibrationInfoManagerYellowKey[4];
// 100016728: using guessed type __CFString *kBRCalibrationInfoManagerBlackKey[3];
// 100016730: using guessed type __CFString *kBRCalibrationInfoManagerQuality600Key[2];
// 100016738: using guessed type __CFString *kBRCalibrationInfoManagerQualityCAPTKey;

//----- (000000010000A3FC) ----------------------------------------------------
__int64 __fastcall createDirectory(const __CFURL *a1)
{
  unsigned int Directory; // r13d
  CFURLRef PathComponent; // rax
  CFURLRef v3; // rbx
  UInt8 buffer[1024]; // [rsp+0h] [rbp-430h] BYREF

  Directory = 1;
  if ( a1 )
  {
    __bzero(buffer, 1024LL);
    Directory = 1;
    if ( CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024LL) )
    {
      Directory = 0;
      while ( access((const char *)buffer, 0) )
      {
        if ( mkdir((const char *)buffer, 0x1FFu) )
        {
          PathComponent = CFURLCreateCopyDeletingLastPathComponent(kCFAllocatorDefault, a1);
          v3 = PathComponent;
          Directory = 1;
          if ( PathComponent )
          {
            Directory = createDirectory(PathComponent);
            CFRelease(v3);
          }
        }
        else
        {
          changePermissions_0((char *)buffer);
          Directory = 0;
        }
      }
    }
  }
  return Directory;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000A50B) ----------------------------------------------------
void __fastcall changePermissions_0(char *a1)
{
  stat v1; // [rsp+8h] [rbp-98h] BYREF

  if ( a1 && !access(a1, 0) && !stat_INODE64(a1, &v1) && getuid() == v1.st_uid )
    chmod(a1, 0x1FFu);
}

//----- (000000010000A564) ----------------------------------------------------
__int64 __fastcall BRCalibrationAutoCalibration(int **a1, int a2, _DWORD *a3, const char *a4, const char *a5)
{
  unsigned int v7; // r13d
  char v10[1024]; // [rsp+10h] [rbp-830h] BYREF
  char v11[1024]; // [rsp+410h] [rbp-430h] BYREF

  __bzero(v11, 1024LL);
  v7 = 1;
  if ( a4 && a5 && !getPrintersLUTDirPath(a5, v11) && !getCachesLUTDirPath(a5, a4, v10) )
    return (unsigned int)BRCalibrationCalibration(a1, a2, a3, v11, v10);
  return v7;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000A62C) ----------------------------------------------------
_BOOL8 __fastcall getVendorDirNameFromIconPath(char *__big, char *__dst)
{
  char *v2; // r15
  char *v3; // rax
  const char *v4; // r15
  signed __int64 v5; // rax

  __bzero(__dst, 256LL);
  v2 = strstr(__big, "/Library/Printers/");
  v3 = strstr(__big, "/Icons/");
  if ( v3 && (v4 = v2 + 18, v5 = v3 - v4, v5 <= 255) )
    return strncpy(__dst, v4, v5) == 0LL;
  else
    return 1LL;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000A6A7) ----------------------------------------------------
__int64 __fastcall BRCalibrationInfoManagerAutoCalibrationEnabled(const char *a1)
{
  __int64 result; // rax

  if ( a1 )
    LOBYTE(result) = access(a1, 0) == 0;
  else
    LOBYTE(result) = 0;
  return (unsigned __int8)result;
}

//----- (000000010000A6C5) ----------------------------------------------------
__int64 __fastcall BRCalibrationInfoManagerInitWithPath(char *__s)
{
  sData = 0LL;
  __bzero(&sCurrentFilePath, 1024LL);
  if ( !__s || strlen(__s) > 0x3FF )
    return 1LL;
  memcpy(&sCurrentFilePath, __s, 0x400uLL);
  return BRCalibrationInfoManagerReadFromFile();
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000A72A) ----------------------------------------------------
__int64 BRCalibrationInfoManagerReadFromFile()
{
  unsigned int v0; // ebx
  size_t v1; // rax
  const __CFURL *v2; // rax
  const __CFURL *v3; // r14
  int v4; // eax
  CFDictionaryRef v5; // r15
  CFDictionaryRef theDict; // [rsp+8h] [rbp-28h] BYREF
  void *value; // [rsp+10h] [rbp-20h] BYREF

  v0 = 0;
  if ( !access((const char *)&sCurrentFilePath, 0) )
  {
    value = 0LL;
    theDict = 0LL;
    v1 = strlen((const char *)&sCurrentFilePath);
    v2 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, &sCurrentFilePath, v1, 0);
    v3 = v2;
    v0 = 1;
    if ( v2 )
    {
      v4 = copyPropertyFromURL(&theDict, v2);
      v5 = theDict;
      v0 = 1;
      if ( !v4 && theDict && CFDictionaryGetValueIfPresent(theDict, CFSTR("data"), (const void **)&value) )
      {
        BRCalibrationInfoManagerSetData(value);
        v0 = 0;
      }
      CFRelease(v3);
      if ( v5 )
        CFRelease(v5);
    }
  }
  return v0;
}
// 100015650: using guessed type __CFString cfstr_Data;

//----- (000000010000A7F7) ----------------------------------------------------
__int64 BRCalibrationInfoManagerDeallocate()
{
  if ( sData )
  {
    CFRelease(sData);
    sData = 0LL;
  }
  return __bzero(&sCurrentFilePath, 1024LL);
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000A82A) ----------------------------------------------------
__int64 BRCalibrationInfoManagerWriteToFile()
{
  size_t v0; // rax
  const __CFURL *v1; // rax
  const __CFURL *v2; // r14
  unsigned int v3; // r15d
  __CFDictionary *Mutable; // r12
  const __CFData *Data; // rax
  const __CFData *v6; // rbx
  const __CFURL *v7; // rdi
  CFMutableDictionaryRef theDict; // [rsp+0h] [rbp-440h] BYREF
  SInt32 errorCode; // [rsp+Ch] [rbp-434h] BYREF
  UInt8 buffer[1024]; // [rsp+10h] [rbp-430h] BYREF

  theDict = 0LL;
  v0 = strlen((const char *)&sCurrentFilePath);
  v1 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, &sCurrentFilePath, v0, 0);
  v2 = v1;
  v3 = 1;
  if ( v1 )
  {
    copyPropertyFromURL(&theDict, v1);
    Mutable = theDict;
    if ( !theDict )
    {
      Mutable = CFDictionaryCreateMutable(
                  kCFAllocatorDefault,
                  0LL,
                  &kCFTypeDictionaryKeyCallBacks,
                  &kCFTypeDictionaryValueCallBacks);
      theDict = Mutable;
      if ( !Mutable )
      {
        v7 = v2;
        goto LABEL_13;
      }
    }
    CFDictionarySetValue(Mutable, CFSTR("data"), sData);
    errorCode = 0;
    Data = CFPropertyListCreateData(kCFAllocatorDefault, Mutable, kCFPropertyListXMLFormat_v1_0, 0LL, 0LL);
    v6 = Data;
    v3 = 1;
    if ( Data )
    {
      if ( CFURLWriteDataAndPropertiesToResource(v2, Data, 0LL, &errorCode) )
      {
        __bzero(buffer, 1024LL);
        v3 = 1;
        if ( CFURLGetFileSystemRepresentation(v2, 1u, buffer, 1024LL) )
          v3 = access((const char *)buffer, 0) != 0;
      }
      else
      {
        v3 = errorCode;
      }
      CFRelease(v6);
    }
    CFRelease(v2);
    if ( Mutable )
    {
      v7 = Mutable;
LABEL_13:
      CFRelease(v7);
    }
  }
  return v3;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);
// 100015650: using guessed type __CFString cfstr_Data;

//----- (000000010000A9D2) ----------------------------------------------------
_BOOL8 BRCalibrationInfoManagerFileExist()
{
  return access((const char *)&sCurrentFilePath, 0) == 0;
}

//----- (000000010000A9EE) ----------------------------------------------------
CFTypeRef BRCalibrationInfoManagerData()
{
  return sData;
}

//----- (000000010000A9FB) ----------------------------------------------------
void __fastcall BRCalibrationInfoManagerSetData(CFTypeRef cf)
{
  if ( sData )
    CFRelease(sData);
  sData = cf;
  if ( cf )
    CFRetain(cf);
}

//----- (000000010000AA36) ----------------------------------------------------
__int64 __fastcall copyPropertyFromURL(_QWORD *a1, const __CFURL *a2)
{
  unsigned int v2; // ebx
  CFPropertyListRef v3; // rax
  CFErrorRef error; // [rsp+0h] [rbp-30h] BYREF
  CFDataRef resourceData; // [rsp+8h] [rbp-28h] BYREF
  SInt32 errorCode[7]; // [rsp+14h] [rbp-1Ch] BYREF

  errorCode[0] = 0;
  resourceData = 0LL;
  v2 = 0;
  if ( a2 )
  {
    v2 = 0;
    if ( CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault, a2, &resourceData, 0LL, 0LL, errorCode) )
    {
      if ( errorCode[0] )
      {
        v2 = SLOWORD(errorCode[0]);
      }
      else
      {
        error = 0LL;
        v3 = CFPropertyListCreateWithData(kCFAllocatorDefault, resourceData, 2uLL, 0LL, &error);
        *a1 = v3;
        v2 = v3 == 0LL;
        if ( error )
          CFRelease(error);
      }
    }
    if ( resourceData )
      CFRelease(resourceData);
  }
  return v2;
}

//----- (000000010000AAE1) ----------------------------------------------------
__int64 __fastcall BRMakeDitherCacheTableFile(
        unsigned __int8 a1,
        unsigned __int16 *a2,
        __int16 *a3,
        unsigned __int8 a4,
        const UInt8 *a5,
        unsigned __int8 a6,
        double a7,
        __m128d a8,
        UInt8 *path,
        int a10)
{
  unsigned int v12; // r15d
  bool v13; // al
  void *v14; // r12
  OSErr v15; // ax
  int v16; // r14d
  const char *v17; // rbx
  OSErr v18; // ax
  int v19; // ebx
  OSErr v20; // ax
  int v21; // eax
  void *v22; // rax
  void *v23; // rbx
  void *v24; // r13
  int v25; // eax
  OSErr v26; // ax
  int v27; // ebx
  void *v28; // rax
  bool v29; // al
  void *v30; // rdx
  char v31; // r15
  unsigned int v32; // eax
  OSErr v33; // ax
  size_t requestCount; // [rsp+20h] [rbp-130h]
  __int16 v36; // [rsp+28h] [rbp-128h]
  __int16 v37; // [rsp+30h] [rbp-120h]
  unsigned __int8 v38; // [rsp+3Ch] [rbp-114h]
  __int16 *v39; // [rsp+40h] [rbp-110h]
  __int64 v41; // [rsp+50h] [rbp-100h]
  int buffer; // [rsp+58h] [rbp-F8h] BYREF
  char v43; // [rsp+5Ch] [rbp-F4h]
  FSIORefNum v44; // [rsp+60h] [rbp-F0h] BYREF
  FSIORefNum forkRefNum; // [rsp+64h] [rbp-ECh] BYREF
  ByteCount actualCount; // [rsp+68h] [rbp-E8h] BYREF
  int v47; // [rsp+70h] [rbp-E0h] BYREF
  __int16 v48; // [rsp+74h] [rbp-DCh]
  __int16 v49; // [rsp+76h] [rbp-DAh]
  __int16 v50; // [rsp+78h] [rbp-D8h]
  FSRef v51; // [rsp+80h] [rbp-D0h] BYREF
  FSRef ref; // [rsp+D0h] [rbp-80h] BYREF

  actualCount = 0LL;
  forkRefNum = -1;
  v44 = -1;
  v12 = 1;
  if ( a2 )
  {
    v13 = a3 == 0LL;
    if ( !a3 )
      return v13;
    v13 = a5 == 0LL;
    if ( !a5 )
      return v13;
    v13 = path == 0LL;
    if ( !path )
      return v13;
    v14 = 0LL;
    v12 = FSPathMakeRef(a5, &ref, 0LL);
    if ( !v12 )
    {
      v15 = FSOpenFork(&ref, 0LL, 0LL, 0, &forkRefNum);
      if ( v15 )
      {
        v39 = a3;
        v38 = a4;
        v12 = v15;
        v36 = 0;
        v37 = 0;
        v16 = 0;
        v17 = (const char *)path;
        goto LABEL_18;
      }
      v43 = 0;
      buffer = 0;
      v18 = FSReadFork(forkRefNum, 1u, 0LL, 4uLL, &buffer, &actualCount);
      if ( v18 )
      {
        v14 = 0LL;
        v39 = a3;
        v38 = a4;
        v12 = v18;
        v36 = 0;
        v37 = 0;
      }
      else
      {
        v19 = atoi((const char *)&buffer);
        v43 = 0;
        buffer = 0;
        v20 = FSReadFork(forkRefNum, 0, 0LL, 4uLL, &buffer, &actualCount);
        if ( !v20 )
        {
          v39 = a3;
          v38 = a4;
          v21 = atoi((const char *)&buffer);
          v36 = v21;
          v37 = v19;
          v16 = v21 * v19;
          v22 = malloc(v21 * v19);
          v23 = v22;
          v12 = 1;
          if ( v22 )
          {
            v12 = FSReadFork(forkRefNum, 0, 0LL, v16, v22, &actualCount);
            v14 = v23;
          }
          else
          {
            v14 = 0LL;
          }
          goto LABEL_17;
        }
        v14 = 0LL;
        v37 = v19;
        v39 = a3;
        v38 = a4;
        v12 = v20;
        v36 = 0;
      }
      v16 = 0;
LABEL_17:
      v17 = (const char *)path;
      FSCloseFork(forkRefNum);
LABEL_18:
      v24 = 0LL;
      if ( v12 )
        goto LABEL_43;
      if ( access(v17, 0) )
      {
        v25 = creat(v17, 0x1FFu);
        v12 = 1;
        v24 = 0LL;
        if ( v25 == -1 )
          goto LABEL_43;
        v24 = 0LL;
        if ( close(v25) == -1 )
          goto LABEL_43;
      }
      v24 = 0LL;
      v12 = FSPathMakeRef((const UInt8 *)v17, &v51, 0LL);
      if ( v12 )
        goto LABEL_43;
      v24 = 0LL;
      v26 = FSOpenFork(&v51, 0LL, 0LL, 4, &v44);
      if ( v26 )
      {
        v12 = v26;
LABEL_43:
        if ( v14 )
          free(v14);
        if ( v24 )
          free(v24);
        return v12;
      }
      v27 = v16 / 8 + ((v16 & 7) != 0);
      requestCount = v27 << 8;
      v28 = malloc(requestCount);
      v12 = 1;
      v24 = 0LL;
      if ( !v28 )
        goto LABEL_43;
      v24 = v28;
      v29 = v39 == 0LL;
      if ( !v39 || (v29 = v14 == 0LL, !v14) )
      {
        v12 = v29;
LABEL_38:
        if ( !v12 )
        {
          v47 = 1145262658;
          v48 = (unsigned __int8)(v38 + 48);
          v50 = v36;
          v49 = v37;
          v33 = FSWriteFork(v44, 1u, 0LL, 0xAuLL, &v47, &actualCount);
          v12 = v33;
          if ( !v33 && actualCount == 10 )
            v12 = FSWriteFork(v44, 1u, 10LL, requestCount, v24, &actualCount);
        }
        goto LABEL_42;
      }
      v30 = malloc(0x100uLL);
      v12 = 1;
      if ( !v30 )
      {
LABEL_42:
        FSCloseFork(v44);
        goto LABEL_43;
      }
      if ( (unsigned int)(a10 - 7) >= 3 )
      {
        if ( (unsigned int)(a10 - 5) >= 2 )
        {
          v12 = 1;
          if ( a10 != 4 )
          {
LABEL_37:
            free(v30);
            goto LABEL_38;
          }
          v31 = v38;
          v41 = (__int64)v30;
          BrMakeGammaTable4150(a2, v39, (__int64)v30, 0, 256, v38, a7, a8, a1, a6);
        }
        else
        {
          v31 = v38;
          v41 = (__int64)v30;
          BrMakeGammaTable3150(a2, v39, (__int64)v30, 0, 256, v38, a7, a8, a1, a6);
        }
      }
      else
      {
        v31 = v38;
        v41 = (__int64)v30;
        BrMakeGammaTableNoCalculateModel(a2, v39, (__int64)v30, 0, 256, v38, a7, a8, a1, a6, a10);
      }
      v38 = v31;
      v32 = BRMakeDitherCacheTableData((unsigned __int8 *)v14, v16, v31, v41, v27, (char *)v24);
      v30 = (void *)v41;
      v12 = v32;
      goto LABEL_37;
    }
  }
  return v12;
}

//----- (000000010000B087) ----------------------------------------------------
__int64 __fastcall BRMakeDitherCacheTableData(unsigned __int8 *a1, int a2, char a3, __int64 a4, int a5, char *a6)
{
  char *v10; // r8
  __int64 result; // rax
  __int64 v12; // r12
  int v13; // r9d
  char *v14; // r15
  int v15; // r14d
  int v16; // eax
  int v17; // esi
  unsigned __int8 *v18; // rdx
  int v19; // edi
  __int64 i; // rbx
  char *v21; // r15
  __int64 v22; // [rsp+0h] [rbp-50h]
  char *v23; // [rsp+8h] [rbp-48h]
  int v26; // [rsp+24h] [rbp-2Ch]

  v10 = (char *)malloc(a5 << 8);
  v23 = v10;
  result = 0xFFFFFFFFLL;
  if ( v10 )
  {
    v22 = a4;
    v26 = a5;
    v12 = 0LL;
    v13 = a2;
    do
    {
      if ( v13 > 0 )
      {
        v14 = &v10[v26 * (int)v12];
        LOBYTE(v15) = 0;
        v16 = v13;
        v17 = 0;
        v18 = a1;
        do
        {
          v19 = *v18 <= (int)v12;
          if ( a3 )
            LOBYTE(v15) = v15 + v19;
          else
            v15 = (v19 << (7 - v17)) | (unsigned __int8)v15;
          if ( v17 < 7 )
          {
            ++v17;
          }
          else
          {
            if ( a3 )
              LOBYTE(v15) = ext_ucDataCAPT[(unsigned __int8)v15];
            *v14++ = v15;
            v17 = 0;
            LOBYTE(v15) = 0;
          }
          ++v18;
          --v16;
        }
        while ( v16 );
        if ( v17 )
        {
          if ( a3 )
          {
            printf("%s Error : CAPT dither data is informal.", "MakeDitherCashData");
            v10 = v23;
            *v14 = ext_ucDataCAPT[(unsigned __int8)v15];
          }
          else
          {
            *v14 = v15;
          }
          v13 = a2;
        }
      }
      ++v12;
    }
    while ( v12 != 256 );
    for ( i = 0LL; i != 256; ++i )
    {
      v21 = v10;
      memcpy(a6, &v10[v26 * *(unsigned __int8 *)(v22 + i)], v26);
      v10 = v21;
      a6 += v26;
    }
    free(v21);
    return 0LL;
  }
  return result;
}
// 10001048C: using guessed type _BYTE ext_ucDataCAPT[12];

//----- (000000010000B200) ----------------------------------------------------
__int64 __fastcall DitheringUseDitherCashTable(
        char a1,
        __int64 a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        __int64 a8,
        _BYTE *a9)
{
  __int64 result; // rax
  int v11; // edx
  int v13; // ecx
  unsigned int v14; // edx
  int v15; // r15d
  __int64 v16; // rbx
  char v17; // r13
  signed int v18; // r12d
  unsigned int v19; // eax
  char v20; // al
  signed int v21; // [rsp+0h] [rbp-2Ch]

  v11 = a6 % a5;
  result = (unsigned int)(a6 / a5);
  if ( a7 > 0 )
  {
    v13 = a4 / 8 + ((a4 & 7) != 0);
    v14 = v13 * v11;
    v15 = 1;
    if ( !a1 )
      v15 = 7;
    v21 = v14 + v13;
    v16 = 0LL;
    v17 = 0;
    v18 = v14;
    do
    {
      v19 = *(unsigned __int8 *)(a2 + a3 * *(unsigned __int8 *)(a8 + v16) + (__int64)v18);
      if ( a1 )
      {
        v20 = v17 | v19;
        if ( v15 )
        {
          --v15;
          v17 = 16 * v20;
        }
        else
        {
          *a9++ = v20;
          v15 = 1;
          v17 = 0;
        }
        result = (unsigned int)(v18 + 1);
        if ( v18 >= v21 )
          result = v14;
        v18 = result;
      }
      else
      {
        result = ((v19 >> (7 - (int)v16 % 8)) & 1) << v15;
        v17 |= result;
        if ( v15 )
        {
          --v15;
        }
        else
        {
          *a9++ = v17;
          result = (unsigned int)(v18 + 1);
          if ( v18 >= v21 )
            result = v14;
          v15 = 7;
          v17 = 0;
          v18 = result;
        }
      }
      ++v16;
    }
    while ( a7 != (_DWORD)v16 );
  }
  return result;
}

//----- (000000010000B330) ----------------------------------------------------
__int64 __fastcall removePrefixAndSufixDoubleQuotationChar(char *__dst, size_t __n)
{
  __int64 result; // rax
  char *v3; // r12
  bool v4; // al
  __int64 v5; // r13
  _QWORD v6[2]; // [rsp+0h] [rbp-40h] BYREF

  result = __stack_chk_guard;
  if ( __dst && __n >= 3 )
  {
    v6[1] = v6;
    v3 = __dst + 1;
    v4 = *__dst == 34;
    if ( *__dst != 34 )
      v3 = __dst;
    v5 = v4 + 1LL;
    if ( __dst[__n - 1] != 34 )
      v5 = v4;
    __bzero((char *)v6 - ((__n + 15) & 0xFFFFFFFFFFFFFFF0LL), __n);
    memcpy((char *)v6 - ((__n + 15) & 0xFFFFFFFFFFFFFFF0LL), v3, __n - v5);
    memcpy(__dst, (char *)v6 - ((__n + 15) & 0xFFFFFFFFFFFFFFF0LL), __n);
    return __stack_chk_guard;
  }
  return result;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000B3EC) ----------------------------------------------------
int __fastcall printPJLCommands(const char *a1, int a2)
{
  int v2; // r14d
  const char *v3; // rbx
  int result; // eax

  v2 = a2;
  v3 = a1;
  if ( a1 && a2 )
  {
    printf("%s", "\x1B%-12345X@PJL\r\n");
    if ( a2 > 0 )
    {
      do
      {
        printf("%s", v3);
        v3 += 256;
        --v2;
      }
      while ( v2 );
    }
    printf("%s", "\x1B%-12345X\r\n");
    return fflush(__stdoutp);
  }
  return result;
}

//----- (000000010000B479) ----------------------------------------------------
CFArrayRef __fastcall copyBackChannelWithPJLCommands(char *__little, int a2, double a3)
{
  int v3; // r15d
  char *v4; // r12
  CFArrayRef result; // rax
  int v6; // r14d
  char *v7; // rbx
  __int64 v8; // r14
  int v9; // ebx
  int v10; // eax
  bool v11; // cc
  char *v12; // r14
  const char *v13; // r15
  char *v14; // rbx
  const char *v15; // rbx
  char *v16; // r12
  size_t v17; // r13
  size_t v18; // r13
  size_t v19; // rax
  CFStringRef v20; // rax
  CFStringRef v21; // rbx
  CFIndex v22; // r12
  __int64 v23; // [rsp+0h] [rbp-A90h] BYREF
  __int64 v24; // [rsp+8h] [rbp-A88h]
  char *v25; // [rsp+10h] [rbp-A80h]
  void *__dst; // [rsp+18h] [rbp-A78h]
  CFIndex capacity; // [rsp+20h] [rbp-A70h]
  __int64 v28; // [rsp+28h] [rbp-A68h]
  double v29; // [rsp+30h] [rbp-A60h]
  int v30; // [rsp+3Ch] [rbp-A54h]
  CFAllocatorRef allocator; // [rsp+40h] [rbp-A50h]
  CFMutableArrayRef theArray; // [rsp+48h] [rbp-A48h]
  double Current; // [rsp+50h] [rbp-A40h]
  CFIndex idx; // [rsp+58h] [rbp-A38h]
  char buffer[2560]; // [rsp+60h] [rbp-A30h] BYREF

  v3 = a2;
  v30 = a2;
  v4 = __little;
  v25 = __little;
  v29 = a3;
  result = 0LL;
  if ( a3 != 0.0 && __little && a2 )
  {
    v23 = (__int64)&v23;
    __dst = &v23 - 32 * (unsigned __int64)(unsigned int)a2;
    __bzero(buffer, 2560LL);
    if ( a2 > 0 )
    {
      v6 = a2;
      v7 = (char *)__dst;
      do
      {
        __bzero(v7, 256LL);
        v7 += 256;
        --v6;
      }
      while ( v6 );
    }
    Current = CFAbsoluteTimeGetCurrent();
    allocator = kCFAllocatorDefault;
    capacity = a2;
    v24 = 0LL;
    LODWORD(v8) = 0;
    do
    {
      do
      {
        v9 = cupsBackChannelRead(&buffer[(int)v8], 2559 - (int)v8, 0.3);
        v10 = 0;
        if ( v9 >= 0 )
          v10 = v9;
        v8 = (unsigned int)(v10 + v8);
      }
      while ( CFAbsoluteTimeGetCurrent() - Current <= 0.3 && v9 > 0 );
      if ( (int)v8 > 0 )
      {
        theArray = CFArrayCreateMutable(allocator, capacity, &kCFTypeArrayCallBacks);
        if ( theArray )
        {
          v28 = v8;
          v11 = v3 <= 0;
          v12 = (char *)__dst;
          v13 = v4;
          idx = 0LL;
          if ( !v11 )
          {
            while ( 1 )
            {
              v14 = strstr(buffer, v13);
              if ( !v14 )
                break;
              v15 = &v14[strlen(v13)];
              v16 = strstr(v15, kPJLCommandResponseFooder);
              if ( !v16 )
                break;
              v17 = strlen(v15);
              v18 = v17 - strlen(v16);
              if ( !v18 )
                break;
              if ( v18 > 0xFF )
                break;
              memcpy(v12, v15, v18);
              v19 = strlen(v12);
              removePrefixAndSufixDoubleQuotationChar(v12, v19);
              v20 = CFStringCreateWithCString(allocator, v12, 0x8000100u);
              v21 = v20;
              if ( !v20 )
                break;
              v22 = idx;
              CFArraySetValueAtIndex(theArray, idx, v20);
              CFRelease(v21);
              idx = v22 + 1;
              v13 += 256;
              v12 += 256;
              if ( (int)v22 + 1 >= v30 )
                return CFArrayCreateCopy(allocator, theArray);
            }
          }
          CFRelease(theArray);
          v3 = v30;
          v4 = v25;
          LODWORD(v8) = v28;
        }
      }
    }
    while ( CFAbsoluteTimeGetCurrent() - Current <= v29 );
    return (CFArrayRef)v24;
  }
  return result;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000B788) ----------------------------------------------------
CFArrayRef __fastcall copySideChannelSNMPDataWithOIDs(char *oid, int a2, double a3)
{
  const char *v3; // r12
  CFArrayRef result; // rax
  CFIndex v5; // r15
  CFStringRef v6; // rax
  CFStringRef v7; // r13
  __int64 v8; // [rsp+8h] [rbp-A58h]
  const __CFArray *theArray; // [rsp+10h] [rbp-A50h]
  int datalen; // [rsp+2Ch] [rbp-A34h] BYREF
  char data[2560]; // [rsp+30h] [rbp-A30h] BYREF

  v3 = oid;
  result = 0LL;
  if ( a3 != 0.0 && oid && a2 )
  {
    theArray = CFArrayCreateMutable(kCFAllocatorDefault, a2, &kCFTypeArrayCallBacks);
    v8 = 0LL;
    if ( theArray )
    {
      v5 = 0LL;
      if ( a2 <= 0 )
      {
        return CFArrayCreateCopy(kCFAllocatorDefault, theArray);
      }
      else
      {
        v8 = 0LL;
        while ( 1 )
        {
          datalen = 2560;
          if ( cupsSideChannelSNMPGet(v3, data, &datalen, a3) != CUPS_SC_STATUS_OK || !datalen )
            break;
          v6 = CFStringCreateWithCString(kCFAllocatorDefault, data, 0x8000100u);
          v7 = v6;
          if ( v6 )
          {
            CFArrayInsertValueAtIndex(theArray, v5, v6);
            CFRelease(v7);
          }
          ++v5;
          v3 += 256;
          if ( (int)v5 >= a2 )
            return CFArrayCreateCopy(kCFAllocatorDefault, theArray);
        }
      }
    }
    return (CFArrayRef)v8;
  }
  return result;
}

//----- (000000010000B8F6) ----------------------------------------------------
CFArrayRef __fastcall copyFactorWithFactorOIDHeader(const char *a1, const __CFArray *a2, int a3, double a4)
{
  CFArrayRef result; // rax
  __int64 v5; // rcx
  char *v6; // r14
  CFIndex v7; // r12
  __int64 v8; // r15
  const __CFString *ValueAtIndex; // rax
  SInt32 IntValue; // eax
  _QWORD v11[2]; // [rsp+0h] [rbp-60h] BYREF
  double v12; // [rsp+10h] [rbp-50h]
  int v13; // [rsp+1Ch] [rbp-44h]
  char *oid; // [rsp+20h] [rbp-40h]
  const char *v15; // [rsp+28h] [rbp-38h]

  result = 0LL;
  if ( a1 && a2 && a3 && a4 != 0.0 )
  {
    v12 = a4;
    v11[1] = v11;
    v5 = (unsigned int)a3;
    oid = (char *)&v11[-32 * (unsigned __int64)(unsigned int)a3];
    v13 = a3;
    v15 = a1;
    if ( a3 > 0 )
    {
      v6 = oid;
      v7 = 0LL;
      do
      {
        v8 = v5;
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v7);
        IntValue = CFStringGetIntValue(ValueAtIndex);
        __sprintf_chk(v6, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", v15, IntValue);
        v5 = v8;
        ++v7;
        v6 += 256;
      }
      while ( (_DWORD)v8 != (_DWORD)v7 );
    }
    return copySideChannelSNMPDataWithOIDs(oid, v13, v12);
  }
  return result;
}

//----- (000000010000B9FB) ----------------------------------------------------
CFArrayRef __fastcall copyIndexesWithIndexOIDHeader(const char *a1, int a2, double a3)
{
  CFArrayRef result; // rax
  int v4; // ebx
  char *v5; // r15
  _QWORD v6[2]; // [rsp+0h] [rbp-50h] BYREF
  double v7; // [rsp+10h] [rbp-40h]
  char *oid; // [rsp+18h] [rbp-38h]

  result = 0LL;
  if ( a1 && a2 && a3 != 0.0 )
  {
    v7 = a3;
    v6[1] = v6;
    oid = (char *)&v6[-32 * (unsigned __int64)(unsigned int)a2];
    if ( a2 > 0 )
    {
      v4 = 0;
      v5 = oid;
      do
      {
        __sprintf_chk(v5, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", a1, ++v4);
        v5 += 256;
      }
      while ( a2 != v4 );
    }
    return copySideChannelSNMPDataWithOIDs(oid, a2, v7);
  }
  return result;
}

//----- (000000010000BAD1) ----------------------------------------------------
__int64 __fastcall getCountWithCountOID(const char *a1, double a2)
{
  unsigned int IntValue; // r14d
  const __CFArray *v3; // rax
  const __CFArray *v4; // rbx
  const __CFString *ValueAtIndex; // rax
  char oid[264]; // [rsp+10h] [rbp-130h] BYREF

  IntValue = 0;
  if ( a1 )
  {
    if ( a2 != 0.0 )
    {
      IntValue = 0;
      __sprintf_chk(oid, 0, 0x100uLL, "%s", a1);
      v3 = copySideChannelSNMPDataWithOIDs(oid, 1, a2);
      v4 = v3;
      if ( v3 )
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v3, 0LL);
        IntValue = CFStringGetIntValue(ValueAtIndex);
        CFRelease(v4);
      }
    }
  }
  return IntValue;
}

//----- (000000010000BB90) ----------------------------------------------------
CFArrayRef __fastcall copyDatasWithPJLCommands(char *__little, int a2, double a3)
{
  if ( !__little || !a2 || a3 == 0.0 )
    return 0LL;
  printPJLCommands(__little, a2);
  return copyBackChannelWithPJLCommands(__little, a2, a3);
}

//----- (000000010000BBE9) ----------------------------------------------------
CFStringRef __fastcall copyDataWithPJLCommand(const char *a1, double a2)
{
  CFStringRef Copy; // r14
  const __CFArray *v3; // rax
  const __CFArray *v4; // rbx
  const __CFString *ValueAtIndex; // rax
  double v7; // [rsp+0h] [rbp-30h] BYREF

  Copy = 0LL;
  if ( a1 )
  {
    if ( a2 != 0.0 )
    {
      Copy = 0LL;
      v7 = a2;
      __sprintf_chk((char *)&v7 - 256, 0, 0x100uLL, "%s", a1);
      printPJLCommands((const char *)&v7 - 256, 1);
      v3 = copyBackChannelWithPJLCommands((char *)&v7 - 256, 1, v7);
      v4 = v3;
      if ( v3 )
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v3, 0LL);
        Copy = CFStringCreateCopy(kCFAllocatorDefault, ValueAtIndex);
        CFRelease(v4);
      }
    }
  }
  return Copy;
}

//----- (000000010000BCC0) ----------------------------------------------------
__int64 __fastcall copyParametersWithOIDs(char *a1, char a2, double a3)
{
  if ( a1 && a2 && a3 != 0.0 )
    return copySideChannelSNMPDataWithOIDs(a1);
  else
    return 0LL;
}

//----- (000000010000BCE7) ----------------------------------------------------
CFArrayRef __fastcall copyIndexesWithCountOID(const char *a1, const char *a2, double a3)
{
  int CountWithCountOID; // eax

  if ( a1 && a2 && a3 != 0.0 && (CountWithCountOID = getCountWithCountOID(a1, a3)) != 0 )
    return copyIndexesWithIndexOIDHeader(a2, CountWithCountOID, a3);
  else
    return 0LL;
}

//----- (000000010000BD31) ----------------------------------------------------
CFArrayRef __fastcall copyFactorWithCountOID(const char *a1, const char *a2, const char *a3, double a4)
{
  int CountWithCountOID; // eax
  int v6; // r15d
  const __CFArray *v7; // rax
  const __CFArray *v8; // rbx
  CFArrayRef v9; // r14

  if ( !a1 )
    return 0LL;
  if ( !a2 )
    return 0LL;
  if ( !a3 )
    return 0LL;
  if ( a4 == 0.0 )
    return 0LL;
  CountWithCountOID = getCountWithCountOID(a1, a4);
  v6 = CountWithCountOID;
  if ( !CountWithCountOID )
    return 0LL;
  v7 = copyIndexesWithIndexOIDHeader(a2, CountWithCountOID, a4);
  v8 = v7;
  if ( !v7 )
    return 0LL;
  v9 = copyFactorWithFactorOIDHeader(a3, v7, v6, a4);
  CFRelease(v8);
  return v9;
}

//----- (000000010000BDB5) ----------------------------------------------------
_BOOL8 __fastcall getVendorFolderNameWithIconPath(char *__big, char *__dst, int a3)
{
  signed __int64 v3; // r15
  char *v4; // r12
  char *v5; // rax
  const char *v6; // r12
  signed __int64 v7; // rax

  v3 = a3;
  __bzero(__dst, a3);
  v4 = strstr(__big, "/Library/Printers/");
  v5 = strstr(__big, "/Icons/");
  if ( v5 && (v6 = v4 + 18, v7 = v5 - v6, v3 >= v7) )
    return strncpy(__dst, v6, v7) == 0LL;
  else
    return 1LL;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000BE2D) ----------------------------------------------------
__int64 __fastcall getCachesLUTFolderPath(char *a1, int a2)
{
  unsigned int v2; // r14d
  char *v3; // r15
  char *v4; // rax
  ppd_file_t *v5; // rax
  ppd_attr_t *Attr; // r13
  ppd_file_t *ppd; // [rsp+8h] [rbp-438h]
  char __dst[1024]; // [rsp+10h] [rbp-430h] BYREF

  v2 = 1;
  if ( a1 )
  {
    if ( a2 )
    {
      v3 = getenv("PRINTER");
      v4 = getenv("PPD");
      if ( v3 )
      {
        if ( v4 )
        {
          v5 = ppdOpenFile(v4);
          if ( v5 )
          {
            ppd = v5;
            Attr = ppdFindAttr(v5, "APPrinterIconPath", 0LL);
            v2 = 1;
            if ( Attr )
            {
              __bzero(__dst, 1024LL);
              v2 = 1;
              if ( !getVendorFolderNameWithIconPath(Attr->value, __dst, 1024) )
              {
                v2 = 0;
                __sprintf_chk(a1, 0, 0xFFFFFFFFFFFFFFFFLL, "/Library/Caches/%s/%s/LUT", __dst, v3);
              }
            }
            ppdClose(ppd);
          }
        }
      }
    }
  }
  return v2;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000BF56) ----------------------------------------------------
CFDataRef __fastcall copyDataWithFilePath(char *__filename)
{
  CFDataRef v1; // r14
  FILE *v2; // r15
  CFIndex v3; // rbx
  int v4; // eax
  UInt8 bytes[2056]; // [rsp+0h] [rbp-830h] BYREF

  v1 = 0LL;
  if ( __filename )
  {
    __bzero(bytes, 2048LL);
    v2 = fopen(__filename, "r");
    v3 = 0LL;
    v1 = 0LL;
    if ( v2 )
    {
      v1 = 0LL;
      while ( 1 )
      {
        v4 = getc(v2);
        if ( v4 == -1 )
          break;
        bytes[v3++] = v4;
        if ( (int)v3 >= 2048 )
          goto LABEL_8;
      }
      v1 = CFDataCreate(kCFAllocatorDefault, bytes, v3);
LABEL_8:
      fclose(v2);
    }
  }
  return v1;
}
// 10000BFE3: conditional instruction was optimized away because ebx.4<800
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000C027) ----------------------------------------------------
CFDictionaryRef copyRetriveDataCheckSumFileDatas()
{
  CFDictionaryRef v0; // rbx
  CFDataRef v1; // rax
  CFDataRef v2; // r14
  void *values; // [rsp+0h] [rbp-C40h] BYREF
  void *keys; // [rsp+8h] [rbp-C38h] BYREF
  char __filename[1024]; // [rsp+10h] [rbp-C30h] BYREF
  char v7[1024]; // [rsp+410h] [rbp-830h] BYREF
  char v8[1032]; // [rsp+810h] [rbp-430h] BYREF

  v0 = 0LL;
  if ( !(unsigned int)getCachesLUTFolderPath(v8, 1024) )
  {
    if ( (unsigned int)(*(&gModelInfo + 1) - 14) > 2 )
      __sprintf_chk(v7, 0, 0x400uLL, "%s%s", "brheadparas", ".bin");
    else
      __sprintf_chk(v7, 0, 0x400uLL, "%s_12%s", "brheadparas", ".bin");
    v0 = 0LL;
    __sprintf_chk(__filename, 0, 0x400uLL, "%s/%s", v8, v7);
    v1 = copyDataWithFilePath(__filename);
    v2 = v1;
    if ( v1 )
    {
      values = v1;
      keys = (void *)CFStringCreateWithCString(kCFAllocatorDefault, "brheadparas", 0x8000100u);
      v0 = 0LL;
      if ( keys )
      {
        v0 = CFDictionaryCreate(
               kCFAllocatorDefault,
               (const void **)&keys,
               (const void **)&values,
               1LL,
               &kCFTypeDictionaryKeyCallBacks,
               &kCFTypeDictionaryValueCallBacks);
        CFRelease(keys);
      }
      CFRelease(v2);
    }
  }
  return v0;
}
// 100015D50: using guessed type int gModelInfo;

//----- (000000010000C17E) ----------------------------------------------------
__int64 __fastcall saveRetriveDataFileWithDict(CFDictionaryRef theDict)
{
  __int64 result; // rax
  CFIndex Count; // rax
  const void **v3; // rbx
  __int64 v4; // r12
  char *v5; // r13
  int CachesLUTFolderPath; // eax
  char *p_buffer; // rax
  __int64 v8; // r14
  char *v9; // r12
  char *v10; // r15
  CFDataRef *v11; // r15
  char v12; // r14
  __int64 v13; // r12
  const char *v14; // rbx
  __int64 v15; // rbx
  const void **v16; // [rsp+10h] [rbp-850h] BYREF
  __int64 v17; // [rsp+18h] [rbp-848h]
  const void ***v18; // [rsp+20h] [rbp-840h]
  unsigned int v19; // [rsp+2Ch] [rbp-834h]
  char buffer; // [rsp+30h] [rbp-830h] BYREF
  char v21[1024]; // [rsp+430h] [rbp-430h] BYREF

  result = 1LL;
  if ( theDict )
  {
    Count = CFDictionaryGetCount(theDict);
    v18 = &v16;
    v3 = (const void **)((char *)&v16 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL));
    v4 = Count;
    CFDictionaryGetKeysAndValues(theDict, v3, v3);
    v5 = (char *)&(&v16)[-128 * v4];
    CachesLUTFolderPath = getCachesLUTFolderPath(v21);
    v19 = 1;
    if ( !CachesLUTFolderPath && !(unsigned int)createCachesDirectory(v21, 1024LL) && v4 > 0 )
    {
      v16 = v3;
      p_buffer = &buffer;
      v8 = v4;
      v17 = v4;
      v9 = (char *)&(&v16)[-128 * v4];
      do
      {
        v10 = p_buffer;
        CFStringGetCString((CFStringRef)*v3, p_buffer, 1024LL, 0x8000100u);
        if ( (unsigned int)(*(&gModelInfo + 1) - 14) > 2 )
          __sprintf_chk(v9, 0, 0xFFFFFFFFFFFFFFFFLL, "%s/%s%s", v21, v10, ".bin");
        else
          __sprintf_chk(v9, 0, 0xFFFFFFFFFFFFFFFFLL, "%s/%s_12%s", v21, v10, ".bin");
        v9 += 1024;
        ++v3;
        --v8;
        p_buffer = v10;
      }
      while ( v8 );
      v11 = (CFDataRef *)v16;
      if ( v17 > 0 )
      {
        v12 = 1;
        v13 = v17;
        v14 = v5;
        do
        {
          if ( !access(v14, 0) && access(v14, 2) )
            v12 = 0;
          v14 += 1024;
          --v13;
        }
        while ( v13 );
        v15 = v17;
        v19 = 1;
        if ( v12 == 1 && v17 > 0 )
        {
          do
          {
            if ( !(unsigned int)saveFileWithData(*v11, v5) )
            {
              changePermissions(v5);
              v19 = 0;
            }
            v5 += 1024;
            ++v11;
            --v15;
          }
          while ( v15 );
        }
      }
    }
    return v19;
  }
  return result;
}
// 100007168: using guessed type __int64 __fastcall createCachesDirectory(_QWORD, _QWORD);
// 100015D50: using guessed type int gModelInfo;

//----- (000000010000C3E1) ----------------------------------------------------
_BOOL8 __fastcall saveRetriveDataFileWithCheckSumAndParameters(CFDictionaryRef theDict, CFDictionaryRef a2)
{
  _BOOL4 v2; // r12d
  __CFDictionary *MutableCopy; // r14
  CFIndex Count; // r12
  const void **v5; // r13
  const void **v6; // rbx
  _QWORD v8[2]; // [rsp+0h] [rbp-40h] BYREF

  v2 = 1;
  if ( theDict )
  {
    if ( a2 )
    {
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, a2);
      if ( MutableCopy )
      {
        Count = CFDictionaryGetCount(theDict);
        v8[1] = v8;
        v5 = (const void **)((char *)v8 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL));
        v6 = v5;
        CFDictionaryGetKeysAndValues(theDict, v5, v5);
        if ( Count > 0 )
        {
          do
          {
            CFDictionaryAddValue(MutableCopy, *v5++, *v6++);
            --Count;
          }
          while ( Count );
        }
        v2 = saveRetriveDataFileWithDict(MutableCopy) != 0;
        CFRelease(MutableCopy);
      }
    }
  }
  return v2;
}

//----- (000000010000C4DE) ----------------------------------------------------
__int64 __fastcall checkUpdate(double a1)
{
  unsigned __int8 v1; // bl
  CFDictionaryRef v2; // r14
  const __CFDictionary *v3; // rax
  const __CFDictionary *v4; // r15
  CFDictionaryRef v5; // rax
  CFDictionaryRef v6; // r12

  v1 = 1;
  if ( *(&gModelInfo + 1) != 14 )
  {
    v2 = copyRetriveDataCheckSumFileDatas();
    if ( v2 )
    {
      v3 = copyRetriveDataCheckSumParameters(a1);
      v4 = v3;
      if ( v3 )
      {
        v5 = copyBinaryParametersWithHexStringParameters(v3);
        v6 = v5;
        if ( v5 )
        {
          v1 = isNewParameters(v2, v5);
          CFRelease(v6);
        }
        else
        {
          v1 = 0;
        }
        CFRelease(v4);
      }
      else
      {
        v1 = 0;
      }
      CFRelease(v2);
    }
  }
  return v1;
}
// 100015D50: using guessed type int gModelInfo;

//----- (000000010000C56D) ----------------------------------------------------
__int64 __fastcall updateData(double a1)
{
  const __CFDictionary *v1; // rax
  const __CFDictionary *v2; // r15
  unsigned int v3; // ebx
  const __CFDictionary *v4; // r14
  const __CFDictionary *v5; // rax
  const __CFDictionary *v6; // r12
  const __CFDictionary *v7; // rax
  const __CFDictionary *v8; // r13

  v1 = copyRetriveDataCheckSumParameters(a1);
  v2 = v1;
  v3 = 3;
  if ( v1 )
  {
    v4 = copyBinaryParametersWithHexStringParameters(v1);
    v3 = 4;
    if ( v4 )
    {
      v5 = copyRetriveDataParameters(a1);
      v6 = v5;
      v3 = 3;
      if ( v5 )
      {
        v7 = copyTrimmedBinaryParametersWithHexStringParameters(v5);
        v8 = v7;
        v3 = 4;
        if ( v7 )
        {
          v3 = 3 * saveRetriveDataFileWithCheckSumAndParameters(v4, v7);
          CFRelease(v8);
        }
        CFRelease(v6);
      }
      CFRelease(v4);
    }
    CFRelease(v2);
  }
  return v3;
}

//----- (000000010000C61A) ----------------------------------------------------
__int64 __fastcall executeRetriveData(int a1)
{
  if ( a1 == 1 && !(unsigned __int8)checkUpdate(5.0) )
    return 0LL;
  else
    return updateData(5.0);
}

//----- (000000010000C646) ----------------------------------------------------
CFDataRef __fastcall copyBinaryDataWithHexStringParameter(const __CFArray *a1)
{
  CFDataRef Copy; // r14
  char *v2; // rbx
  const UInt8 *v3; // r13
  const __CFArray *v4; // r14
  CFIndex v5; // r12
  CFIndex v6; // r15
  const __CFString *ValueAtIndex; // r14
  CFIndex i; // r15
  char v9; // al
  char v10; // al
  unsigned int v11; // ecx
  UInt8 v12; // al
  char v13; // cl
  CFMutableDataRef v14; // rbx
  _QWORD v16[2]; // [rsp+0h] [rbp-70h] BYREF
  CFAllocatorRef allocator; // [rsp+10h] [rbp-60h]
  __int64 v18; // [rsp+18h] [rbp-58h]
  CFIndex bufferSize; // [rsp+20h] [rbp-50h]
  CFMutableDataRef theData; // [rsp+28h] [rbp-48h]
  CFArrayRef theArray; // [rsp+30h] [rbp-40h]
  CFIndex Length; // [rsp+38h] [rbp-38h]

  theArray = a1;
  Copy = 0LL;
  if ( a1 )
  {
    bufferSize = (unsigned int)(kMIBResponseMaxLength + 1);
    v2 = (char *)v16 - ((bufferSize + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v18 = (unsigned int)(kMIBResponseMaxLength / 2 + 1);
    v3 = (const UInt8 *)v16 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    allocator = kCFAllocatorDefault;
    Copy = 0LL;
    theData = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
    if ( theData )
    {
      v16[1] = v16;
      v4 = theArray;
      if ( CFArrayGetCount(theArray) > 0 )
      {
        v5 = 0LL;
        do
        {
          v6 = bufferSize;
          __bzero(v2, bufferSize);
          __bzero(v3, v18);
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, v5);
          CFStringGetCString(ValueAtIndex, v2, v6, 0x8000100u);
          Length = CFStringGetLength(ValueAtIndex);
          for ( i = 0LL; i < CFStringGetLength(ValueAtIndex); i += 2LL )
          {
            v9 = v2[i];
            if ( (unsigned __int8)(v9 - 48) > 9u )
            {
              if ( (unsigned __int8)(v9 - 65) > 5u )
              {
                v11 = (unsigned __int8)(v9 - 97);
                v10 = v9 - 87;
                if ( v11 >= 6 )
                  v10 = 0;
              }
              else
              {
                v10 = v9 - 55;
              }
            }
            else
            {
              v10 = v9 - 48;
            }
            v12 = 16 * v10;
            v13 = v2[i + 1];
            if ( (unsigned __int8)(v13 - 48) > 9u )
            {
              if ( (unsigned __int8)(v13 - 65) > 5u )
              {
                if ( (unsigned __int8)(v13 - 97) <= 5u )
                  v12 = v12 + v13 - 87;
              }
              else
              {
                v12 = v12 + v13 - 55;
              }
            }
            else
            {
              v12 = v12 + v13 - 48;
            }
            v3[(int)i / 2] = v12;
          }
          CFDataAppendBytes(theData, v3, (int)Length / 2);
          ++v5;
          v4 = theArray;
        }
        while ( v5 < CFArrayGetCount(theArray) );
      }
      v14 = theData;
      Copy = CFDataCreateCopy(allocator, theData);
      CFRelease(v14);
    }
  }
  return Copy;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000C886) ----------------------------------------------------
CFDataRef __fastcall copyTrimmedBinaryDataWithHexStringParameter(CFArrayRef theArray)
{
  CFDataRef Copy; // r15
  char *v2; // r14
  const UInt8 *v3; // r13
  CFIndex v4; // rbx
  const __CFArray *v5; // r15
  CFIndex v6; // r12
  const __CFString *ValueAtIndex; // r15
  int Length; // ebx
  CFIndex i; // r12
  char v10; // al
  char v11; // al
  unsigned int v12; // ecx
  UInt8 v13; // al
  char v14; // cl
  int v15; // eax
  int v16; // ecx
  int v17; // edx
  const UInt8 *v18; // rsi
  const __CFArray *v19; // r12
  __int64 v21; // [rsp+0h] [rbp-70h] BYREF
  CFAllocatorRef allocator; // [rsp+8h] [rbp-68h]
  __int64 *v23; // [rsp+10h] [rbp-60h]
  __int64 v24; // [rsp+18h] [rbp-58h]
  CFIndex bufferSize; // [rsp+20h] [rbp-50h]
  CFMutableDataRef theData; // [rsp+28h] [rbp-48h]
  CFArrayRef theArraya; // [rsp+30h] [rbp-40h]
  CFIndex v28; // [rsp+38h] [rbp-38h]

  theArraya = theArray;
  Copy = 0LL;
  if ( theArray )
  {
    v23 = &v21;
    bufferSize = (unsigned int)(kMIBResponseMaxLength + 1);
    v2 = (char *)&v21 - ((bufferSize + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v24 = (unsigned int)(kMIBResponseMaxLength / 2 + 1);
    v3 = (const UInt8 *)&v21 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    allocator = kCFAllocatorDefault;
    Copy = 0LL;
    theData = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
    if ( theData )
    {
      Copy = 0LL;
      if ( CFArrayGetCount(theArray) > 0 )
      {
        v4 = 0LL;
        v5 = theArray;
        while ( 1 )
        {
          v28 = v4;
          v6 = bufferSize;
          __bzero(v2, bufferSize);
          __bzero(v3, v24);
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, v4);
          CFStringGetCString(ValueAtIndex, v2, v6, 0x8000100u);
          Length = CFStringGetLength(ValueAtIndex);
          for ( i = 0LL; i < CFStringGetLength(ValueAtIndex); i += 2LL )
          {
            v10 = v2[i];
            if ( (unsigned __int8)(v10 - 48) > 9u )
            {
              if ( (unsigned __int8)(v10 - 65) > 5u )
              {
                v12 = (unsigned __int8)(v10 - 97);
                v11 = v10 - 87;
                if ( v12 >= 6 )
                  v11 = 0;
              }
              else
              {
                v11 = v10 - 55;
              }
            }
            else
            {
              v11 = v10 - 48;
            }
            v13 = 16 * v11;
            v14 = v2[i + 1];
            if ( (unsigned __int8)(v14 - 48) > 9u )
            {
              if ( (unsigned __int8)(v14 - 65) > 5u )
              {
                if ( (unsigned __int8)(v14 - 97) <= 5u )
                  v13 = v13 + v14 - 87;
              }
              else
              {
                v13 = v13 + v14 - 55;
              }
            }
            else
            {
              v13 = v13 + v14 - 48;
            }
            v3[(int)i / 2] = v13;
          }
          v15 = Length / 2 - 1;
          v16 = 0;
          if ( v15 > 0 )
          {
            LOBYTE(v16) = 0;
            v17 = Length / 2 - 1;
            v18 = v3;
            do
            {
              v16 = (unsigned __int8)(v16 + *v18++);
              --v17;
            }
            while ( v17 );
          }
          Copy = 0LL;
          v19 = theArraya;
          if ( v16 != v3[v15] )
            break;
          CFDataAppendBytes(theData, v3, v15);
          v4 = v28 + 1;
          v5 = v19;
          if ( v4 >= CFArrayGetCount(v19) )
          {
            Copy = CFDataCreateCopy(allocator, theData);
            break;
          }
        }
      }
      CFRelease(theData);
    }
  }
  return Copy;
}
// 10000FA06: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (000000010000CAFD) ----------------------------------------------------
CFArrayRef __fastcall copyHeadAllTableFactorsWithPJL(double a1)
{
  CFArrayRef Copy; // r15
  const __CFString *v2; // rax
  const __CFString *v3; // rbx
  const __CFString *v4; // rdi
  int v5; // ebx
  CFIndex v6; // rcx
  CFIndex v7; // r15
  char *v8; // rbx
  const __CFString *v9; // rax
  const __CFString *v10; // rbx
  __int64 v11; // r15
  SInt32 v12; // eax
  int v13; // ebx
  char *v14; // r12
  int v15; // r14d
  const __CFArray *v16; // rax
  const __CFArray *v17; // r14
  CFIndex Count; // rax
  CFRange v19; // rdx
  char *v20; // rbx
  const __CFString *v21; // rax
  CFTypeRef v22; // rbx
  __int64 v23; // r12
  SInt32 v24; // eax
  int v25; // ecx
  int v26; // ebx
  char *v27; // r12
  int v28; // r15d
  const __CFArray *v29; // rax
  const __CFArray *v30; // rbx
  CFIndex v31; // rax
  CFRange v32; // rdx
  char *v33; // rbx
  const __CFString *v34; // rax
  const __CFString *v35; // rbx
  SInt32 v36; // eax
  int v37; // ecx
  int v38; // r13d
  char *v39; // r12
  int v40; // r14d
  const __CFArray *v41; // rax
  const __CFArray *v42; // rbx
  CFIndex v43; // rax
  CFRange v44; // rdx
  char *v45; // rbx
  const __CFString *v46; // rax
  const __CFString *v47; // rbx
  SInt32 v48; // eax
  int v49; // r12d
  char *v50; // r13
  int v51; // r15d
  const __CFArray *v52; // rax
  const __CFArray *v53; // rbx
  int v54; // r15d
  CFIndex v55; // rax
  CFRange v56; // rdx
  CFMutableArrayRef v57; // rbx
  CFMutableArrayRef v58; // rbx
  _QWORD v60[6]; // [rsp+20h] [rbp-D0h] BYREF
  SInt32 IntValue; // [rsp+54h] [rbp-9Ch]
  CFMutableArrayRef Mutable; // [rsp+58h] [rbp-98h]
  char *__little; // [rsp+60h] [rbp-90h]
  _QWORD *v64; // [rsp+68h] [rbp-88h]
  CFTypeRef v65; // [rsp+70h] [rbp-80h]
  CFAllocatorRef allocator; // [rsp+78h] [rbp-78h]
  const __CFString *v67; // [rsp+80h] [rbp-70h]
  CFIndex idx; // [rsp+88h] [rbp-68h]
  CFMutableArrayRef theArray; // [rsp+90h] [rbp-60h]
  char *v70; // [rsp+98h] [rbp-58h]
  double v71; // [rsp+A0h] [rbp-50h]
  CFIndex v72; // [rsp+A8h] [rbp-48h]
  SInt32 v73; // [rsp+B0h] [rbp-40h]
  __int64 v74; // [rsp+B8h] [rbp-38h]

  Copy = 0LL;
  if ( a1 == 0.0 )
    return Copy;
  v71 = a1;
  v2 = copyDataWithPJLCommand("@PJL INFO TABLENUM\r\n", a1);
  v3 = v2;
  Copy = 0LL;
  if ( !v2 )
    return Copy;
  IntValue = CFStringGetIntValue(v2);
  v4 = v3;
  v5 = IntValue;
  CFRelease(v4);
  Copy = 0LL;
  if ( !IntValue )
    return Copy;
  v60[5] = v60;
  v70 = (char *)v60 - ((kPJLCommandMaxLength + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  allocator = kCFAllocatorDefault;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, IntValue, &kCFTypeArrayCallBacks);
  Copy = 0LL;
  if ( !Mutable )
    return Copy;
  v74 = kPJLCommandMaxLength;
  if ( v5 <= 0 )
  {
LABEL_40:
    v58 = Mutable;
    Copy = CFArrayCreateCopy(allocator, Mutable);
    goto LABEL_43;
  }
  v6 = 0LL;
  while ( 1 )
  {
    v7 = v6;
    idx = v6;
    theArray = CFArrayCreateMutable(allocator, 0LL, &kCFTypeArrayCallBacks);
    v6 = v7 + 1;
    if ( !theArray )
      goto LABEL_39;
    v72 = v7 + 1;
    v8 = v70;
    __sprintf_chk(v70, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s%d%s", "@PJL INFO ", "K", v7 + 1, "PARAMNUM\r\n");
    v9 = copyDataWithPJLCommand(v8, v71);
    v10 = v9;
    LODWORD(v65) = 1;
    v11 = 1LL;
    if ( v9 )
    {
      v12 = CFStringGetIntValue(v9);
      v11 = 1LL;
      if ( v12 )
      {
        v67 = v10;
        v64 = v60;
        v73 = v12;
        __little = (char *)v60 - ((v74 * (unsigned int)v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v13 = 0;
        v14 = __little;
        v15 = v72;
        if ( v12 > 0 )
        {
          do
          {
            __sprintf_chk(
              v14,
              0,
              0xFFFFFFFFFFFFFFFFLL,
              "%s%s%d%s%d%s",
              "@PJL DINQUIRE ",
              "K",
              v15,
              "PARAM",
              v13,
              "\r\n");
            v14 += v74;
            ++v13;
          }
          while ( v73 != v13 );
        }
        v16 = copyDatasWithPJLCommands(__little, v73, v71);
        v17 = v16;
        v11 = 1LL;
        v10 = v67;
        if ( v16 )
        {
          Count = CFArrayGetCount(v16);
          v11 = 0LL;
          v19.location = 0LL;
          v19.length = Count;
          CFArrayAppendArray(theArray, v17, v19);
          CFRelease(v17);
        }
      }
      CFRelease(v10);
    }
    v67 = (const __CFString *)v11;
    v20 = v70;
    __sprintf_chk(v70, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s%d%s", "@PJL INFO ", "C", v72, "PARAMNUM\r\n");
    v21 = copyDataWithPJLCommand(v20, v71);
    v22 = v21;
    v23 = v74;
    if ( v21 )
    {
      v24 = CFStringGetIntValue(v21);
      v25 = 1;
      if ( v24 )
      {
        v65 = v22;
        v64 = v60;
        v73 = v24;
        __little = (char *)v60 - ((v23 * (unsigned int)v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v26 = 0;
        v27 = __little;
        v28 = v72;
        if ( v24 > 0 )
        {
          do
          {
            __sprintf_chk(
              v27,
              0,
              0xFFFFFFFFFFFFFFFFLL,
              "%s%s%d%s%d%s",
              "@PJL DINQUIRE ",
              "C",
              v28,
              "PARAM",
              v26,
              "\r\n");
            v27 += v74;
            ++v26;
          }
          while ( v73 != v26 );
        }
        v23 = v74;
        v29 = copyDatasWithPJLCommands(__little, v73, v71);
        v30 = v29;
        v25 = 1;
        if ( v29 )
        {
          v31 = CFArrayGetCount(v29);
          v32.location = 0LL;
          v32.length = v31;
          CFArrayAppendArray(theArray, v30, v32);
          CFRelease(v30);
          v25 = (int)v67;
        }
        v22 = v65;
      }
      LODWORD(v65) = v25;
      CFRelease(v22);
    }
    v33 = v70;
    __sprintf_chk(v70, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s%d%s", "@PJL INFO ", "M", v72, "PARAMNUM\r\n");
    v34 = copyDataWithPJLCommand(v33, v71);
    v35 = v34;
    LODWORD(v67) = 1;
    if ( v34 )
    {
      v36 = CFStringGetIntValue(v34);
      v37 = 1;
      if ( v36 )
      {
        v67 = v35;
        v64 = v60;
        v73 = v36;
        __little = (char *)v60 - ((v23 * (unsigned int)v36 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v38 = 0;
        v39 = __little;
        v40 = v72;
        if ( v36 > 0 )
        {
          do
          {
            __sprintf_chk(
              v39,
              0,
              0xFFFFFFFFFFFFFFFFLL,
              "%s%s%d%s%d%s",
              "@PJL DINQUIRE ",
              "M",
              v40,
              "PARAM",
              v38,
              "\r\n");
            v39 += v74;
            ++v38;
          }
          while ( v73 != v38 );
        }
        v23 = v74;
        v41 = copyDatasWithPJLCommands(__little, v73, v71);
        v42 = v41;
        v37 = 1;
        if ( v41 )
        {
          v43 = CFArrayGetCount(v41);
          v44.location = 0LL;
          v44.length = v43;
          CFArrayAppendArray(theArray, v42, v44);
          CFRelease(v42);
          v37 = (int)v65;
        }
        v35 = v67;
      }
      LODWORD(v67) = v37;
      CFRelease(v35);
    }
    v45 = v70;
    __sprintf_chk(v70, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s%d%s", "@PJL INFO ", "Y", v72, "PARAMNUM\r\n");
    v46 = copyDataWithPJLCommand(v45, v71);
    v47 = v46;
    if ( !v46 )
      goto LABEL_42;
    v48 = CFStringGetIntValue(v46);
    if ( !v48 )
      break;
    v65 = v47;
    v64 = v60;
    v73 = v48;
    __little = (char *)v60 - ((v23 * (unsigned int)v48 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v49 = 0;
    v50 = __little;
    v51 = v72;
    if ( v48 > 0 )
    {
      do
      {
        __sprintf_chk(v50, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s%d%s%d%s", "@PJL DINQUIRE ", "Y", v51, "PARAM", v49, "\r\n");
        v50 += v74;
        ++v49;
      }
      while ( v73 != v49 );
    }
    v52 = copyDatasWithPJLCommands(__little, v73, v71);
    v53 = v52;
    v54 = 1;
    if ( v52 )
    {
      v55 = CFArrayGetCount(v52);
      v56.location = 0LL;
      v56.length = v55;
      CFArrayAppendArray(theArray, v53, v56);
      CFRelease(v53);
      v54 = (int)v67;
    }
    CFRelease(v65);
    if ( v54 )
      goto LABEL_42;
    v57 = theArray;
    CFArrayInsertValueAtIndex(Mutable, idx, theArray);
    CFRelease(v57);
    v5 = IntValue;
    v6 = v72;
LABEL_39:
    if ( (int)v6 >= v5 )
      goto LABEL_40;
  }
  CFRelease(v47);
LABEL_42:
  CFRelease(theArray);
  Copy = 0LL;
  v58 = Mutable;
LABEL_43:
  CFRelease(v58);
  return Copy;
}

//----- (000000010000D2D1) ----------------------------------------------------
CFDictionaryRef __fastcall copyRetriveDataParametersWithPJL(double a1)
{
  CFDictionaryRef Copy; // rbx
  const __CFArray *v2; // rax
  char *v3; // rbx
  _BOOL4 v4; // r12d
  CFStringRef v5; // r13
  _BOOL4 v6; // r15d
  const void *ValueAtIndex; // rax
  const __CFArray *Mutable; // r15
  const __CFString *v9; // rax
  const __CFString *v10; // r12
  SInt32 IntValue; // ebx
  int v12; // r12d
  char *v13; // r14
  const __CFArray *v14; // rax
  const __CFArray *v15; // rbx
  CFIndex Count; // rax
  CFRange v17; // rdx
  CFStringRef v18; // rax
  SInt32 v19; // ebx
  __int64 v20; // rcx
  int v21; // r12d
  char *v22; // r14
  __int64 v23; // r13
  const __CFArray *v24; // rax
  const __CFArray *v25; // rbx
  int v26; // r15d
  __CFArray *v27; // r12
  CFIndex v28; // rax
  CFRange v29; // rdx
  CFStringRef v30; // rax
  CFStringRef v31; // rbx
  const __CFString *v32; // rax
  SInt32 v33; // ebx
  int v34; // r15d
  char *v35; // r14
  CFArrayRef v36; // r14
  CFStringRef v37; // rax
  CFStringRef v38; // rbx
  __int64 v40; // [rsp+10h] [rbp-470h] BYREF
  __int64 *v41; // [rsp+18h] [rbp-468h]
  CFTypeRef v42; // [rsp+20h] [rbp-460h]
  double v43; // [rsp+28h] [rbp-458h]
  CFArrayRef theArray; // [rsp+30h] [rbp-450h]
  CFMutableDictionaryRef theDict; // [rsp+38h] [rbp-448h]
  char *__little; // [rsp+40h] [rbp-440h]
  CFAllocatorRef alloc; // [rsp+48h] [rbp-438h]
  char cStr[1024]; // [rsp+50h] [rbp-430h] BYREF

  Copy = 0LL;
  if ( a1 > 0.0 )
  {
    alloc = kCFAllocatorDefault;
    Copy = 0LL;
    v43 = a1;
    theDict = CFDictionaryCreateMutable(
                kCFAllocatorDefault,
                0LL,
                &kCFTypeDictionaryKeyCallBacks,
                &kCFTypeDictionaryValueCallBacks);
    if ( theDict )
    {
      v2 = copyHeadAllTableFactorsWithPJL(a1);
      Copy = 0LL;
      if ( !v2 )
        goto LABEL_43;
      theArray = v2;
      __little = (char *)CFArrayGetCount(v2);
      v3 = 0LL;
      v4 = __little == 0LL;
      if ( (__int64)__little <= 0 )
      {
        v6 = __little == 0LL;
      }
      else
      {
        do
        {
          __sprintf_chk(cStr, 0, 0x400uLL, "%s%d", "brheadparan", (_DWORD)v3);
          v5 = CFStringCreateWithCString(alloc, cStr, 0x8000100u);
          v6 = 1;
          if ( v5 )
          {
            ValueAtIndex = CFArrayGetValueAtIndex(theArray, (CFIndex)v3);
            CFDictionaryAddValue(theDict, v5, ValueAtIndex);
            CFRelease(v5);
            v6 = v4;
          }
          ++v3;
          v4 = v6;
        }
        while ( __little != v3 );
      }
      CFRelease(theArray);
      Copy = 0LL;
      if ( v6 )
        goto LABEL_43;
      Mutable = CFArrayCreateMutable(alloc, 0LL, &kCFTypeArrayCallBacks);
      if ( !Mutable )
        goto LABEL_28;
      v9 = copyDataWithPJLCommand("@PJL INFO RATIONUM\r\n", v43);
      v10 = v9;
      if ( v9 )
      {
        IntValue = CFStringGetIntValue(v9);
        if ( IntValue )
        {
          v42 = v10;
          theArray = Mutable;
          v41 = &v40;
          __little = (char *)&v40
                   - ((kPJLCommandMaxLength * (unsigned __int64)(unsigned int)IntValue + 15) & 0xFFFFFFFFFFFFFFF0LL);
          if ( IntValue > 0 )
          {
            v12 = 0;
            v13 = __little;
            do
            {
              __sprintf_chk(v13, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%d%s", "@PJL DINQUIRE KCMYRATIO", v12, "\r\n");
              v13 += kPJLCommandMaxLength;
              ++v12;
            }
            while ( IntValue != v12 );
          }
          v14 = copyDatasWithPJLCommands(__little, IntValue, v43);
          v15 = v14;
          if ( v14 )
          {
            Count = CFArrayGetCount(v14);
            v17.location = 0LL;
            Mutable = theArray;
            v17.length = Count;
            CFArrayAppendArray(theArray, v15, v17);
            CFRelease(v15);
            CFRelease(v42);
            v18 = copyDataWithPJLCommand("@PJL INFO CORRECTIONNUM\r\n", v43);
            if ( v18 )
            {
              v42 = v18;
              v19 = CFStringGetIntValue(v18);
              v41 = &v40;
              v20 = kPJLCommandMaxLength;
              __little = (char *)&v40
                       - ((kPJLCommandMaxLength * (unsigned __int64)(unsigned int)v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
              if ( v19 > 0 )
              {
                v21 = 0;
                v22 = __little;
                do
                {
                  v23 = v20;
                  __sprintf_chk(v22, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%d%s", "@PJL DINQUIRE KCMYCORRECTION", v21, "\r\n");
                  v20 = v23;
                  v22 += v23;
                  ++v21;
                }
                while ( v19 != v21 );
              }
              v24 = copyDatasWithPJLCommands(__little, v19, v43);
              v25 = v24;
              v26 = 1;
              v27 = theArray;
              if ( v24 )
              {
                v28 = CFArrayGetCount(v24);
                v26 = 0;
                v29.location = 0LL;
                v29.length = v28;
                CFArrayAppendArray(v27, v25, v29);
                CFRelease(v25);
              }
              CFRelease(v42);
              if ( v26 )
                goto LABEL_41;
              __sprintf_chk(cStr, 0, 0x400uLL, "%s", "brheadparaw");
              v30 = CFStringCreateWithCString(alloc, cStr, 0x8000100u);
              v31 = v30;
              if ( v30 )
              {
                CFDictionaryAddValue(theDict, v30, v27);
                CFRelease(v31);
              }
              CFRelease(v27);
LABEL_28:
              v32 = copyDataWithPJLCommand("@PJL INFO DROPLETCORRECTNUM\r\n", v43);
              v27 = (__CFArray *)v32;
              Copy = 0LL;
              if ( v32 )
              {
                v33 = CFStringGetIntValue(v32);
                v26 = 1;
                if ( v33 )
                {
                  theArray = v27;
                  v42 = &v40;
                  __little = (char *)&v40
                           - ((kPJLCommandMaxLength * (unsigned __int64)(unsigned int)v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  if ( v33 > 0 )
                  {
                    v34 = 0;
                    v35 = __little;
                    do
                    {
                      __sprintf_chk(
                        v35,
                        0,
                        0xFFFFFFFFFFFFFFFFLL,
                        "%s%d%s",
                        "@PJL DINQUIRE DROPLETCORRECTION",
                        v34,
                        "\r\n");
                      v35 += kPJLCommandMaxLength;
                      ++v34;
                    }
                    while ( v33 != v34 );
                  }
                  v36 = copyDatasWithPJLCommands(__little, v33, v43);
                  v26 = 1;
                  v27 = theArray;
                  if ( v36 )
                  {
                    v26 = 0;
                    __sprintf_chk(cStr, 0, 0x400uLL, "%s", "brheadparadc");
                    v37 = CFStringCreateWithCString(alloc, cStr, 0x8000100u);
                    v38 = v37;
                    if ( v37 )
                    {
                      CFDictionaryAddValue(theDict, v37, v36);
                      CFRelease(v38);
                    }
                    else
                    {
                      v26 = 1;
                    }
                    CFRelease(v36);
                  }
                }
LABEL_41:
                CFRelease(v27);
                Copy = 0LL;
                if ( !v26 )
                  Copy = CFDictionaryCreateCopy(alloc, theDict);
              }
LABEL_43:
              CFRelease(theDict);
              return Copy;
            }
          }
          else
          {
            CFRelease(v42);
            Mutable = theArray;
          }
        }
        else
        {
          CFRelease(v10);
        }
      }
      CFRelease(Mutable);
      Copy = 0LL;
      goto LABEL_43;
    }
  }
  return Copy;
}

//----- (000000010000D90A) ----------------------------------------------------
CFArrayRef __fastcall copyRetriveDataCheckSumParametersWithPJL(double a1)
{
  CFArrayRef result; // rax
  char *v2; // rbx
  double v3; // [rsp+0h] [rbp-30h] BYREF

  result = 0LL;
  if ( a1 != 0.0 )
  {
    v2 = (char *)&v3 - ((3LL * kPJLCommandMaxLength + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v3 = a1;
    __sprintf_chk(v2, 0, 0xFFFFFFFFFFFFFFFFLL, "@PJL DINQUIRE SERIALNUMPRN\r\n");
    __sprintf_chk(&v2[kPJLCommandMaxLength], 0, 0xFFFFFFFFFFFFFFFFLL, "@PJL DINQUIRE BANDINGSUM\r\n");
    __sprintf_chk(&v2[2 * kPJLCommandMaxLength], 0, 0xFFFFFFFFFFFFFFFFLL, "@PJL DINQUIRE DROPLETSUM\r\n");
    return copyDatasWithPJLCommands(v2, 3, v3);
  }
  return result;
}

//----- (000000010000D9D9) ----------------------------------------------------
CFArrayRef __fastcall copyHeadAllTableFactorsWithMIB(double a1)
{
  CFArrayRef Copy; // r13
  char *v2; // r12
  const __CFArray *v3; // rax
  const __CFArray *v4; // r15
  CFIndex Count; // rax
  __int64 v6; // rbx
  CFIndex v7; // rbx
  const __CFString *ValueAtIndex; // rax
  SInt32 IntValue; // r15d
  __CFArray *Mutable; // rax
  char *v11; // r13
  SInt32 v12; // r12d
  char *v13; // r15
  char *v14; // rbx
  const __CFArray *v15; // rbx
  CFIndex v16; // rax
  CFRange v17; // rdx
  char *v18; // rbx
  const __CFArray *v19; // rax
  const __CFArray *v20; // rbx
  CFIndex v21; // rax
  CFRange v22; // rdx
  char *v23; // rbx
  const __CFArray *v24; // rbx
  int v25; // eax
  CFIndex v26; // rax
  CFRange v27; // rdx
  char *v28; // rbx
  const __CFArray *v29; // rax
  const __CFArray *v30; // rbx
  __CFArray *v31; // r15
  CFIndex v32; // rax
  CFRange v33; // rdx
  CFMutableArrayRef v34; // r14
  CFMutableArrayRef v36[2]; // [rsp+0h] [rbp-90h] BYREF
  char *v37; // [rsp+10h] [rbp-80h]
  CFIndex v38; // [rsp+18h] [rbp-78h]
  CFIndex idx; // [rsp+20h] [rbp-70h]
  CFAllocatorRef allocator; // [rsp+28h] [rbp-68h]
  __int64 v41; // [rsp+30h] [rbp-60h]
  int v42; // [rsp+3Ch] [rbp-54h]
  const __CFArray *v43; // [rsp+40h] [rbp-50h]
  CFMutableArrayRef theArray; // [rsp+48h] [rbp-48h]
  char *v45; // [rsp+50h] [rbp-40h]
  double v46; // [rsp+58h] [rbp-38h]

  Copy = 0LL;
  if ( a1 == 0.0 )
    return Copy;
  v36[1] = (CFMutableArrayRef)v36;
  v37 = (char *)v36 - ((kMIBOIDMaxLength + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  v45 = v37;
  Copy = 0LL;
  v46 = a1;
  __sprintf_chk(v37, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.1.1.0");
  __sprintf_chk(
    (char *)v36 - ((kMIBOIDMaxLength + 15LL) & 0xFFFFFFFFFFFFFFF0LL),
    0,
    0xFFFFFFFFFFFFFFFFLL,
    "%s",
    "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.1.2.1.1");
  v2 = (char *)v36 - ((kMIBOIDMaxLength + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  v3 = copyIndexesWithCountOID(v2, v2, v46);
  v4 = v3;
  v43 = v3;
  if ( !v3 )
    return Copy;
  Count = CFArrayGetCount(v3);
  Copy = 0LL;
  if ( !Count )
    goto LABEL_21;
  allocator = kCFAllocatorDefault;
  v6 = Count;
  v38 = Count;
  v36[0] = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
  Copy = 0LL;
  if ( !v36[0] )
    goto LABEL_21;
  if ( v6 <= 0 )
  {
LABEL_18:
    v34 = v36[0];
    Copy = CFArrayCreateCopy(allocator, v36[0]);
    goto LABEL_20;
  }
  v7 = 0LL;
  while ( 1 )
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, v7);
    IntValue = CFStringGetIntValue(ValueAtIndex);
    Mutable = CFArrayCreateMutable(allocator, 0LL, &kCFTypeArrayCallBacks);
    if ( Mutable )
      break;
LABEL_17:
    ++v7;
    v4 = v43;
    if ( v7 >= v38 )
      goto LABEL_18;
  }
  idx = v7;
  theArray = Mutable;
  v11 = v2;
  __sprintf_chk(v2, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.2.1.0");
  v12 = IntValue;
  v13 = v37;
  __sprintf_chk(v37, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.2.2.1.1", v12);
  v14 = v45;
  __sprintf_chk(v45, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.2.2.1.2", v12);
  v15 = copyFactorWithCountOID(v11, v13, v14, v46);
  v42 = 1;
  v41 = 1LL;
  if ( v15 )
  {
    v16 = CFArrayGetCount(v15);
    v41 = 0LL;
    v17.location = 0LL;
    v17.length = v16;
    CFArrayAppendArray(theArray, v15, v17);
    CFRelease(v15);
  }
  __sprintf_chk(v11, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.3.1.0");
  __sprintf_chk(v13, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.3.2.1.1", v12);
  v18 = v45;
  __sprintf_chk(v45, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.3.2.1.2", v12);
  v19 = copyFactorWithCountOID(v11, v13, v18, v46);
  v20 = v19;
  if ( v19 )
  {
    v21 = CFArrayGetCount(v19);
    v22.location = 0LL;
    v22.length = v21;
    CFArrayAppendArray(theArray, v20, v22);
    CFRelease(v20);
    v42 = v41;
  }
  __sprintf_chk(v11, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.4.1.0");
  __sprintf_chk(v13, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.4.2.1.1", v12);
  v23 = v45;
  __sprintf_chk(v45, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.4.2.1.2", v12);
  v24 = copyFactorWithCountOID(v11, v13, v23, v46);
  v25 = 1;
  if ( v24 )
  {
    v26 = CFArrayGetCount(v24);
    v27.location = 0LL;
    v27.length = v26;
    CFArrayAppendArray(theArray, v24, v27);
    CFRelease(v24);
    v25 = v42;
  }
  v42 = v25;
  __sprintf_chk(v11, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.5.1.0");
  __sprintf_chk(v13, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.5.2.1.1", v12);
  v28 = v45;
  __sprintf_chk(v45, 0, 0xFFFFFFFFFFFFFFFFLL, "%s.%d", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.5.2.1.2", v12);
  v2 = v11;
  v29 = copyFactorWithCountOID(v11, v13, v28, v46);
  v30 = v29;
  v31 = theArray;
  if ( v29 )
  {
    v32 = CFArrayGetCount(v29);
    v33.location = 0LL;
    v33.length = v32;
    CFArrayAppendArray(v31, v30, v33);
    CFRelease(v30);
    if ( !v42 )
    {
      v7 = idx;
      CFArrayInsertValueAtIndex(v36[0], idx, v31);
      CFRelease(v31);
      goto LABEL_17;
    }
  }
  CFRelease(v31);
  Copy = 0LL;
  v4 = v43;
  v34 = v36[0];
LABEL_20:
  CFRelease(v34);
LABEL_21:
  CFRelease(v4);
  return Copy;
}

//----- (000000010000DEAD) ----------------------------------------------------
CFDictionaryRef __fastcall copyRetriveDataParametersWithMIB(double a1)
{
  CFDictionaryRef Copy; // r15
  unsigned __int64 v2; // rax
  const __CFArray *v3; // rax
  const __CFArray *v4; // rbx
  _BOOL4 v5; // r15d
  CFStringRef v6; // r13
  _BOOL4 v7; // r12d
  const void *ValueAtIndex; // rax
  char *v9; // rbx
  char *v10; // r14
  char *v11; // r13
  const __CFArray *v12; // r15
  __CFArray *Mutable; // r14
  int v14; // ebx
  const __CFArray *v15; // rbx
  CFIndex Count; // rax
  CFRange v17; // rdx
  CFIndex v18; // rax
  CFRange v19; // rdx
  CFStringRef v20; // rax
  CFStringRef v21; // r13
  char *v22; // r13
  char *v23; // r14
  char *v24; // rbx
  CFArrayRef v25; // r14
  const __CFAllocator *v26; // r13
  CFStringRef v27; // rax
  CFStringRef v28; // r15
  const __CFDictionary *v29; // rbx
  __int64 v31; // [rsp+0h] [rbp-480h] BYREF
  char *v32; // [rsp+8h] [rbp-478h]
  char *v33; // [rsp+10h] [rbp-470h]
  char *v34; // [rsp+18h] [rbp-468h]
  __int64 *v35; // [rsp+20h] [rbp-460h]
  double v36; // [rsp+28h] [rbp-458h]
  CFArrayRef theArray; // [rsp+30h] [rbp-450h]
  CFMutableDictionaryRef theDict; // [rsp+38h] [rbp-448h]
  CFArrayRef otherArray; // [rsp+40h] [rbp-440h]
  CFAllocatorRef alloc; // [rsp+48h] [rbp-438h]
  char cStr[1024]; // [rsp+50h] [rbp-430h] BYREF

  v36 = a1;
  Copy = 0LL;
  if ( a1 != 0.0 )
  {
    Copy = 0LL;
    theDict = CFDictionaryCreateMutable(
                kCFAllocatorDefault,
                0LL,
                &kCFTypeDictionaryKeyCallBacks,
                &kCFTypeDictionaryValueCallBacks);
    if ( theDict )
    {
      alloc = kCFAllocatorDefault;
      v2 = (kMIBOIDMaxLength + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
      v34 = (char *)&v31 - v2;
      v33 = (char *)&v31 - v2 - v2;
      v32 = &v33[-v2];
      v3 = copyHeadAllTableFactorsWithMIB(v36);
      Copy = 0LL;
      if ( v3 )
      {
        v35 = &v31;
        theArray = v3;
        otherArray = (CFArrayRef)CFArrayGetCount(v3);
        v4 = 0LL;
        v5 = otherArray == 0LL;
        if ( (__int64)otherArray <= 0 )
        {
          v7 = otherArray == 0LL;
        }
        else
        {
          do
          {
            __sprintf_chk(cStr, 0, 0x400uLL, "%s%d", "brheadparan", (_DWORD)v4);
            v6 = CFStringCreateWithCString(alloc, cStr, 0x8000100u);
            v7 = 1;
            if ( v6 )
            {
              ValueAtIndex = CFArrayGetValueAtIndex(theArray, (CFIndex)v4);
              CFDictionaryAddValue(theDict, v6, ValueAtIndex);
              CFRelease(v6);
              v7 = v5;
            }
            v4 = (const __CFArray *)((char *)v4 + 1);
            v5 = v7;
          }
          while ( otherArray != v4 );
        }
        CFRelease(theArray);
        Copy = 0LL;
        if ( !v7 )
        {
          Copy = 0LL;
          v9 = v34;
          __sprintf_chk(v34, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.11.1.0");
          v10 = v33;
          __sprintf_chk(v33, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.11.2.1.1");
          v11 = v32;
          __sprintf_chk(v32, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.11.2.1.2");
          otherArray = copyFactorWithCountOID(v9, v10, v11, v36);
          if ( otherArray )
          {
            __sprintf_chk(v9, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.12.1.0");
            __sprintf_chk(v10, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.12.2.1.1");
            __sprintf_chk(v11, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.12.2.1.3");
            v12 = copyFactorWithCountOID(v9, v10, v11, v36);
            if ( v12 )
            {
              Mutable = CFArrayCreateMutable(alloc, 0LL, &kCFTypeArrayCallBacks);
              v14 = 1;
              if ( Mutable )
              {
                v15 = otherArray;
                Count = CFArrayGetCount(otherArray);
                v17.location = 0LL;
                v17.length = Count;
                CFArrayAppendArray(Mutable, v15, v17);
                v18 = CFArrayGetCount(v12);
                v19.location = 0LL;
                v19.length = v18;
                CFArrayAppendArray(Mutable, v12, v19);
                __sprintf_chk(cStr, 0, 0x400uLL, "%s", "brheadparaw");
                v20 = CFStringCreateWithCString(alloc, cStr, 0x8000100u);
                v21 = v20;
                if ( v20 )
                {
                  CFDictionaryAddValue(theDict, v20, Mutable);
                  CFRelease(v21);
                  v14 = 0;
                }
                else
                {
                  v14 = 1;
                }
                CFRelease(Mutable);
              }
              CFRelease(v12);
              CFRelease(otherArray);
              Copy = 0LL;
              if ( !v14 )
              {
                Copy = 0LL;
                v22 = v34;
                __sprintf_chk(v34, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.13.1.0");
                v23 = v33;
                __sprintf_chk(v33, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.13.2.1.1");
                v24 = v32;
                __sprintf_chk(v32, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.13.2.1.2");
                v25 = copyFactorWithCountOID(v22, v23, v24, v36);
                if ( v25 )
                {
                  __sprintf_chk(cStr, 0, 0x400uLL, "%s", "brheadparadc");
                  v26 = alloc;
                  v27 = CFStringCreateWithCString(alloc, cStr, 0x8000100u);
                  v28 = v27;
                  if ( v27 )
                  {
                    v29 = theDict;
                    CFDictionaryAddValue(theDict, v27, v25);
                    CFRelease(v28);
                    CFRelease(v25);
                    Copy = CFDictionaryCreateCopy(v26, v29);
                  }
                  else
                  {
                    CFRelease(v25);
                    Copy = 0LL;
                  }
                }
              }
            }
            else
            {
              CFRelease(otherArray);
              Copy = 0LL;
            }
          }
        }
      }
      CFRelease(theDict);
    }
  }
  return Copy;
}

//----- (000000010000E3EC) ----------------------------------------------------
__int64 __fastcall copyRetriveDataCheckSumParametersWithMIB(double a1)
{
  __int64 result; // rax
  char *v2; // rbx
  __int64 v3; // [rsp+0h] [rbp-40h] BYREF
  double v4; // [rsp+8h] [rbp-38h]

  result = 0LL;
  if ( a1 != 0.0 )
  {
    v2 = (char *)&v3 - ((3LL * kMIBOIDMaxLength + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v4 = a1;
    __sprintf_chk(v2, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.5.1.0");
    __sprintf_chk(&v2[kMIBOIDMaxLength], 0, 0xFFFFFFFFFFFFFFFFLL, "%s", "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.14.1.0");
    __sprintf_chk(
      &v2[2 * kMIBOIDMaxLength],
      0,
      0xFFFFFFFFFFFFFFFFLL,
      "%s",
      "1.3.6.1.4.1.2435.2.3.9.4.2.1.5.1.2.67.14.2.0");
    return copyParametersWithOIDs(v2, 3, v4);
  }
  return result;
}

//----- (000000010000E4D2) ----------------------------------------------------
__int64 __fastcall isNewParameters(const void *a1, const void *a2)
{
  __int64 result; // rax

  LOBYTE(result) = 0;
  if ( a2 && a1 )
    LOBYTE(result) = CFEqual(a1, a2) == 0;
  return (unsigned __int8)result;
}

//----- (000000010000E4F1) ----------------------------------------------------
CFDictionaryRef __fastcall copyBinaryParametersWithHexStringParameters(CFDictionaryRef theDict)
{
  __int64 v1; // rcx
  __int64 Count; // rbx
  __CFDictionary *MutableCopy; // rax
  __int64 v4; // r15
  CFDataRef v5; // rax
  CFDataRef v6; // r12
  CFAllocatorRef allocator[2]; // [rsp+0h] [rbp-50h] BYREF
  CFDictionaryRef Copy; // [rsp+10h] [rbp-40h]
  CFMutableDictionaryRef theDicta; // [rsp+18h] [rbp-38h]

  v1 = 0LL;
  if ( theDict )
  {
    Count = CFDictionaryGetCount(theDict);
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, Count, theDict);
    v1 = 0LL;
    if ( MutableCopy )
    {
      allocator[0] = kCFAllocatorDefault;
      allocator[1] = (CFAllocatorRef)allocator;
      theDicta = MutableCopy;
      CFDictionaryGetKeysAndValues(
        MutableCopy,
        (const void **)((char *)allocator - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL)),
        (const void **)((char *)allocator - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL)));
      v4 = 0LL;
      if ( Count <= 0 )
      {
LABEL_7:
        Copy = CFDictionaryCreateCopy(allocator[0], theDicta);
      }
      else
      {
        Copy = 0LL;
        while ( 1 )
        {
          v5 = copyBinaryDataWithHexStringParameter(*(CFAllocatorRef *)((char *)&allocator[v4]
                                                                      - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL)));
          v6 = v5;
          if ( !v5 )
            break;
          CFDictionarySetValue(
            theDicta,
            *(CFAllocatorRef *)((char *)&allocator[v4] - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL)),
            v5);
          CFRelease(v6);
          if ( ++v4 >= Count )
            goto LABEL_7;
        }
      }
      CFRelease(theDicta);
      return Copy;
    }
  }
  return (CFDictionaryRef)v1;
}

//----- (000000010000E60D) ----------------------------------------------------
CFDictionaryRef __fastcall copyTrimmedBinaryParametersWithHexStringParameters(CFDictionaryRef theDict)
{
  __int64 v1; // rcx
  __int64 Count; // rbx
  __CFDictionary *MutableCopy; // rax
  __int64 v4; // r15
  CFDataRef v5; // rax
  CFDataRef v6; // r12
  CFAllocatorRef allocator[2]; // [rsp+0h] [rbp-50h] BYREF
  CFDictionaryRef Copy; // [rsp+10h] [rbp-40h]
  CFMutableDictionaryRef theDicta; // [rsp+18h] [rbp-38h]

  v1 = 0LL;
  if ( theDict )
  {
    Count = CFDictionaryGetCount(theDict);
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, Count, theDict);
    v1 = 0LL;
    if ( MutableCopy )
    {
      allocator[0] = kCFAllocatorDefault;
      allocator[1] = (CFAllocatorRef)allocator;
      theDicta = MutableCopy;
      CFDictionaryGetKeysAndValues(
        MutableCopy,
        (const void **)((char *)allocator - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL)),
        (const void **)((char *)allocator - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL)));
      v4 = 0LL;
      if ( Count <= 0 )
      {
LABEL_7:
        Copy = CFDictionaryCreateCopy(allocator[0], theDicta);
      }
      else
      {
        Copy = 0LL;
        while ( 1 )
        {
          v5 = copyTrimmedBinaryDataWithHexStringParameter(*(CFAllocatorRef *)((char *)&allocator[v4]
                                                                             - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL)));
          v6 = v5;
          if ( !v5 )
            break;
          CFDictionarySetValue(
            theDicta,
            *(CFAllocatorRef *)((char *)&allocator[v4] - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL)),
            v5);
          CFRelease(v6);
          if ( ++v4 >= Count )
            goto LABEL_7;
        }
      }
      CFRelease(theDicta);
      return Copy;
    }
  }
  return (CFDictionaryRef)v1;
}

//----- (000000010000E729) ----------------------------------------------------
CFDictionaryRef __fastcall copyRetriveDataCheckSumParameters(double a1)
{
  CFArrayRef v1; // r14
  CFDictionaryRef Copy; // r13
  __CFString *v3; // rax
  __CFString *v4; // rbx
  __CFDictionary *v5; // rdi
  CFArrayRef v6; // rax
  __CFDictionary *Mutable; // r15
  CFStringRef v8; // rax
  CFStringRef v9; // rbx
  void *keys; // [rsp+10h] [rbp-450h] BYREF
  void *v12; // [rsp+18h] [rbp-448h] BYREF
  char cStr[1032]; // [rsp+20h] [rbp-440h] BYREF
  void *values; // [rsp+428h] [rbp-38h] BYREF

  if ( *(&gModelInfo + 1) == 14 )
  {
    values = CFSTR("1");
    v1 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
    Copy = 0LL;
    if ( v1 )
    {
      Copy = 0LL;
      __sprintf_chk(cStr, 0, 0x400uLL, "%s", "brheadparas");
      v3 = (__CFString *)CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
      v4 = v3;
      if ( v3 )
      {
        v12 = v1;
        keys = v3;
        Copy = CFDictionaryCreate(
                 kCFAllocatorDefault,
                 (const void **)&keys,
                 (const void **)&v12,
                 1LL,
                 &kCFTypeDictionaryKeyCallBacks,
                 &kCFTypeDictionaryValueCallBacks);
        v5 = (__CFDictionary *)v4;
LABEL_15:
        CFRelease(v5);
        goto LABEL_16;
      }
      goto LABEL_16;
    }
  }
  else
  {
    Copy = 0LL;
    if ( a1 != 0.0 )
    {
      Copy = 0LL;
      if ( (unsigned int)(gGetStatusMode - 1) <= 1 )
      {
        v6 = gGetStatusMode == 1
           ? (CFArrayRef)copyRetriveDataCheckSumParametersWithMIB(a1)
           : copyRetriveDataCheckSumParametersWithPJL(a1);
        v1 = v6;
        Copy = 0LL;
        if ( v6 )
        {
          Copy = 0LL;
          Mutable = CFDictionaryCreateMutable(
                      kCFAllocatorDefault,
                      0LL,
                      &kCFTypeDictionaryKeyCallBacks,
                      &kCFTypeDictionaryValueCallBacks);
          if ( Mutable )
          {
            Copy = 0LL;
            __sprintf_chk(cStr, 0, 0x400uLL, "%s", "brheadparas");
            v8 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
            v9 = v8;
            if ( v8 )
            {
              CFDictionaryAddValue(Mutable, v8, v1);
              Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, Mutable);
              CFRelease(v9);
            }
            v5 = Mutable;
            goto LABEL_15;
          }
LABEL_16:
          CFRelease(v1);
        }
      }
    }
  }
  return Copy;
}
// 100015730: using guessed type __CFString cfstr_1;
// 100015D50: using guessed type int gModelInfo;
// 100016C30: using guessed type int gGetStatusMode;

//----- (000000010000E93E) ----------------------------------------------------
CFDictionaryRef __fastcall copyRetriveDataParameters(double a1)
{
  if ( gGetStatusMode == 2 )
    return copyRetriveDataParametersWithPJL(a1);
  if ( gGetStatusMode == 1 )
    return copyRetriveDataParametersWithMIB(a1);
  return 0LL;
}
// 100016C30: using guessed type int gGetStatusMode;

//----- (000000010000E965) ----------------------------------------------------
__int64 __fastcall BrMakeGammaTableNoCalculateModel(
        unsigned __int16 *a1,
        __int16 *a2,
        __int64 a3,
        char a4,
        int a5,
        unsigned __int8 a6,
        double a7,
        __m128d a8,
        unsigned __int8 a9,
        unsigned __int8 a10,
        int a11)
{
  void *v16; // r9
  int v17; // esi
  unsigned __int8 v18; // di
  unsigned __int8 v19; // r8
  int v20; // eax
  __int16 v21; // cx
  __int64 v22; // rcx
  __int64 v23; // rdx
  unsigned __int16 v24; // cx
  __int64 v25; // rax
  float v26; // xmm2_4
  __int64 i; // rax
  float v28; // xmm2_4
  __int64 j; // rax
  unsigned __int16 v30; // ax
  float v31; // xmm2_4
  float v32; // xmm3_4
  unsigned __int16 v33; // ax
  unsigned __int16 v34; // di
  unsigned __int16 v35; // bx
  float v36; // xmm4_4
  __int64 k; // rcx
  __int64 v38; // rax
  __int16 v39; // di
  char *v40; // r12
  unsigned __int8 v41; // r13
  __int64 v42; // rdi
  __int16 *v43; // rsi
  __int64 m; // rcx
  int v45; // ebx
  unsigned int v46; // eax
  int v47; // r10d
  int v48; // r9d
  int v49; // r14d
  bool v50; // zf
  __int16 *v51; // rsi
  int v52; // r12d
  __int64 v53; // rax
  _WORD *v54; // r13
  __m128d v55; // xmm0
  __m128d v56; // xmm1
  __m128d v57; // xmm0
  __m128d v58; // xmm1
  __int64 v59; // rax
  __m128i v60; // xmm2
  __m128i v61; // xmm3
  _WORD *v62; // rdi
  __m128 v63; // xmm5
  __m128d v64; // xmm0
  __m128d v65; // xmm1
  __m128d v66; // xmm0
  __m128d v67; // xmm1
  __int64 v68; // rax
  __m128i si128; // xmm2
  __m128i v70; // xmm3
  __m128 v71; // xmm5
  __m128d v72; // xmm0
  __m128d v73; // xmm1
  __m128d v74; // xmm0
  __m128d v75; // xmm1
  __int64 v76; // rax
  __m128i v77; // xmm2
  __m128i v78; // xmm3
  __m128 v79; // xmm5
  __int64 v80; // rcx
  __int64 v81; // rsi
  __int16 v82; // ax
  __m128d v83; // xmm0
  __m128d v84; // xmm0
  __m128d v85; // xmm1
  __int64 v86; // rax
  __m128i v87; // xmm2
  __m128i v88; // xmm3
  __m128 v89; // xmm5
  unsigned int v90; // ecx
  int v91; // eax
  unsigned __int16 v92; // si
  __int64 v93; // rdx
  float v94; // xmm1_4
  float v95; // xmm0_4
  unsigned __int16 v96; // si
  float v97; // xmm0_4
  float v98; // xmm2_4
  _WORD *v99; // rax
  int v100; // ecx
  __int64 v101; // rdx
  int v102; // r10d
  __int64 v103; // rcx
  __int64 v104; // rax
  unsigned __int16 v105; // si
  unsigned __int16 v106; // ax
  __int64 v107; // rax
  __int16 v108; // dx
  unsigned __int8 v110; // [rsp+Ch] [rbp-8A4h]
  void *v111; // [rsp+10h] [rbp-8A0h]
  __int64 v113; // [rsp+28h] [rbp-888h]
  unsigned __int16 v114; // [rsp+30h] [rbp-880h]
  __int64 v115; // [rsp+32h] [rbp-87Eh]
  __int64 v116; // [rsp+3Ah] [rbp-876h]
  int v117; // [rsp+42h] [rbp-86Eh]
  __int64 v118[6]; // [rsp+50h] [rbp-860h] BYREF
  _WORD v119[512]; // [rsp+80h] [rbp-830h] BYREF
  _DWORD v120[256]; // [rsp+480h] [rbp-430h] BYREF

  v16 = malloc(2LL * (unsigned int)(a5 + 2));
  if ( !v16 )
    return __stack_chk_guard;
  v17 = a11;
  v18 = a10;
  v19 = a9;
  v20 = *a1;
  v21 = *a2;
  if ( v20 == 255 )
  {
    if ( v21 == 255 )
    {
      v114 = 0;
      if ( a6 == 1 )
      {
        v117 = *(_DWORD *)(a2 + 9);
        v22 = *(_QWORD *)(a2 + 1);
        v23 = *(_QWORD *)(a2 + 5);
      }
      else
      {
        v117 = *(_DWORD *)(a1 + 9);
        v22 = *(_QWORD *)(a1 + 1);
        v23 = *(_QWORD *)(a1 + 5);
      }
      v116 = v23;
      v115 = v22;
      goto LABEL_37;
    }
LABEL_7:
    v114 = 0;
    HIWORD(v117) = ext_uwCalTarget_BC2Model[4 * a6 + a9];
    v24 = HIWORD(v117);
    LOWORD(v115) = (int)((float)HIWORD(v117) / 10.0 + 0.5);
    v25 = 2LL;
    a8 = (__m128d)0x3FE0000000000000uLL;
    while ( 1 )
    {
      *(&v114 + v25) = (int)((float)(int)(v25 * v24) / 10.0 + 0.5);
      if ( v25 == 9 )
        break;
      ++v25;
      v24 = HIWORD(v117);
    }
    goto LABEL_37;
  }
  if ( v21 == 255 )
    goto LABEL_7;
  v26 = (float)(unsigned __int16)(a1[7] + (a1[6] << 8));
  v119[0] = (int)((float)((float)(unsigned __int16)v20 * v26) / 255.0 + 0.5);
  for ( i = 1LL; i != 6; ++i )
    v119[i] = (int)((float)((float)a1[i] * v26) / 255.0 + 0.5);
  LOWORD(v118[0]) = a2[7] + (a2[6] << 8);
  v28 = (float)LOWORD(v118[0]);
  for ( j = 1LL; j != 6; ++j )
    *((_WORD *)v118 + j) = (int)((float)((float)(unsigned __int16)a2[j] * v28) / 255.0 + 0.5);
  v30 = a1[8];
  v31 = 1.0;
  v32 = 1.0;
  if ( v30 )
    v32 = (float)v30 / 100.0;
  v113 = a3;
  v33 = a2[8];
  if ( v33 )
    v31 = (float)v33 / 100.0;
  v34 = v118[0];
  v35 = v119[0];
  v36 = (float)((float)LOWORD(v118[0]) * v31) - (float)((float)v119[0] * v32);
  for ( k = 0LL; ; ++k )
  {
    v38 = (unsigned __int16)(int)((float)(v36 - (float)((float)((float)v34 * v31) - (float)((float)v35 * v32)))
                                * 255.0
                                / v36
                                + 0.5);
    if ( (unsigned int)v38 > 0xFF )
      v38 = 255LL;
    v39 = ext_ubConvTableInside_BC2Model[256 * (unsigned __int64)a9 + v38];
    if ( (_DWORD)k == 1 )
      *(&v114 + k) = v39;
    else
      *(&v114 + 2 * k) = v39;
    if ( k == 5 )
      break;
    v34 = *((_WORD *)v118 + k + 1);
    v35 = v119[k + 1];
  }
  v111 = v16;
  WORD1(v115) = (int)((float)((float)((float)(HIWORD(v115) - (unsigned __int16)v115) / 3.0)
                            + (float)(unsigned __int16)v115)
                    + 0.5);
  a8 = (__m128d)0x3F000000u;
  WORD2(v115) = (int)((float)((float)((float)(HIWORD(v115) - WORD1(v115)) * 0.5) + (float)WORD1(v115)) + 0.5);
  LOWORD(v116) = (int)((float)((float)((float)(WORD1(v116) - HIWORD(v115)) * 0.5) + (float)HIWORD(v115)) + 0.5);
  WORD2(v116) = (int)((float)((float)((float)(HIWORD(v116) - WORD1(v116)) * 0.5) + (float)WORD1(v116)) + 0.5);
  LOWORD(v117) = (int)((float)((float)((float)(HIWORD(v117) - HIWORD(v116)) * 0.5) + (float)HIWORD(v116)) + 0.5);
  LOWORD(v120[0]) = v114;
  v110 = a6;
  v40 = (char *)&ext_ubConvTableBase_BC2Model + 44 * a6;
  v41 = v40[11 * a9];
  v42 = 0LL;
  v43 = (__int16 *)v120;
  for ( m = 0LL; m != 10; ++m )
  {
    v45 = v41;
    v41 = v40[11 * a9 + 1 + m];
    v46 = (unsigned __int16)(v45 + 1);
    if ( v46 <= v41 )
    {
      v47 = *(&v114 + m);
      v48 = *((unsigned __int16 *)&v115 + m) - v47;
      v49 = v45 + 2;
      do
      {
        *((_WORD *)v120 + (unsigned __int16)(v49 - 1)) = v47 + (int)(v48 * (v46 - v45)) / (v41 - v45);
        v46 = (unsigned __int16)v49++;
      }
      while ( v46 <= v41 );
    }
  }
  v19 = a9;
  do
  {
    *(&v114 + v42++) = *v43;
    v43 += 10;
  }
  while ( v42 != 11 );
  a3 = v113;
  v16 = v111;
  a6 = v110;
  v18 = a10;
  v17 = a11;
LABEL_37:
  v50 = v17 == 9;
  v51 = ext_uwCalTarget_BC2Model;
  if ( v50 )
    v51 = ext_uwCalTarget_ECLModel;
  v52 = (unsigned __int16)v51[4 * a6 + v19];
  v53 = 0LL;
  v54 = v16;
  if ( v18 < 3u )
  {
    do
    {
      *((float *)v118 + v53) = (float)*(&v114 + v53);
      ++v53;
    }
    while ( v53 != 11 );
    CorrectSpline_1(v118, (__int64)v120, a5);
    if ( v18 == 2 )
    {
      v64 = (__m128d)(unsigned int)v120[a5 - 1];
      v64.f64[0] = (float)((float)((float)(*(float *)v64.f64 * 80.0) / 100.0) - (float)v114);
      v65 = 0LL;
      v65.f64[0] = (double)v114;
      v66 = _mm_unpacklo_pd(v64, v64);
      v67 = _mm_unpacklo_pd(v65, v65);
      v68 = 0LL;
      si128 = _mm_load_si128((const __m128i *)&xmmword_100010140);
      v70 = _mm_load_si128((const __m128i *)&xmmword_100010150);
      v62 = v54;
      do
      {
        v71 = _mm_div_ps(
                _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v68), 0), si128), v70)),
                (__m128)xmmword_100010160);
        *(__m128 *)&v119[2 * v68] = _mm_movelh_ps(
                                      _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v71), v66), v67)),
                                      _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v71, v71)), v66), v67)));
        v68 += 4LL;
      }
      while ( v68 != 256 );
LABEL_83:
      if ( (_WORD)a5 )
      {
        v102 = a5 - 1;
        v103 = 0LL;
        do
        {
          v104 = 0LL;
          do
          {
            if ( *(float *)&v120[v104] >= *(float *)&v119[2 * v103] )
              break;
            ++v104;
          }
          while ( (unsigned __int16)v104 < (unsigned int)(unsigned __int16)a5 );
          if ( !(_WORD)v103 )
            LOWORD(v104) = 0;
          v105 = v104;
          if ( (_DWORD)v103 == v102 && (unsigned __int16)v104 != v102 )
            v105 = a5 - 1;
          if ( (_WORD)v103 != 0 && v105 == 0 )
            v105 = 1;
          v106 = v105;
          if ( v105 > v102 )
            v106 = a5 - 1;
          v62[v103++] = v106;
        }
        while ( (unsigned __int16)v103 != (unsigned __int16)a5 );
      }
      goto LABEL_97;
    }
    v83 = 0LL;
    v83.f64[0] = (float)(v52 - v114);
    a8.f64[0] = (double)v114;
    v84 = _mm_unpacklo_pd(v83, v83);
    v85 = _mm_unpacklo_pd(a8, a8);
    v86 = 0LL;
    v87 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v88 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    do
    {
      v89 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v86), 0), v87), v88)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v119[2 * v86] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v89), v84), v85)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v89, v89)), v84), v85)));
      v86 += 4LL;
    }
    while ( v86 != 256 );
    v90 = 80 * a5 / 0x64u;
    v91 = a5 - 1;
    v92 = v90;
    if ( (unsigned __int16)v90 > (unsigned int)a5 )
    {
      v92 = a5 - 1;
      LOWORD(v90) = a5 - 1;
    }
    v93 = v92;
    v94 = *(float *)&v119[2 * v92];
    v95 = *(float *)&v120[v91];
    if ( v94 > v95 )
    {
      if ( (unsigned __int16)v90 >= 0x33u )
      {
        if ( v95 <= v94 )
        {
          v96 = v92 - 1;
          v62 = v54;
          while ( v96 >= 0x33u )
          {
            v94 = *((float *)&v118[5] + v93-- + 1);
            --v96;
            if ( v95 > v94 )
              goto LABEL_78;
          }
          v94 = *(float *)&v120[v91];
        }
        else
        {
          v62 = v54;
LABEL_78:
          LOWORD(v90) = v93;
        }
        goto LABEL_80;
      }
      v94 = *(float *)&v120[v91];
    }
    v62 = v54;
LABEL_80:
    if ( (unsigned __int16)v90 < (unsigned int)(unsigned __int16)a5 )
    {
      v97 = v95 - v94;
      v98 = (float)(v91 - (unsigned __int16)v90);
      v99 = &v119[2 * (unsigned __int16)v90];
      v100 = (unsigned __int16)(a5 - v90);
      v101 = 0LL;
      do
      {
        *(float *)&v99[2 * v101] = (float)((float)((float)(int)v101 * v97) / v98) + v94;
        ++v101;
      }
      while ( v100 != (unsigned __int16)v101 );
    }
    goto LABEL_83;
  }
  do
  {
    *((float *)v118 + v53) = (float)*(&v114 + v53);
    ++v53;
  }
  while ( v53 != 11 );
  CorrectSpline_1(v118, (__int64)v120, a5);
  if ( v18 == 5 )
  {
    v55 = (__m128d)(unsigned int)v120[a5 - 1];
    v55.f64[0] = (float)((float)((float)(*(float *)v55.f64 * 50.0) / 100.0) - (float)v114);
    v56 = 0LL;
    v56.f64[0] = (double)v114;
    v57 = _mm_unpacklo_pd(v55, v55);
    v58 = _mm_unpacklo_pd(v56, v56);
    v59 = 0LL;
    v60 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v61 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    v62 = v54;
    do
    {
      v63 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v59), 0), v60), v61)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v119[2 * v59] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v63), v57), v58)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v63, v63)), v57), v58)));
      v59 += 4LL;
    }
    while ( v59 != 256 );
  }
  else
  {
    v72 = 0LL;
    v72.f64[0] = (float)((float)((float)((float)v52 * 70.0) / 100.0) - (float)v114);
    v73 = 0LL;
    v73.f64[0] = (double)v114;
    v74 = _mm_unpacklo_pd(v72, v72);
    v75 = _mm_unpacklo_pd(v73, v73);
    v76 = 0LL;
    v77 = _mm_load_si128((const __m128i *)&xmmword_100010140);
    v78 = _mm_load_si128((const __m128i *)&xmmword_100010150);
    v62 = v54;
    do
    {
      v79 = _mm_div_ps(
              _mm_cvtepi32_ps(_mm_and_si128(_mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v76), 0), v77), v78)),
              (__m128)xmmword_100010160);
      *(__m128 *)&v119[2 * v76] = _mm_movelh_ps(
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(v79), v74), v75)),
                                    _mm_cvtpd_ps(_mm_add_pd(_mm_mul_pd(_mm_cvtps_pd(_mm_movehl_ps(v79, v79)), v74), v75)));
      v76 += 4LL;
    }
    while ( v76 != 256 );
  }
  if ( (_WORD)a5 )
  {
    v80 = 0LL;
    do
    {
      v81 = 0LL;
      do
      {
        if ( *(float *)&v120[v81] >= *(float *)&v119[2 * v80] )
          break;
        ++v81;
      }
      while ( (unsigned __int16)v81 < (unsigned int)(unsigned __int16)a5 );
      if ( !(_WORD)v80 )
        LOWORD(v81) = 0;
      if ( (_WORD)v80 != 0 && (_WORD)v81 == 0 )
        LOWORD(v81) = 1;
      v82 = v81;
      if ( (unsigned __int16)v81 > a5 - 1 )
        v82 = a5 - 1;
      v62[v80++] = v82;
    }
    while ( (unsigned __int16)v80 != (unsigned __int16)a5 );
  }
LABEL_97:
  if ( (_WORD)a5 )
  {
    v107 = 0LL;
    do
    {
      v108 = v62[v107];
      if ( a4 == 1 )
        *(_WORD *)(a3 + 2 * v107) = v108;
      else
        *(_BYTE *)(a3 + v107) = v108;
      ++v107;
    }
    while ( (int)v107 < a5 );
  }
  free(v62);
  return __stack_chk_guard;
}
// 100010140: using guessed type __int128 xmmword_100010140;
// 100010150: using guessed type __int128 xmmword_100010150;
// 100010160: using guessed type __int128 xmmword_100010160;
// 100016740: using guessed type _WORD ext_uwCalTarget_BC2Model[16];
// 100016760: using guessed type __int16 ext_uwCalTarget_ECLModel[3];
// 100016810: using guessed type unsigned __int8 ext_ubConvTableInside_BC2Model[1024];

//----- (000000010000F42E) ----------------------------------------------------
void __fastcall CorrectSpline_1(__int64 *a1, __int64 a2, int a3)
{
  float *v3; // r13
  _QWORD *v4; // r12
  void *v5; // rbx
  float *v6; // r15
  float *v7; // rax
  float *v9; // r14
  float v10; // xmm0_4
  __int64 v11; // rax
  __int64 i; // rax
  float v13; // xmm1_4
  float v14; // xmm2_4
  __int64 v15; // rax
  float v16; // xmm3_4
  float v17; // xmm4_4
  float v18; // xmm5_4
  float v19; // xmm3_4
  float v20; // xmm4_4
  float v21; // xmm3_4
  float v22; // xmm2_4
  __int64 j; // rax
  float v24; // xmm1_4
  float v25; // xmm5_4
  float v26; // xmm6_4
  float v27; // xmm7_4
  float v28; // xmm2_4
  float v29; // xmm1_4
  __int64 v30; // rax
  float v31; // xmm2_4
  __int64 v32; // rax
  float v33; // xmm3_4
  int v34; // ecx
  int v35; // esi
  int v36; // edx
  int v37; // edx
  bool v38; // cc
  int v39; // esi
  __int64 v40; // rcx
  float v41; // xmm4_4
  float v42; // xmm5_4
  float v43; // xmm7_4
  float v44; // xmm4_4
  float v45; // xmm3_4

  v3 = (float *)malloc(0x40uLL);
  v4 = malloc(0x40uLL);
  v5 = malloc(0x40uLL);
  v6 = (float *)malloc(0x40uLL);
  v7 = (float *)malloc(0x40uLL);
  v9 = v7;
  *((_QWORD *)v3 + 7) = 0LL;
  *((_QWORD *)v3 + 6) = 0LL;
  *((_QWORD *)v3 + 5) = 0LL;
  *((_QWORD *)v3 + 4) = 0LL;
  *((_QWORD *)v3 + 3) = 0LL;
  *((_QWORD *)v3 + 2) = 0LL;
  *((_QWORD *)v3 + 1) = 0LL;
  *(_QWORD *)v3 = 0LL;
  v4[7] = 0LL;
  v4[6] = 0LL;
  v4[5] = 0LL;
  v4[4] = 0LL;
  v4[3] = 0LL;
  v4[2] = 0LL;
  v4[1] = 0LL;
  *v4 = 0LL;
  if ( v3 )
  {
    if ( v4 )
    {
      if ( v5 )
      {
        if ( v6 )
        {
          if ( v7 )
          {
            v10 = (float)(a3 - 1);
            *((_DWORD *)v4 + 10) = *((_DWORD *)a1 + 10);
            v4[4] = a1[4];
            v4[3] = a1[3];
            v4[2] = a1[2];
            v11 = *a1;
            v4[1] = a1[1];
            *v4 = v11;
            for ( i = 0LL; i != 11; ++i )
              v3[i] = (float)((float)(int)i * v10) / 10.0;
            *((_DWORD *)v5 + 10) = 0;
            *(_DWORD *)v5 = 0;
            v13 = *v3;
            v14 = *(float *)v4;
            v15 = 0LL;
            v16 = *v3;
            do
            {
              v17 = v3[v15 + 1];
              v18 = v17 - v16;
              v9[v15] = v17 - v16;
              v19 = *((float *)v4 + v15 + 1);
              v6[++v15] = (float)(v19 - v14) / v18;
              v14 = v19;
              v16 = v17;
            }
            while ( v15 != 10 );
            v20 = v6[2];
            v21 = (float)(*v9 * -0.0) + (float)(v20 - v6[1]);
            *((float *)v5 + 1) = v21;
            v22 = (float)(v3[2] - v13) + (float)(v3[2] - v13);
            v6[1] = v22;
            for ( j = 0LL; j != 8; ++j )
            {
              v24 = v9[j + 1];
              v25 = v24 / v22;
              v26 = v6[j + 3];
              v27 = (float)(v26 - v20) - (float)(v21 * (float)(v24 / v22));
              *((float *)v5 + j + 2) = v27;
              v28 = v3[j + 3] - v3[j + 1];
              v22 = (float)(v28 + v28) - (float)(v25 * v24);
              v6[j + 2] = v22;
              v21 = v27;
              v20 = v26;
            }
            v29 = *((float *)v5 + 10);
            *((float *)v5 + 9) = *((float *)v5 + 9) - (float)(v9[9] * v29);
            v30 = 9LL;
            do
            {
              v31 = (float)(*((float *)v5 + v30) - (float)(v29 * v9[v30])) / v6[v30];
              *((float *)v5 + v30--) = v31;
              v29 = v31;
            }
            while ( (int)v30 > 0 );
            v32 = 0LL;
            if ( a3 > 0 )
            {
              do
              {
                v33 = (float)(int)v32;
                v34 = 10;
                v35 = 0;
                do
                {
                  while ( 1 )
                  {
                    v36 = (v35 + v34) / 2;
                    if ( v33 <= v3[v36] )
                      break;
                    v37 = v36 + 1;
                    v35 = v37;
                    if ( v37 >= v34 )
                      goto LABEL_20;
                  }
                  v38 = v35 < v36;
                  v34 = (v35 + v34) / 2;
                  v37 = v35;
                }
                while ( v38 );
LABEL_20:
                v39 = v37 - (v37 > 0);
                v40 = v39 + 1;
                v41 = v3[v39];
                v42 = v3[v40] - v41;
                v43 = *((float *)v5 + v39);
                v44 = (float)((float)((float)((float)((float)(*((float *)v4 + v40) - *((float *)v4 + v39)) / v42)
                                            - (float)((float)((float)(v43 + v43) + *((float *)v5 + v40)) * v42))
                                    + (float)((float)((float)(v43 * 3.0)
                                                    + (float)((float)((float)(*((float *)v5 + v40) - v43)
                                                                    * (float)(v33 - v41))
                                                            / v42))
                                            * (float)(v33 - v41)))
                            * (float)(v33 - v41))
                    + *((float *)v4 + v39);
                v45 = (float)(a3 - 1);
                if ( v44 <= v10 )
                {
                  v45 = v44;
                  if ( v44 < 0.0 )
                    v45 = 0.0;
                }
                *(float *)(a2 + 4 * v32++) = v45;
              }
              while ( (_DWORD)v32 != a3 );
            }
          }
        }
      }
    }
  }
  if ( v3 )
    free(v3);
  if ( v4 )
    free(v4);
  if ( v5 )
    free(v5);
  if ( v6 )
    free(v6);
  if ( v9 )
    free(v9);
}

// nfuncs=256 queued=131 decompiled=131 lumina nreq=0 worse=0 better=0
// ALL OK, 131 function(s) have been successfully decompiled
